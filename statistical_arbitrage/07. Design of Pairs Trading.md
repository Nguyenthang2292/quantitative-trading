## 1. Pairs Trading có lợi nhuận không?
*Pairs trading* dựa trên giả định rằng mối quan hệ lịch sử giữa hai công cụ tài chính sẽ được duy trì trong tương lai. Tuy nhiên, điều này không phải lúc nào cũng đúng vì mối quan hệ *cointegration* có thể thay đổi theo thời gian do nhiều yếu tố như:

- Điều kiện thị trường.
- Xu hướng ngành.
- Sự kiện cụ thể liên quan đến công ty.
Do đó, *pairs trading* tiềm ẩn rủi ro và yêu cầu nhà giao dịch phải giám sát chặt chẽ mối quan hệ giữa các công cụ, cũng như sử dụng các kỹ thuật quản lý rủi ro để bảo vệ vị thế giao dịch của mình.

Một số nghiên cứu cho thấy *pairs trading* có thể tạo ra lợi nhuận *(Avellaneda & Lee, 2010; Elliott et al., 2005; Gatev et al., 2006)*, trong khi những nghiên cứu khác cho rằng mối quan hệ cointegration không được duy trì ổn định theo thời gian *(Chan, 2013; Clegg, 2014)*.

## Những cảnh báo khi sử dụng *Pairs Trading*:
1. Chi phí giao dịch:
 - Phí giao dịch có thể lớn hơn cả lợi nhuận kiếm được từ *spread*.

2. Hiệu quả giảm dần:
 - Một chiến lược từng hiệu quả trong quá khứ có thể không còn hiệu quả trong thời gian gần đây.

3. Khó khăn kỹ thuật:
 - Thanh khoản thấp khi bán khống.
 - Nguy cơ *margin call* (bị yêu cầu bổ sung ký quỹ khi giá biến động bất lợi).
 - Cạnh tranh giữa các nhà giao dịch tần suất cao.

## Giải pháp:
- Sử dụng lọc Kalman *(Kalman Filter)* để ước tính một mối quan hệ *cointegration* thay đổi theo thời gian.
- Sử dụng mô hình **VECM** *(Vector Error Correction Model)* để khắc phục các hạn chế về *cointegration*.

## 2. Thiết kế Pairs Trading
Phần này giới thiệu chi tiết về thiết kế chiến lược pairs trading. Mục tiêu của chiến lược là giao dịch một *spread* hồi quy về trung bình có lợi nhuận, bao gồm các bước chính như:
1. Xác định cặp tài sản có quan hệ *cointegration*:
- Từ các bước sàng lọc cơ bản đến các kiểm tra thống kê phức tạp.
2. Thiết kế chiến lược giao dịch:
- Dựa trên việc lựa chọn ngưỡng $$𝑠_0$$ hoặc sử dụng các phương pháp phức tạp hơn.

**Các phương pháp nâng cao:**
- Lọc *Kalman*: Dùng để ước tính một mối quan hệ *cointegration* thay đổi theo thời gian.
- Mở rộng *pairs trading*: Áp dụng chiến lược này cho hơn hai tài sản.

## 3. Pre-screening (Sàng lọc sơ bộ)
### 1. Tổng quan về Prescreening:
Sàng lọc sơ bộ (*pre-screening*) là một quá trình đơn giản và tiết kiệm chi phí, trong đó nhiều cặp tài sản có thể được loại bỏ một cách nhanh chóng, chỉ giữ lại một số cặp tiềm năng để phân tích sâu hơn.
Một thước đo phổ biến để đánh giá *cointegration* là khoảng cách giá chuẩn hóa ***(Normalized Price Distance - NPD)***.

### 2. Công thức NPD:
```math
\text{NPD} = \sum_{t=1}^{T} \left( \tilde{p}_{1t} - \tilde{p}_{2t} \right)^2
```
**Trong đó:**
- $$\tilde{p}_ {1t}$$ và $$\tilde{p}_{2t}$$ là giá chuẩn hóa:
  
```math
  \tilde{p}_{1t} = \frac{p_{1t}}{p_{10}}, \quad \tilde{p}_{2t} = \frac{p_{2t}}{p_{20}}
```
  - $$p_{1t}, p_{2t}$$ là giá gốc của hai tài sản.
  - $$p_{10}, p_{20}$$ là giá tại thời điểm ban đầu.

**Ý nghĩa:**
- NPD đo lường sự khác biệt giữa các giá chuẩn hóa theo thời gian. Nếu NPD nhỏ, nghĩa là sự khác biệt giữa các giá chuẩn hóa ổn định trong dài hạn → cặp tài sản có tiềm năng *cointegration*.

### 3. Prescreening với Log-Prices (giá log):
Một thước đo tương tự cũng có thể được định nghĩa với *log-prices* \( y_{1t} \) và \( y_{2t} \) bằng cách trừ đi giá trị tại thời điểm ban đầu:
```math
\tilde{y}_{1t} = y_{1t} - y_{10}, \quad \tilde{y}_{2t} = y_{2t} - y_{20}
```

- Chuỗi $$\tilde{y}_ {1t}$$ và $$\tilde{y}_{2t}$$ đại diện cho sự khác biệt dài hạn của chuỗi giá log (tương tự *log-returns*).

### 4. Ý nghĩa thực tế:
- *Pre-screening* giúp nhanh chóng loại bỏ những cặp tài sản không có tiềm năng *cointegration* để tập trung phân tích kỹ hơn vào các cặp có giá trị NPD nhỏ.
- Điều này làm giảm thời gian và chi phí tính toán khi thực hiện chiến lược *pairs trading* trên nhiều cặp tài sản.

### Tóm tắt:
- *Prescreening* là bước đầu tiên trong quy trình tìm kiếm cặp tài sản *cointegration* tiềm năng.
- NPD đo lường sự khác biệt giữa các giá chuẩn hóa theo thời gian. Nếu NPD thấp, hai chuỗi thời gian có thể có mối quan hệ *cointegration* mạnh.
- Phương pháp này cũng có thể áp dụng cho *log-prices* để đo lường các biến động dài hạn của chuỗi thời gian.

### Ví dụ code:
Ví dụ phương pháp **NPD** và **Log-Prices** với 1 list các pair ví dụ: pairs = ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD", "USDCHF", "NZDUSD"] (sử dụng giá [close] cho mỗi pair)
```python
# Reimport necessary libraries after the environment reset
import pandas as pd
import numpy as np
from itertools import combinations
import matplotlib.pyplot as plt

# Tạo chuỗi dữ liệu giả lập cho các cặp tiền tệ
np.random.seed(42)
T = 200  # Số lượng điểm dữ liệu
pairs = ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD", "USDCHF", "NZDUSD"]
prices_data = {}

# Giả lập dữ liệu giá đóng cửa cho mỗi cặp tiền tệ
for pair in pairs:
    initial_price = np.random.uniform(1.0, 2.0)  # Giá ban đầu ngẫu nhiên
    returns = np.random.normal(0, 0.01, T)  # Lợi nhuận ngẫu nhiên
    prices_data[pair] = initial_price * np.exp(np.cumsum(returns))  # Giá đóng cửa giả lập

# Tạo DataFrame chứa giá đóng cửa của tất cả các cặp tiền tệ
df_prices = pd.DataFrame(prices_data, index=pd.date_range(start='2022-01-01', periods=T))

# Tính toán khoảng cách giá chuẩn hóa (NPD) cho từng cặp
npd_results = {}
for pair1, pair2 in combinations(pairs, 2):
    # Giá chuẩn hóa
    norm_prices_1 = df_prices[pair1] / df_prices[pair1].iloc[0]
    norm_prices_2 = df_prices[pair2] / df_prices[pair2].iloc[0]
    # Tính NPD
    npd = np.sum((norm_prices_1 - norm_prices_2) ** 2)
    npd_results[(pair1, pair2)] = npd

# Tính toán log-prices
log_prices = np.log(df_prices)

# Tính toán khoảng cách log-prices cho từng cặp
log_distance_results = {}
for pair1, pair2 in combinations(pairs, 2):
    shifted_log_1 = log_prices[pair1] - log_prices[pair1].iloc[0]
    shifted_log_2 = log_prices[pair2] - log_prices[pair2].iloc[0]
    log_distance = np.sum((shifted_log_1 - shifted_log_2) ** 2)
    log_distance_results[(pair1, pair2)] = log_distance

# Chuyển kết quả thành DataFrame để dễ quan sát
npd_df = pd.DataFrame.from_dict(npd_results, orient='index', columns=['NPD'])
log_distance_df = pd.DataFrame.from_dict(log_distance_results, orient='index', columns=['Log-Price Distance'])

# Sắp xếp theo thứ tự tăng dần
npd_df_sorted = npd_df.sort_values(by='NPD')
log_distance_df_sorted = log_distance_df.sort_values(by='Log-Price Distance')

# Hiển thị kết quả
print(npd_df_sorted,log_distance_df_sorted)
```
### Result
>(                       NPD
>(USDJPY, AUDUSD)  0.223389
>(USDJPY, NZDUSD)  0.476154
>(AUDUSD, NZDUSD)  0.690620
>(EURUSD, AUDUSD)  1.135016
>(EURUSD, USDJPY)  1.603391,
>                  Log-Price Distance
>(USDJPY, AUDUSD)            0.227109
>(USDJPY, NZDUSD)            0.512831
>(AUDUSD, NZDUSD)            0.763408
>(EURUSD, AUDUSD)            1.118013
>(EURUSD, USDJPY)            1.572460)

