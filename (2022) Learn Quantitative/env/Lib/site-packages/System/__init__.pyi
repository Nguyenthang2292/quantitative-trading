from typing import overload
import abc
import datetime
import typing
import warnings

import System
import System.Buffers
import System.Collections
import System.Collections.Generic
import System.Collections.ObjectModel
import System.ComponentModel
import System.Configuration.Assemblies
import System.Diagnostics
import System.Diagnostics.CodeAnalysis
import System.Globalization
import System.IO
import System.Numerics
import System.Reflection
import System.Runtime.CompilerServices
import System.Runtime.ExceptionServices
import System.Runtime.InteropServices
import System.Runtime.Remoting
import System.Runtime.Serialization
import System.Security
import System.Security.Principal
import System.Text
import System.Threading
import System.Threading.Tasks

System_Range = typing.Any
System_ReadOnlyMemory = typing.Any
System_TimeZoneInfo = typing.Any
System_TimeZoneInfo_AdjustmentRule = typing.Any
System_TimeZoneInfo_TransitionTime = typing.Any
System_Int128 = typing.Any
System_Guid = typing.Any
System_Lazy = typing.Any
System_Memory = typing.Any
System_TimeOnly = typing.Any
System_DateTimeOffset = typing.Any
System_DateOnly = typing.Any
System_UInt128 = typing.Any
System_IntPtr = typing.Any
System_Index = typing.Any
System_ValueTuple = typing.Any
System_UIntPtr = typing.Any
System_Half = typing.Any
System_Version = typing.Any
System_ConsoleKeyInfo = typing.Any

System_ISpanParsable_TSelf = typing.TypeVar("System_ISpanParsable_TSelf")
System_ReadOnlyMemory_T = typing.TypeVar("System_ReadOnlyMemory_T")
System_MemoryExtensions_Trim_T = typing.TypeVar("System_MemoryExtensions_Trim_T")
System_MemoryExtensions_TrimStart_T = typing.TypeVar("System_MemoryExtensions_TrimStart_T")
System_MemoryExtensions_TrimEnd_T = typing.TypeVar("System_MemoryExtensions_TrimEnd_T")
System_MemoryExtensions_Contains_T = typing.TypeVar("System_MemoryExtensions_Contains_T")
System_MemoryExtensions_IndexOf_T = typing.TypeVar("System_MemoryExtensions_IndexOf_T")
System_MemoryExtensions_LastIndexOf_T = typing.TypeVar("System_MemoryExtensions_LastIndexOf_T")
System_MemoryExtensions_IndexOfAnyExcept_T = typing.TypeVar("System_MemoryExtensions_IndexOfAnyExcept_T")
System_MemoryExtensions_LastIndexOfAnyExcept_T = typing.TypeVar("System_MemoryExtensions_LastIndexOfAnyExcept_T")
System_MemoryExtensions_IndexOfAnyInRange_T = typing.TypeVar("System_MemoryExtensions_IndexOfAnyInRange_T")
System_MemoryExtensions_IndexOfAnyExceptInRange_T = typing.TypeVar("System_MemoryExtensions_IndexOfAnyExceptInRange_T")
System_MemoryExtensions_LastIndexOfAnyInRange_T = typing.TypeVar("System_MemoryExtensions_LastIndexOfAnyInRange_T")
System_MemoryExtensions_LastIndexOfAnyExceptInRange_T = typing.TypeVar("System_MemoryExtensions_LastIndexOfAnyExceptInRange_T")
System_MemoryExtensions_IndexOfAny_T = typing.TypeVar("System_MemoryExtensions_IndexOfAny_T")
System_MemoryExtensions_LastIndexOfAny_T = typing.TypeVar("System_MemoryExtensions_LastIndexOfAny_T")
System_MemoryExtensions_BinarySearch_TComparable = typing.TypeVar("System_MemoryExtensions_BinarySearch_TComparable")
System_MemoryExtensions_BinarySearch_T = typing.TypeVar("System_MemoryExtensions_BinarySearch_T")
System_MemoryExtensions_BinarySearch_TComparer = typing.TypeVar("System_MemoryExtensions_BinarySearch_TComparer")
System_MemoryExtensions_Sort_TComparer = typing.TypeVar("System_MemoryExtensions_Sort_TComparer")
System_MemoryExtensions_Replace_T = typing.TypeVar("System_MemoryExtensions_Replace_T")
System_MemoryExtensions_AsSpan_T = typing.TypeVar("System_MemoryExtensions_AsSpan_T")
System_MemoryExtensions_SequenceEqual_T = typing.TypeVar("System_MemoryExtensions_SequenceEqual_T")
System_MemoryExtensions_SequenceCompareTo_T = typing.TypeVar("System_MemoryExtensions_SequenceCompareTo_T")
System_MemoryExtensions_StartsWith_T = typing.TypeVar("System_MemoryExtensions_StartsWith_T")
System_MemoryExtensions_EndsWith_T = typing.TypeVar("System_MemoryExtensions_EndsWith_T")
System_MemoryExtensions_Reverse_T = typing.TypeVar("System_MemoryExtensions_Reverse_T")
System_MemoryExtensions_AsMemory_T = typing.TypeVar("System_MemoryExtensions_AsMemory_T")
System_MemoryExtensions_CopyTo_T = typing.TypeVar("System_MemoryExtensions_CopyTo_T")
System_MemoryExtensions_Overlaps_T = typing.TypeVar("System_MemoryExtensions_Overlaps_T")
System_MemoryExtensions_Sort_T = typing.TypeVar("System_MemoryExtensions_Sort_T")
System_MemoryExtensions_Sort_TKey = typing.TypeVar("System_MemoryExtensions_Sort_TKey")
System_MemoryExtensions_Sort_TValue = typing.TypeVar("System_MemoryExtensions_Sort_TValue")
System_MemoryExtensions_CommonPrefixLength_T = typing.TypeVar("System_MemoryExtensions_CommonPrefixLength_T")
System_MemoryExtensions_AppendFormatted_TryWriteInterpolatedStringHandler_T = typing.TypeVar("System_MemoryExtensions_AppendFormatted_TryWriteInterpolatedStringHandler_T")
System_Activator_CreateInstance_T = typing.TypeVar("System_Activator_CreateInstance_T")
System_SByte_CreateChecked_TOther = typing.TypeVar("System_SByte_CreateChecked_TOther")
System_SByte_CreateSaturating_TOther = typing.TypeVar("System_SByte_CreateSaturating_TOther")
System_SByte_CreateTruncating_TOther = typing.TypeVar("System_SByte_CreateTruncating_TOther")
System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromChecked_TOther = typing.TypeVar("System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromChecked_TOther")
System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromSaturating_TOther = typing.TypeVar("System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromSaturating_TOther")
System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromTruncating_TOther = typing.TypeVar("System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromTruncating_TOther")
System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToChecked_TOther = typing.TypeVar("System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToChecked_TOther")
System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToSaturating_TOther = typing.TypeVar("System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToSaturating_TOther")
System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToTruncating_TOther = typing.TypeVar("System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToTruncating_TOther")
System_String_Create_TState = typing.TypeVar("System_String_Create_TState")
System_String_Concat_T = typing.TypeVar("System_String_Concat_T")
System_String_Join_T = typing.TypeVar("System_String_Join_T")
System_Byte_CreateChecked_TOther = typing.TypeVar("System_Byte_CreateChecked_TOther")
System_Byte_CreateSaturating_TOther = typing.TypeVar("System_Byte_CreateSaturating_TOther")
System_Byte_CreateTruncating_TOther = typing.TypeVar("System_Byte_CreateTruncating_TOther")
System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromChecked_TOther = typing.TypeVar("System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromChecked_TOther")
System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromSaturating_TOther = typing.TypeVar("System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromSaturating_TOther")
System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromTruncating_TOther = typing.TypeVar("System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromTruncating_TOther")
System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToChecked_TOther = typing.TypeVar("System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToChecked_TOther")
System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToSaturating_TOther = typing.TypeVar("System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToSaturating_TOther")
System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToTruncating_TOther = typing.TypeVar("System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToTruncating_TOther")
System_Span_T = typing.TypeVar("System_Span_T")
System_IObserver_T = typing.TypeVar("System_IObserver_T")
System_Decimal_CreateChecked_TOther = typing.TypeVar("System_Decimal_CreateChecked_TOther")
System_Decimal_CreateSaturating_TOther = typing.TypeVar("System_Decimal_CreateSaturating_TOther")
System_Decimal_CreateTruncating_TOther = typing.TypeVar("System_Decimal_CreateTruncating_TOther")
System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromChecked_TOther = typing.TypeVar("System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromChecked_TOther")
System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromSaturating_TOther = typing.TypeVar("System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromSaturating_TOther")
System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromTruncating_TOther = typing.TypeVar("System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromTruncating_TOther")
System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToChecked_TOther = typing.TypeVar("System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToChecked_TOther")
System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToSaturating_TOther = typing.TypeVar("System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToSaturating_TOther")
System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToTruncating_TOther = typing.TypeVar("System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToTruncating_TOther")
System_Lazy_TMetadata = typing.TypeVar("System_Lazy_TMetadata")
System_Lazy_T = typing.TypeVar("System_Lazy_T")
System_Nullable_T = typing.TypeVar("System_Nullable_T")
System_Nullable_Compare_T = typing.TypeVar("System_Nullable_Compare_T")
System_Nullable_Equals_T = typing.TypeVar("System_Nullable_Equals_T")
System_Nullable_GetValueRefOrDefaultRef_T = typing.TypeVar("System_Nullable_GetValueRefOrDefaultRef_T")
System_Int32_CreateChecked_TOther = typing.TypeVar("System_Int32_CreateChecked_TOther")
System_Int32_CreateSaturating_TOther = typing.TypeVar("System_Int32_CreateSaturating_TOther")
System_Int32_CreateTruncating_TOther = typing.TypeVar("System_Int32_CreateTruncating_TOther")
System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromChecked_TOther = typing.TypeVar("System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromChecked_TOther")
System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromSaturating_TOther = typing.TypeVar("System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromSaturating_TOther")
System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromTruncating_TOther = typing.TypeVar("System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromTruncating_TOther")
System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToChecked_TOther = typing.TypeVar("System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToChecked_TOther")
System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToSaturating_TOther = typing.TypeVar("System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToSaturating_TOther")
System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToTruncating_TOther = typing.TypeVar("System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToTruncating_TOther")
System_ReadOnlySpan_T = typing.TypeVar("System_ReadOnlySpan_T")
System_Memory_T = typing.TypeVar("System_Memory_T")
System_Array_BinarySearch_T = typing.TypeVar("System_Array_BinarySearch_T")
System_Array_Fill_T = typing.TypeVar("System_Array_Fill_T")
System_Array_Find_T = typing.TypeVar("System_Array_Find_T")
System_Array_FindLast_T = typing.TypeVar("System_Array_FindLast_T")
System_Array_IndexOf_T = typing.TypeVar("System_Array_IndexOf_T")
System_Array_LastIndexOf_T = typing.TypeVar("System_Array_LastIndexOf_T")
System_Array_AsReadOnly_T = typing.TypeVar("System_Array_AsReadOnly_T")
System_Array_Resize_T = typing.TypeVar("System_Array_Resize_T")
System_Array_ConvertAll_TOutput = typing.TypeVar("System_Array_ConvertAll_TOutput")
System_Array_ConvertAll_TInput = typing.TypeVar("System_Array_ConvertAll_TInput")
System_Array_Empty_T = typing.TypeVar("System_Array_Empty_T")
System_Array_Exists_T = typing.TypeVar("System_Array_Exists_T")
System_Array_FindAll_T = typing.TypeVar("System_Array_FindAll_T")
System_Array_FindIndex_T = typing.TypeVar("System_Array_FindIndex_T")
System_Array_FindLastIndex_T = typing.TypeVar("System_Array_FindLastIndex_T")
System_Array_ForEach_T = typing.TypeVar("System_Array_ForEach_T")
System_Array_Reverse_T = typing.TypeVar("System_Array_Reverse_T")
System_Array_Sort_T = typing.TypeVar("System_Array_Sort_T")
System_Array_Sort_TKey = typing.TypeVar("System_Array_Sort_TKey")
System_Array_Sort_TValue = typing.TypeVar("System_Array_Sort_TValue")
System_Array_TrueForAll_T = typing.TypeVar("System_Array_TrueForAll_T")
System_UInt32_CreateChecked_TOther = typing.TypeVar("System_UInt32_CreateChecked_TOther")
System_UInt32_CreateSaturating_TOther = typing.TypeVar("System_UInt32_CreateSaturating_TOther")
System_UInt32_CreateTruncating_TOther = typing.TypeVar("System_UInt32_CreateTruncating_TOther")
System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromChecked_TOther = typing.TypeVar("System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromChecked_TOther")
System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromSaturating_TOther = typing.TypeVar("System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromSaturating_TOther")
System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromTruncating_TOther = typing.TypeVar("System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromTruncating_TOther")
System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToChecked_TOther = typing.TypeVar("System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToChecked_TOther")
System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToSaturating_TOther = typing.TypeVar("System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToSaturating_TOther")
System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToTruncating_TOther = typing.TypeVar("System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToTruncating_TOther")
System_IProgress_T = typing.TypeVar("System_IProgress_T")
System_UInt16_CreateChecked_TOther = typing.TypeVar("System_UInt16_CreateChecked_TOther")
System_UInt16_CreateSaturating_TOther = typing.TypeVar("System_UInt16_CreateSaturating_TOther")
System_UInt16_CreateTruncating_TOther = typing.TypeVar("System_UInt16_CreateTruncating_TOther")
System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromChecked_TOther = typing.TypeVar("System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromChecked_TOther")
System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromSaturating_TOther = typing.TypeVar("System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromSaturating_TOther")
System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromTruncating_TOther = typing.TypeVar("System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromTruncating_TOther")
System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToChecked_TOther = typing.TypeVar("System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToChecked_TOther")
System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToSaturating_TOther = typing.TypeVar("System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToSaturating_TOther")
System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToTruncating_TOther = typing.TypeVar("System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToTruncating_TOther")
System_Enum_GetName_TEnum = typing.TypeVar("System_Enum_GetName_TEnum")
System_Enum_GetValues_TEnum = typing.TypeVar("System_Enum_GetValues_TEnum")
System_Enum_IsDefined_TEnum = typing.TypeVar("System_Enum_IsDefined_TEnum")
System_Enum_Parse_TEnum = typing.TypeVar("System_Enum_Parse_TEnum")
System_Enum_TryParse_TEnum = typing.TypeVar("System_Enum_TryParse_TEnum")
System_IEquatable_T = typing.TypeVar("System_IEquatable_T")
System_WeakReference_T = typing.TypeVar("System_WeakReference_T")
System_Progress_T = typing.TypeVar("System_Progress_T")
System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromChecked_TOther = typing.TypeVar("System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromChecked_TOther")
System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromSaturating_TOther = typing.TypeVar("System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromSaturating_TOther")
System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromTruncating_TOther = typing.TypeVar("System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromTruncating_TOther")
System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToChecked_TOther = typing.TypeVar("System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToChecked_TOther")
System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToSaturating_TOther = typing.TypeVar("System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToSaturating_TOther")
System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToTruncating_TOther = typing.TypeVar("System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToTruncating_TOther")
System_HashCode_Combine_T1 = typing.TypeVar("System_HashCode_Combine_T1")
System_HashCode_Combine_T2 = typing.TypeVar("System_HashCode_Combine_T2")
System_HashCode_Combine_T3 = typing.TypeVar("System_HashCode_Combine_T3")
System_HashCode_Combine_T4 = typing.TypeVar("System_HashCode_Combine_T4")
System_HashCode_Combine_T5 = typing.TypeVar("System_HashCode_Combine_T5")
System_HashCode_Combine_T6 = typing.TypeVar("System_HashCode_Combine_T6")
System_HashCode_Combine_T7 = typing.TypeVar("System_HashCode_Combine_T7")
System_HashCode_Combine_T8 = typing.TypeVar("System_HashCode_Combine_T8")
System_HashCode_Add_T = typing.TypeVar("System_HashCode_Add_T")
System_UInt64_CreateChecked_TOther = typing.TypeVar("System_UInt64_CreateChecked_TOther")
System_UInt64_CreateSaturating_TOther = typing.TypeVar("System_UInt64_CreateSaturating_TOther")
System_UInt64_CreateTruncating_TOther = typing.TypeVar("System_UInt64_CreateTruncating_TOther")
System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromChecked_TOther = typing.TypeVar("System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromChecked_TOther")
System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromSaturating_TOther = typing.TypeVar("System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromSaturating_TOther")
System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromTruncating_TOther = typing.TypeVar("System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromTruncating_TOther")
System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToChecked_TOther = typing.TypeVar("System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToChecked_TOther")
System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToSaturating_TOther = typing.TypeVar("System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToSaturating_TOther")
System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToTruncating_TOther = typing.TypeVar("System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToTruncating_TOther")
System_IntPtr_CreateChecked_TOther = typing.TypeVar("System_IntPtr_CreateChecked_TOther")
System_IntPtr_CreateSaturating_TOther = typing.TypeVar("System_IntPtr_CreateSaturating_TOther")
System_IntPtr_CreateTruncating_TOther = typing.TypeVar("System_IntPtr_CreateTruncating_TOther")
System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromChecked_TOther = typing.TypeVar("System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromChecked_TOther")
System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromSaturating_TOther = typing.TypeVar("System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromSaturating_TOther")
System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromTruncating_TOther = typing.TypeVar("System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromTruncating_TOther")
System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToChecked_TOther = typing.TypeVar("System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToChecked_TOther")
System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToSaturating_TOther = typing.TypeVar("System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToSaturating_TOther")
System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToTruncating_TOther = typing.TypeVar("System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToTruncating_TOther")
System_ValueTuple_T1 = typing.TypeVar("System_ValueTuple_T1")
System_ValueTuple_T2 = typing.TypeVar("System_ValueTuple_T2")
System_ValueTuple_T3 = typing.TypeVar("System_ValueTuple_T3")
System_ValueTuple_T4 = typing.TypeVar("System_ValueTuple_T4")
System_ValueTuple_T5 = typing.TypeVar("System_ValueTuple_T5")
System_ValueTuple_T6 = typing.TypeVar("System_ValueTuple_T6")
System_ValueTuple_T7 = typing.TypeVar("System_ValueTuple_T7")
System_ValueTuple_TRest = typing.TypeVar("System_ValueTuple_TRest")
System_ValueTuple_Create_T1 = typing.TypeVar("System_ValueTuple_Create_T1")
System_ValueTuple_Create_T2 = typing.TypeVar("System_ValueTuple_Create_T2")
System_ValueTuple_Create_T3 = typing.TypeVar("System_ValueTuple_Create_T3")
System_ValueTuple_Create_T4 = typing.TypeVar("System_ValueTuple_Create_T4")
System_ValueTuple_Create_T5 = typing.TypeVar("System_ValueTuple_Create_T5")
System_ValueTuple_Create_T6 = typing.TypeVar("System_ValueTuple_Create_T6")
System_ValueTuple_Create_T7 = typing.TypeVar("System_ValueTuple_Create_T7")
System_ValueTuple_Create_T8 = typing.TypeVar("System_ValueTuple_Create_T8")
System_GC_AllocateUninitializedArray_T = typing.TypeVar("System_GC_AllocateUninitializedArray_T")
System_GC_AllocateArray_T = typing.TypeVar("System_GC_AllocateArray_T")
System_Int64_CreateChecked_TOther = typing.TypeVar("System_Int64_CreateChecked_TOther")
System_Int64_CreateSaturating_TOther = typing.TypeVar("System_Int64_CreateSaturating_TOther")
System_Int64_CreateTruncating_TOther = typing.TypeVar("System_Int64_CreateTruncating_TOther")
System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromChecked_TOther = typing.TypeVar("System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromChecked_TOther")
System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromSaturating_TOther = typing.TypeVar("System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromSaturating_TOther")
System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromTruncating_TOther = typing.TypeVar("System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromTruncating_TOther")
System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToChecked_TOther = typing.TypeVar("System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToChecked_TOther")
System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToSaturating_TOther = typing.TypeVar("System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToSaturating_TOther")
System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToTruncating_TOther = typing.TypeVar("System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToTruncating_TOther")
System_Int16_CreateChecked_TOther = typing.TypeVar("System_Int16_CreateChecked_TOther")
System_Int16_CreateSaturating_TOther = typing.TypeVar("System_Int16_CreateSaturating_TOther")
System_Int16_CreateTruncating_TOther = typing.TypeVar("System_Int16_CreateTruncating_TOther")
System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromChecked_TOther = typing.TypeVar("System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromChecked_TOther")
System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromSaturating_TOther = typing.TypeVar("System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromSaturating_TOther")
System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromTruncating_TOther = typing.TypeVar("System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromTruncating_TOther")
System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToChecked_TOther = typing.TypeVar("System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToChecked_TOther")
System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToSaturating_TOther = typing.TypeVar("System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToSaturating_TOther")
System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToTruncating_TOther = typing.TypeVar("System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToTruncating_TOther")
System_UIntPtr_CreateChecked_TOther = typing.TypeVar("System_UIntPtr_CreateChecked_TOther")
System_UIntPtr_CreateSaturating_TOther = typing.TypeVar("System_UIntPtr_CreateSaturating_TOther")
System_UIntPtr_CreateTruncating_TOther = typing.TypeVar("System_UIntPtr_CreateTruncating_TOther")
System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromChecked_TOther = typing.TypeVar("System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromChecked_TOther")
System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromSaturating_TOther = typing.TypeVar("System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromSaturating_TOther")
System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromTruncating_TOther = typing.TypeVar("System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromTruncating_TOther")
System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToChecked_TOther = typing.TypeVar("System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToChecked_TOther")
System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToSaturating_TOther = typing.TypeVar("System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToSaturating_TOther")
System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToTruncating_TOther = typing.TypeVar("System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToTruncating_TOther")
System_IComparable_T = typing.TypeVar("System_IComparable_T")
System_ArraySegment_T = typing.TypeVar("System_ArraySegment_T")
System_TupleExtensions_Deconstruct_T1 = typing.TypeVar("System_TupleExtensions_Deconstruct_T1")
System_TupleExtensions_Deconstruct_T2 = typing.TypeVar("System_TupleExtensions_Deconstruct_T2")
System_TupleExtensions_Deconstruct_T3 = typing.TypeVar("System_TupleExtensions_Deconstruct_T3")
System_TupleExtensions_Deconstruct_T4 = typing.TypeVar("System_TupleExtensions_Deconstruct_T4")
System_TupleExtensions_Deconstruct_T5 = typing.TypeVar("System_TupleExtensions_Deconstruct_T5")
System_TupleExtensions_Deconstruct_T6 = typing.TypeVar("System_TupleExtensions_Deconstruct_T6")
System_TupleExtensions_Deconstruct_T7 = typing.TypeVar("System_TupleExtensions_Deconstruct_T7")
System_TupleExtensions_Deconstruct_T8 = typing.TypeVar("System_TupleExtensions_Deconstruct_T8")
System_TupleExtensions_Deconstruct_T9 = typing.TypeVar("System_TupleExtensions_Deconstruct_T9")
System_TupleExtensions_Deconstruct_T10 = typing.TypeVar("System_TupleExtensions_Deconstruct_T10")
System_TupleExtensions_Deconstruct_T11 = typing.TypeVar("System_TupleExtensions_Deconstruct_T11")
System_TupleExtensions_Deconstruct_T12 = typing.TypeVar("System_TupleExtensions_Deconstruct_T12")
System_TupleExtensions_Deconstruct_T13 = typing.TypeVar("System_TupleExtensions_Deconstruct_T13")
System_TupleExtensions_Deconstruct_T14 = typing.TypeVar("System_TupleExtensions_Deconstruct_T14")
System_TupleExtensions_Deconstruct_T15 = typing.TypeVar("System_TupleExtensions_Deconstruct_T15")
System_TupleExtensions_Deconstruct_T16 = typing.TypeVar("System_TupleExtensions_Deconstruct_T16")
System_TupleExtensions_Deconstruct_T17 = typing.TypeVar("System_TupleExtensions_Deconstruct_T17")
System_TupleExtensions_Deconstruct_T18 = typing.TypeVar("System_TupleExtensions_Deconstruct_T18")
System_TupleExtensions_Deconstruct_T19 = typing.TypeVar("System_TupleExtensions_Deconstruct_T19")
System_TupleExtensions_Deconstruct_T20 = typing.TypeVar("System_TupleExtensions_Deconstruct_T20")
System_TupleExtensions_Deconstruct_T21 = typing.TypeVar("System_TupleExtensions_Deconstruct_T21")
System_TupleExtensions_ToValueTuple_T1 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T1")
System_TupleExtensions_ToValueTuple_T2 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T2")
System_TupleExtensions_ToValueTuple_T3 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T3")
System_TupleExtensions_ToValueTuple_T4 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T4")
System_TupleExtensions_ToValueTuple_T5 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T5")
System_TupleExtensions_ToValueTuple_T6 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T6")
System_TupleExtensions_ToValueTuple_T7 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T7")
System_TupleExtensions_ToTuple_T1 = typing.TypeVar("System_TupleExtensions_ToTuple_T1")
System_TupleExtensions_ToTuple_T2 = typing.TypeVar("System_TupleExtensions_ToTuple_T2")
System_TupleExtensions_ToTuple_T3 = typing.TypeVar("System_TupleExtensions_ToTuple_T3")
System_TupleExtensions_ToTuple_T4 = typing.TypeVar("System_TupleExtensions_ToTuple_T4")
System_TupleExtensions_ToTuple_T5 = typing.TypeVar("System_TupleExtensions_ToTuple_T5")
System_TupleExtensions_ToTuple_T6 = typing.TypeVar("System_TupleExtensions_ToTuple_T6")
System_TupleExtensions_ToTuple_T7 = typing.TypeVar("System_TupleExtensions_ToTuple_T7")
System_TupleExtensions_ToValueTuple_T8 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T8")
System_TupleExtensions_ToValueTuple_T9 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T9")
System_TupleExtensions_ToValueTuple_T10 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T10")
System_TupleExtensions_ToValueTuple_T11 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T11")
System_TupleExtensions_ToValueTuple_T12 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T12")
System_TupleExtensions_ToValueTuple_T13 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T13")
System_TupleExtensions_ToValueTuple_T14 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T14")
System_TupleExtensions_ToTuple_T8 = typing.TypeVar("System_TupleExtensions_ToTuple_T8")
System_TupleExtensions_ToTuple_T9 = typing.TypeVar("System_TupleExtensions_ToTuple_T9")
System_TupleExtensions_ToTuple_T10 = typing.TypeVar("System_TupleExtensions_ToTuple_T10")
System_TupleExtensions_ToTuple_T11 = typing.TypeVar("System_TupleExtensions_ToTuple_T11")
System_TupleExtensions_ToTuple_T12 = typing.TypeVar("System_TupleExtensions_ToTuple_T12")
System_TupleExtensions_ToTuple_T13 = typing.TypeVar("System_TupleExtensions_ToTuple_T13")
System_TupleExtensions_ToTuple_T14 = typing.TypeVar("System_TupleExtensions_ToTuple_T14")
System_TupleExtensions_ToValueTuple_T15 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T15")
System_TupleExtensions_ToValueTuple_T16 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T16")
System_TupleExtensions_ToValueTuple_T17 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T17")
System_TupleExtensions_ToValueTuple_T18 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T18")
System_TupleExtensions_ToValueTuple_T19 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T19")
System_TupleExtensions_ToValueTuple_T20 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T20")
System_TupleExtensions_ToValueTuple_T21 = typing.TypeVar("System_TupleExtensions_ToValueTuple_T21")
System_TupleExtensions_ToTuple_T15 = typing.TypeVar("System_TupleExtensions_ToTuple_T15")
System_TupleExtensions_ToTuple_T16 = typing.TypeVar("System_TupleExtensions_ToTuple_T16")
System_TupleExtensions_ToTuple_T17 = typing.TypeVar("System_TupleExtensions_ToTuple_T17")
System_TupleExtensions_ToTuple_T18 = typing.TypeVar("System_TupleExtensions_ToTuple_T18")
System_TupleExtensions_ToTuple_T19 = typing.TypeVar("System_TupleExtensions_ToTuple_T19")
System_TupleExtensions_ToTuple_T20 = typing.TypeVar("System_TupleExtensions_ToTuple_T20")
System_TupleExtensions_ToTuple_T21 = typing.TypeVar("System_TupleExtensions_ToTuple_T21")
System_Tuple_T1 = typing.TypeVar("System_Tuple_T1")
System_Tuple_T2 = typing.TypeVar("System_Tuple_T2")
System_Tuple_T3 = typing.TypeVar("System_Tuple_T3")
System_Tuple_T4 = typing.TypeVar("System_Tuple_T4")
System_Tuple_T5 = typing.TypeVar("System_Tuple_T5")
System_Tuple_T6 = typing.TypeVar("System_Tuple_T6")
System_Tuple_T7 = typing.TypeVar("System_Tuple_T7")
System_Tuple_TRest = typing.TypeVar("System_Tuple_TRest")
System_Tuple_Create_T1 = typing.TypeVar("System_Tuple_Create_T1")
System_Tuple_Create_T2 = typing.TypeVar("System_Tuple_Create_T2")
System_Tuple_Create_T3 = typing.TypeVar("System_Tuple_Create_T3")
System_Tuple_Create_T4 = typing.TypeVar("System_Tuple_Create_T4")
System_Tuple_Create_T5 = typing.TypeVar("System_Tuple_Create_T5")
System_Tuple_Create_T6 = typing.TypeVar("System_Tuple_Create_T6")
System_Tuple_Create_T7 = typing.TypeVar("System_Tuple_Create_T7")
System_Tuple_Create_T8 = typing.TypeVar("System_Tuple_Create_T8")
System_IObservable_T = typing.TypeVar("System_IObservable_T")
System_IParsable_TSelf = typing.TypeVar("System_IParsable_TSelf")
System__EventContainer_Callable = typing.TypeVar("System__EventContainer_Callable")
System__EventContainer_ReturnType = typing.TypeVar("System__EventContainer_ReturnType")


class Object:
    """This class has no documentation."""

    def __init__(self) -> None:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Determines whether the specified object is equal to the current object.
        
        :param obj: The object to compare with the current object.
        :returns: true if the specified object is equal to the current object; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def Equals(objA: typing.Any, objB: typing.Any) -> bool:
        ...

    def GetHashCode(self) -> int:
        """
        Serves as the default hash function.
        
        :returns: A hash code for the current object.
        """
        ...

    def GetType(self) -> typing.Type:
        ...

    def MemberwiseClone(self) -> System.Object:
        """This method is protected."""
        ...

    @staticmethod
    def ReferenceEquals(objA: typing.Any, objB: typing.Any) -> bool:
        ...

    def ToString(self) -> str:
        ...


class Exception(System.Object, System.Runtime.Serialization.ISerializable):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @property
    def Data(self) -> System.Collections.IDictionary:
        ...

    @property
    def InnerException(self) -> System.Exception:
        ...

    @property
    def HelpLink(self) -> str:
        ...

    @HelpLink.setter
    def HelpLink(self, value: str):
        ...

    @property
    def Source(self) -> str:
        ...

    @Source.setter
    def Source(self, value: str):
        ...

    @property
    def SerializeObjectState(self) -> _EventContainer[typing.Callable[[System.Object, System.Runtime.Serialization.SafeSerializationEventArgs], None], None]:
        """
        This property is protected.
        
        Obsoletions.BinaryFormatterMessage
        """
        warnings.warn("Obsoletions.BinaryFormatterMessage", DeprecationWarning)

    @SerializeObjectState.setter
    def SerializeObjectState(self, value: _EventContainer[typing.Callable[[System.Object, System.Runtime.Serialization.SafeSerializationEventArgs], None], None]):
        """
        This property is protected.
        
        Obsoletions.BinaryFormatterMessage
        """
        warnings.warn("Obsoletions.BinaryFormatterMessage", DeprecationWarning)

    @property
    def HResult(self) -> int:
        ...

    @HResult.setter
    def HResult(self, value: int):
        ...

    @property
    def StackTrace(self) -> str:
        ...

    @property
    def _message(self) -> str:
        ...

    @_message.setter
    def _message(self, value: str):
        ...

    @property
    def foreignExceptionsFrames(self) -> typing.List[System.Diagnostics.MonoStackFrame]:
        ...

    @foreignExceptionsFrames.setter
    def foreignExceptionsFrames(self, value: typing.List[System.Diagnostics.MonoStackFrame]):
        ...

    @property
    def TargetSite(self) -> System.Reflection.MethodBase:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetBaseException(self) -> System.Exception:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetType(self) -> typing.Type:
        ...

    def RestoreRemoteStackTrace(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def ToString(self) -> str:
        ...


class SystemException(System.Exception):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class ArgumentException(System.SystemException):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @property
    def ParamName(self) -> str:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, message: str, paramName: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, message: str, paramName: str) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    @staticmethod
    def ThrowIfNullOrEmpty(argument: str, paramName: str = None) -> None:
        """
        Throws an exception if  is null or empty.
        
        :param argument: The string argument to validate as non-null and non-empty.
        :param paramName: The name of the parameter with which  corresponds.
        """
        ...


class DuplicateWaitObjectException(System.ArgumentException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, parameterName: str) -> None:
        ...

    @overload
    def __init__(self, parameterName: str, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class IComparable(typing.Generic[System_IComparable_T], metaclass=abc.ABCMeta):
    """This class has no documentation."""

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System_IComparable_T) -> int:
        ...


class IFormatProvider(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def GetFormat(self, formatType: typing.Type) -> System.Object:
        ...


class IFormattable(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def ToString(self, format: str, formatProvider: System.IFormatProvider) -> str:
        ...


class Span(typing.Generic[System_Span_T]):
    """
    Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
    or native memory, or to memory allocated on the stack. It is type- and memory-safe.
    """

    class Enumerator:
        """Enumerates the elements of a Span{T}."""

        @property
        def Current(self) -> typing.Any:
            """Gets the element at the current position of the enumerator."""
            ...

        def MoveNext(self) -> bool:
            """Advances the enumerator to the next element of the span."""
            ...

    @property
    def Length(self) -> int:
        """The number of items in the span."""
        ...

    @property
    def IsEmpty(self) -> bool:
        """Gets a value indicating whether this Span{T} is empty."""
        ...

    Empty: System.Span[System_Span_T]
    """Returns an empty Span{T}"""

    def __getitem__(self, index: int) -> typing.Any:
        ...

    @overload
    def __init__(self, array: typing.List[System_Span_T]) -> None:
        """
        Creates a new span over the entirety of the target array.
        
        :param array: The target array.
        """
        ...

    @overload
    def __init__(self, array: typing.List[System_Span_T], start: int, length: int) -> None:
        """
        Creates a new span over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the span.
        :param length: The number of items in the span.
        """
        ...

    @overload
    def __init__(self, pointer: typing.Any, length: int) -> None:
        """
        Creates a new span over the target unmanaged buffer.  Clearly this
        is quite dangerous, because we are creating arbitrarily typed T's
        out of a void*-typed block of memory.  And the length is not checked.
        But if this creation is correct, then all subsequent uses are correct.
        
        :param pointer: An unmanaged pointer to memory.
        :param length: The number of T elements the memory contains.
        """
        ...

    @overload
    def __init__(self, reference: System_Span_T) -> None:
        """
        Creates a new Span{T} of length 1 around the specified reference.
        
        :param reference: A reference to data.
        """
        ...

    def Clear(self) -> None:
        """Clears the contents of this span."""
        ...

    def CopyTo(self, destination: System.Span[System_Span_T]) -> None:
        """
        Copies the contents of this span into destination span. If the source
        and destinations overlap, this method behaves as if the original values in
        a temporary location before the destination is overwritten.
        
        :param destination: The span to copy items into.
        """
        ...

    def Equals(self, obj: typing.Any) -> bool:
        """
        This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
        
        Equals() on Span will always throw an exception. Use the equality operator instead.
        """
        warnings.warn("Equals() on Span will always throw an exception. Use the equality operator instead.", DeprecationWarning)

    def Fill(self, value: System_Span_T) -> None:
        """Fills the contents of this span with the given value."""
        ...

    def GetEnumerator(self) -> System.Span.Enumerator:
        """Gets an enumerator for this span."""
        ...

    def GetHashCode(self) -> int:
        """
        This method is not supported as spans cannot be boxed.
        
        GetHashCode() on Span will always throw an exception.
        """
        warnings.warn("GetHashCode() on Span will always throw an exception.", DeprecationWarning)

    def GetPinnableReference(self) -> typing.Any:
        """
        Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
        It can be used for pinning and is required to support the use of span within a fixed statement.
        """
        ...

    @overload
    def Slice(self, start: int) -> System.Span[System_Span_T]:
        """
        Forms a slice out of the given span, beginning at 'start'.
        
        :param start: The index at which to begin this slice.
        """
        ...

    @overload
    def Slice(self, start: int, length: int) -> System.Span[System_Span_T]:
        """
        Forms a slice out of the given span, beginning at 'start', of given length
        
        :param start: The index at which to begin this slice.
        :param length: The desired length for the slice (exclusive).
        """
        ...

    def ToArray(self) -> typing.List[System_Span_T]:
        """
        Copies the contents of this span into a new array.  This heap
        allocates, so should generally be avoided, however it is sometimes
        necessary to bridge the gap with APIs written in terms of arrays.
        """
        ...

    def ToString(self) -> str:
        """
        For Span{Char}, returns a new instance of string that represents the characters pointed to by the span.
        Otherwise, returns a string with the name of the type and the number of elements.
        """
        ...

    def TryCopyTo(self, destination: System.Span[System_Span_T]) -> bool:
        """
        Copies the contents of this span into destination span. If the source
        and destinations overlap, this method behaves as if the original values in
        a temporary location before the destination is overwritten.
        
        :param destination: The span to copy items into.
        :returns: If the destination span is shorter than the source span, this method return false and no data is written to the destination.
        """
        ...


class ReadOnlySpan(typing.Generic[System_ReadOnlySpan_T]):
    """
    ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
    or native memory, or to memory allocated on the stack. It is type- and memory-safe.
    """

    class Enumerator:
        """Enumerates the elements of a ReadOnlySpan{T}."""

        @property
        def Current(self) -> typing.Any:
            """Gets the element at the current position of the enumerator."""
            ...

        def MoveNext(self) -> bool:
            """Advances the enumerator to the next element of the span."""
            ...

    @property
    def Length(self) -> int:
        """The number of items in the read-only span."""
        ...

    @property
    def IsEmpty(self) -> bool:
        """Gets a value indicating whether this ReadOnlySpan{T} is empty."""
        ...

    Empty: System.ReadOnlySpan[System_ReadOnlySpan_T]
    """Returns a 0-length read-only span whose base is the null pointer."""

    def __getitem__(self, index: int) -> typing.Any:
        ...

    @overload
    def __init__(self, array: typing.List[System_ReadOnlySpan_T]) -> None:
        """
        Creates a new read-only span over the entirety of the target array.
        
        :param array: The target array.
        """
        ...

    @overload
    def __init__(self, array: typing.List[System_ReadOnlySpan_T], start: int, length: int) -> None:
        """
        Creates a new read-only span over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the read-only span.
        :param length: The number of items in the read-only span.
        """
        ...

    @overload
    def __init__(self, pointer: typing.Any, length: int) -> None:
        """
        Creates a new read-only span over the target unmanaged buffer.  Clearly this
        is quite dangerous, because we are creating arbitrarily typed T's
        out of a void*-typed block of memory.  And the length is not checked.
        But if this creation is correct, then all subsequent uses are correct.
        
        :param pointer: An unmanaged pointer to memory.
        :param length: The number of T elements the memory contains.
        """
        ...

    @overload
    def __init__(self, reference: System_ReadOnlySpan_T) -> None:
        """
        Creates a new ReadOnlySpan{T} of length 1 around the specified reference.
        
        :param reference: A reference to data.
        """
        ...

    def CopyTo(self, destination: System.Span[System_ReadOnlySpan_T]) -> None:
        """
        Copies the contents of this read-only span into destination span. If the source
        and destinations overlap, this method behaves as if the original values in
        a temporary location before the destination is overwritten.
        
        :param destination: The span to copy items into.
        """
        ...

    def Equals(self, obj: typing.Any) -> bool:
        """
        This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
        
        Equals() on ReadOnlySpan will always throw an exception. Use the equality operator instead.
        """
        warnings.warn("Equals() on ReadOnlySpan will always throw an exception. Use the equality operator instead.", DeprecationWarning)

    def GetEnumerator(self) -> System.ReadOnlySpan.Enumerator:
        """Gets an enumerator for this span."""
        ...

    def GetHashCode(self) -> int:
        """
        This method is not supported as spans cannot be boxed.
        
        GetHashCode() on ReadOnlySpan will always throw an exception.
        """
        warnings.warn("GetHashCode() on ReadOnlySpan will always throw an exception.", DeprecationWarning)

    def GetPinnableReference(self) -> typing.Any:
        """
        Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
        It can be used for pinning and is required to support the use of span within a fixed statement.
        """
        ...

    @overload
    def Slice(self, start: int) -> System.ReadOnlySpan[System_ReadOnlySpan_T]:
        """
        Forms a slice out of the given read-only span, beginning at 'start'.
        
        :param start: The index at which to begin this slice.
        """
        ...

    @overload
    def Slice(self, start: int, length: int) -> System.ReadOnlySpan[System_ReadOnlySpan_T]:
        """
        Forms a slice out of the given read-only span, beginning at 'start', of given length
        
        :param start: The index at which to begin this slice.
        :param length: The desired length for the slice (exclusive).
        """
        ...

    def ToArray(self) -> typing.List[System_ReadOnlySpan_T]:
        """
        Copies the contents of this read-only span into a new array.  This heap
        allocates, so should generally be avoided, however it is sometimes
        necessary to bridge the gap with APIs written in terms of arrays.
        """
        ...

    def ToString(self) -> str:
        """
        For ReadOnlySpan{Char}, returns a new instance of string that represents the characters pointed to by the span.
        Otherwise, returns a string with the name of the type and the number of elements.
        """
        ...

    def TryCopyTo(self, destination: System.Span[System_ReadOnlySpan_T]) -> bool:
        """
        Copies the contents of this read-only span into destination span. If the source
        and destinations overlap, this method behaves as if the original values in
        a temporary location before the destination is overwritten.
        
        :param destination: The span to copy items into.
        :returns: If the destination span is shorter than the source span, this method return false and no data is written to the destination.
        """
        ...


class ISpanFormattable(System.IFormattable, metaclass=abc.ABCMeta):
    """Provides functionality to format the string representation of an object into a span."""

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> typing.Union[bool, int]:
        """
        Tries to format the value of the current instance into the provided span of characters.
        
        :param destination: When this method returns, this instance's value formatted as a span of characters.
        :param charsWritten: When this method returns, the number of characters that were written in .
        :param format: A span containing the characters that represent a standard or custom format string that defines the acceptable format for .
        :param provider: An optional object that supplies culture-specific formatting information for .
        :returns: true if the formatting was successful; otherwise, false.
        """
        ...


class IConvertible(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, conversionType: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...


class IEquatable(typing.Generic[System_IEquatable_T], metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def Equals(self, other: System_IEquatable_T) -> bool:
        """
        Indicates whether the current object is equal to another object of the same type.
        
        :param other: An object to compare with this object.
        :returns: true if the current object is equal to the  parameter; otherwise, false.
        """
        ...


class IParsable(typing.Generic[System_IParsable_TSelf], metaclass=abc.ABCMeta):
    """Defines a mechanism for parsing a string to a value."""

    @staticmethod
    def Parse(s: str, provider: System.IFormatProvider) -> System_IParsable_TSelf:
        """
        Parses a string into a value.
        
        :param s: The string to parse.
        :param provider: An object that provides culture-specific formatting information about .
        :returns: The result of parsing .
        """
        ...

    @staticmethod
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System_IParsable_TSelf]) -> typing.Union[bool, System_IParsable_TSelf]:
        """
        Tries to parse a string into a value.
        
        :param s: The string to parse.
        :param provider: An object that provides culture-specific formatting information about .
        :param result: On return, contains the result of successfully parsing  or an undefined value on failure.
        :returns: true if  was successfully parsed; otherwise, false.
        """
        ...


class ISpanParsable(typing.Generic[System_ISpanParsable_TSelf], System.IParsable[System_ISpanParsable_TSelf], metaclass=abc.ABCMeta):
    """Defines a mechanism for parsing a span of characters to a value."""

    @staticmethod
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System_ISpanParsable_TSelf:
        """
        Parses a span of characters into a value.
        
        :param s: The span of characters to parse.
        :param provider: An object that provides culture-specific formatting information about .
        :returns: The result of parsing .
        """
        ...

    @staticmethod
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System_ISpanParsable_TSelf]) -> typing.Union[bool, System_ISpanParsable_TSelf]:
        """
        Tries to parse a span of characters into a value.
        
        :param s: The span of characters to parse.
        :param provider: An object that provides culture-specific formatting information about .
        :param result: On return, contains the result of successfully parsing  or an undefined value on failure.
        :returns: true if  was successfully parsed; otherwise, false.
        """
        ...


class ICloneable(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def Clone(self) -> System.Object:
        ...


class ValueTuple(typing.Generic[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6, System_ValueTuple_T7, System_ValueTuple_TRest], System.IEquatable[System_ValueTuple], System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable[System_ValueTuple], System.IValueTupleInternal):
    """Represents an 8-tuple, or octuple, as a value type."""

    @property
    def Length(self) -> int:
        """The number of positions in this data structure."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1} instance's first component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2} instance's second component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2, T3} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2, T3} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2, T3} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2, T3} instance's second component."""
        ...

    @property
    def Item3(self) -> System_ValueTuple_T3:
        """The current ValueTuple{T1, T2, T3} instance's third component."""
        ...

    @Item3.setter
    def Item3(self, value: System_ValueTuple_T3):
        """The current ValueTuple{T1, T2, T3} instance's third component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2, T3, T4} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2, T3, T4} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2, T3, T4} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2, T3, T4} instance's second component."""
        ...

    @property
    def Item3(self) -> System_ValueTuple_T3:
        """The current ValueTuple{T1, T2, T3, T4} instance's third component."""
        ...

    @Item3.setter
    def Item3(self, value: System_ValueTuple_T3):
        """The current ValueTuple{T1, T2, T3, T4} instance's third component."""
        ...

    @property
    def Item4(self) -> System_ValueTuple_T4:
        """The current ValueTuple{T1, T2, T3, T4} instance's fourth component."""
        ...

    @Item4.setter
    def Item4(self, value: System_ValueTuple_T4):
        """The current ValueTuple{T1, T2, T3, T4} instance's fourth component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's second component."""
        ...

    @property
    def Item3(self) -> System_ValueTuple_T3:
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's third component."""
        ...

    @Item3.setter
    def Item3(self, value: System_ValueTuple_T3):
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's third component."""
        ...

    @property
    def Item4(self) -> System_ValueTuple_T4:
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's fourth component."""
        ...

    @Item4.setter
    def Item4(self, value: System_ValueTuple_T4):
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's fourth component."""
        ...

    @property
    def Item5(self) -> System_ValueTuple_T5:
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's fifth component."""
        ...

    @Item5.setter
    def Item5(self, value: System_ValueTuple_T5):
        """The current ValueTuple{T1, T2, T3, T4, T5} instance's fifth component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's second component."""
        ...

    @property
    def Item3(self) -> System_ValueTuple_T3:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's third component."""
        ...

    @Item3.setter
    def Item3(self, value: System_ValueTuple_T3):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's third component."""
        ...

    @property
    def Item4(self) -> System_ValueTuple_T4:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's fourth component."""
        ...

    @Item4.setter
    def Item4(self, value: System_ValueTuple_T4):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's fourth component."""
        ...

    @property
    def Item5(self) -> System_ValueTuple_T5:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's fifth component."""
        ...

    @Item5.setter
    def Item5(self, value: System_ValueTuple_T5):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's fifth component."""
        ...

    @property
    def Item6(self) -> System_ValueTuple_T6:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's sixth component."""
        ...

    @Item6.setter
    def Item6(self, value: System_ValueTuple_T6):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6} instance's sixth component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's second component."""
        ...

    @property
    def Item3(self) -> System_ValueTuple_T3:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's third component."""
        ...

    @Item3.setter
    def Item3(self, value: System_ValueTuple_T3):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's third component."""
        ...

    @property
    def Item4(self) -> System_ValueTuple_T4:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's fourth component."""
        ...

    @Item4.setter
    def Item4(self, value: System_ValueTuple_T4):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's fourth component."""
        ...

    @property
    def Item5(self) -> System_ValueTuple_T5:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's fifth component."""
        ...

    @Item5.setter
    def Item5(self, value: System_ValueTuple_T5):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's fifth component."""
        ...

    @property
    def Item6(self) -> System_ValueTuple_T6:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's sixth component."""
        ...

    @Item6.setter
    def Item6(self, value: System_ValueTuple_T6):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's sixth component."""
        ...

    @property
    def Item7(self) -> System_ValueTuple_T7:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's seventh component."""
        ...

    @Item7.setter
    def Item7(self, value: System_ValueTuple_T7):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance's seventh component."""
        ...

    @property
    def Item1(self) -> System_ValueTuple_T1:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's first component."""
        ...

    @Item1.setter
    def Item1(self, value: System_ValueTuple_T1):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's first component."""
        ...

    @property
    def Item2(self) -> System_ValueTuple_T2:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's second component."""
        ...

    @Item2.setter
    def Item2(self, value: System_ValueTuple_T2):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's second component."""
        ...

    @property
    def Item3(self) -> System_ValueTuple_T3:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's third component."""
        ...

    @Item3.setter
    def Item3(self, value: System_ValueTuple_T3):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's third component."""
        ...

    @property
    def Item4(self) -> System_ValueTuple_T4:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's fourth component."""
        ...

    @Item4.setter
    def Item4(self, value: System_ValueTuple_T4):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's fourth component."""
        ...

    @property
    def Item5(self) -> System_ValueTuple_T5:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's fifth component."""
        ...

    @Item5.setter
    def Item5(self, value: System_ValueTuple_T5):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's fifth component."""
        ...

    @property
    def Item6(self) -> System_ValueTuple_T6:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's sixth component."""
        ...

    @Item6.setter
    def Item6(self, value: System_ValueTuple_T6):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's sixth component."""
        ...

    @property
    def Item7(self) -> System_ValueTuple_T7:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's seventh component."""
        ...

    @Item7.setter
    def Item7(self, value: System_ValueTuple_T7):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's seventh component."""
        ...

    @property
    def Rest(self) -> System_ValueTuple_TRest:
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's eighth component."""
        ...

    @Rest.setter
    def Rest(self, value: System_ValueTuple_TRest):
        """The current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance's eighth component."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1) -> None:
        """
        Initializes a new instance of the ValueTuple{T1} value type.
        
        :param item1: The value of the tuple's first component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2, item3: System_ValueTuple_T3) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2, T3} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        :param item3: The value of the tuple's third component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2, item3: System_ValueTuple_T3, item4: System_ValueTuple_T4) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2, T3, T4} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        :param item3: The value of the tuple's third component.
        :param item4: The value of the tuple's fourth component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2, item3: System_ValueTuple_T3, item4: System_ValueTuple_T4, item5: System_ValueTuple_T5) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2, T3, T4, T5} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        :param item3: The value of the tuple's third component.
        :param item4: The value of the tuple's fourth component.
        :param item5: The value of the tuple's fifth component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2, item3: System_ValueTuple_T3, item4: System_ValueTuple_T4, item5: System_ValueTuple_T5, item6: System_ValueTuple_T6) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2, T3, T4, T5, T6} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        :param item3: The value of the tuple's third component.
        :param item4: The value of the tuple's fourth component.
        :param item5: The value of the tuple's fifth component.
        :param item6: The value of the tuple's sixth component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2, item3: System_ValueTuple_T3, item4: System_ValueTuple_T4, item5: System_ValueTuple_T5, item6: System_ValueTuple_T6, item7: System_ValueTuple_T7) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2, T3, T4, T5, T6, T7} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        :param item3: The value of the tuple's third component.
        :param item4: The value of the tuple's fourth component.
        :param item5: The value of the tuple's fifth component.
        :param item6: The value of the tuple's sixth component.
        :param item7: The value of the tuple's seventh component.
        """
        ...

    @overload
    def __init__(self, item1: System_ValueTuple_T1, item2: System_ValueTuple_T2, item3: System_ValueTuple_T3, item4: System_ValueTuple_T4, item5: System_ValueTuple_T5, item6: System_ValueTuple_T6, item7: System_ValueTuple_T7, rest: System_ValueTuple_TRest) -> None:
        """
        Initializes a new instance of the ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} value type.
        
        :param item1: The value of the tuple's first component.
        :param item2: The value of the tuple's second component.
        :param item3: The value of the tuple's third component.
        :param item4: The value of the tuple's fourth component.
        :param item5: The value of the tuple's fifth component.
        :param item6: The value of the tuple's sixth component.
        :param item7: The value of the tuple's seventh component.
        :param rest: The value of the tuple's eight component.
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6, System_ValueTuple_T7]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6, System_ValueTuple_T7, System_ValueTuple_TRest]) -> int:
        """
        Compares this instance to a specified instance and returns an indication of their relative values.
        
        :param other: An instance to compare.
        :returns: A signed number indicating the relative values of this instance and . Returns less than zero if this instance is less than , zero if this instance is equal to , and greater than zero if this instance is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @staticmethod
    @overload
    def Create() -> System.ValueTuple:
        """
        Creates a new struct 0-tuple.
        
        :returns: A 0-tuple.
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1) -> System.ValueTuple[System_ValueTuple_Create_T1]:
        """
        Creates a new struct 1-tuple, or singleton.
        
        :param item1: The value of the first component of the tuple.
        :returns: A 1-tuple (singleton) whose value is (item1).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2]:
        """
        Creates a new struct 2-tuple, or pair.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :returns: A 2-tuple (pair) whose value is (item1, item2).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2, item3: System_ValueTuple_Create_T3) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2, System_ValueTuple_Create_T3]:
        """
        Creates a new struct 3-tuple, or triple.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :param item3: The value of the third component of the tuple.
        :returns: A 3-tuple (triple) whose value is (item1, item2, item3).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2, item3: System_ValueTuple_Create_T3, item4: System_ValueTuple_Create_T4) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2, System_ValueTuple_Create_T3, System_ValueTuple_Create_T4]:
        """
        Creates a new struct 4-tuple, or quadruple.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :param item3: The value of the third component of the tuple.
        :param item4: The value of the fourth component of the tuple.
        :returns: A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2, item3: System_ValueTuple_Create_T3, item4: System_ValueTuple_Create_T4, item5: System_ValueTuple_Create_T5) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2, System_ValueTuple_Create_T3, System_ValueTuple_Create_T4, System_ValueTuple_Create_T5]:
        """
        Creates a new struct 5-tuple, or quintuple.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :param item3: The value of the third component of the tuple.
        :param item4: The value of the fourth component of the tuple.
        :param item5: The value of the fifth component of the tuple.
        :returns: A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2, item3: System_ValueTuple_Create_T3, item4: System_ValueTuple_Create_T4, item5: System_ValueTuple_Create_T5, item6: System_ValueTuple_Create_T6) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2, System_ValueTuple_Create_T3, System_ValueTuple_Create_T4, System_ValueTuple_Create_T5, System_ValueTuple_Create_T6]:
        """
        Creates a new struct 6-tuple, or sextuple.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :param item3: The value of the third component of the tuple.
        :param item4: The value of the fourth component of the tuple.
        :param item5: The value of the fifth component of the tuple.
        :param item6: The value of the sixth component of the tuple.
        :returns: A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2, item3: System_ValueTuple_Create_T3, item4: System_ValueTuple_Create_T4, item5: System_ValueTuple_Create_T5, item6: System_ValueTuple_Create_T6, item7: System_ValueTuple_Create_T7) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2, System_ValueTuple_Create_T3, System_ValueTuple_Create_T4, System_ValueTuple_Create_T5, System_ValueTuple_Create_T6, System_ValueTuple_Create_T7]:
        """
        Creates a new struct 7-tuple, or septuple.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :param item3: The value of the third component of the tuple.
        :param item4: The value of the fourth component of the tuple.
        :param item5: The value of the fifth component of the tuple.
        :param item6: The value of the sixth component of the tuple.
        :param item7: The value of the seventh component of the tuple.
        :returns: A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).
        """
        ...

    @staticmethod
    @overload
    def Create(item1: System_ValueTuple_Create_T1, item2: System_ValueTuple_Create_T2, item3: System_ValueTuple_Create_T3, item4: System_ValueTuple_Create_T4, item5: System_ValueTuple_Create_T5, item6: System_ValueTuple_Create_T6, item7: System_ValueTuple_Create_T7, item8: System_ValueTuple_Create_T8) -> System.ValueTuple[System_ValueTuple_Create_T1, System_ValueTuple_Create_T2, System_ValueTuple_Create_T3, System_ValueTuple_Create_T4, System_ValueTuple_Create_T5, System_ValueTuple_Create_T6, System_ValueTuple_Create_T7, System.ValueTuple[System_ValueTuple_Create_T8]]:
        """
        Creates a new struct 8-tuple, or octuple.
        
        :param item1: The value of the first component of the tuple.
        :param item2: The value of the second component of the tuple.
        :param item3: The value of the third component of the tuple.
        :param item4: The value of the fourth component of the tuple.
        :param item5: The value of the fifth component of the tuple.
        :param item6: The value of the sixth component of the tuple.
        :param item7: The value of the seventh component of the tuple.
        :param item8: The value of the eighth component of the tuple.
        :returns: An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).
        """
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if  is a ValueTuple.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple) -> bool:
        """
        Returns a value indicating whether this instance is equal to a specified value.
        
        :param other: An instance to compare to this instance.
        :returns: true if  has the same value as this instance; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1}
        instance is equal to a specified ValueTuple{T1}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2} instance is equal to a specified ValueTuple{T1, T2}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2} instance is equal to a specified object based on a specified comparison method.
        
        :param other: The object to compare with this instance.
        :param comparer: An object that defines the method to use to evaluate whether the two objects are equal.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3}
        instance is equal to a specified ValueTuple{T1, T2, T3}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4}
        instance is equal to a specified ValueTuple{T1, T2, T3, T4}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5}
        instance is equal to a specified ValueTuple{T1, T2, T3, T4, T5}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5, T6} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5, T6}
        instance is equal to a specified ValueTuple{T1, T2, T3, T4, T5, T6}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6, System_ValueTuple_T7]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5, T6, T7}
        instance is equal to a specified ValueTuple{T1, T2, T3, T4, T5, T6, T7}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance is equal to a specified object.
        
        :param obj: The object to compare with this instance.
        :returns: true if the current instance is equal to the specified object; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: System.ValueTuple[System_ValueTuple_T1, System_ValueTuple_T2, System_ValueTuple_T3, System_ValueTuple_T4, System_ValueTuple_T5, System_ValueTuple_T6, System_ValueTuple_T7, System_ValueTuple_TRest]) -> bool:
        """
        Returns a value that indicates whether the current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest}
        instance is equal to a specified ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest}.
        
        :param other: The tuple to compare with this instance.
        :returns: true if the current instance is equal to the specified tuple; otherwise, false.
        """
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for this instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2, T3} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2, T3, T4} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2, T3, T4, T5} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2, T3, T4, T5, T6} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        """
        Returns the hash code for the current ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple instance.
        
        :returns: The string representation of this ValueTuple instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1} instance.
        
        :returns: The string representation of this ValueTuple{T1} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2, T3} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2, T3} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2, T3, T4} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2, T3, T4} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2, T3, T4, T5} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2, T3, T4, T5} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2, T3, T4, T5, T6} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2, T3, T4, T5, T6} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2, T3, T4, T5, T6, T7} instance.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Returns a string that represents the value of this ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance.
        
        :returns: The string representation of this ValueTuple{T1, T2, T3, T4, T5, T6, T7, TRest} instance.
        """
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...

    @overload
    def ToStringEnd(self) -> str:
        ...


class UIntPtr(System.Runtime.Serialization.ISerializable, System.IBinaryInteger[System_UIntPtr], System.IMinMaxValue[System_UIntPtr], System.IUnsignedNumber[System_UIntPtr]):
    """This class has no documentation."""

    Zero: System.UIntPtr

    Size: int

    MaxValue: System.UIntPtr

    MinValue: System.UIntPtr

    AdditiveIdentity: System.UIntPtr

    AllBitsSet: System.UIntPtr

    @property
    def value(self) -> System.UIntPtr:
        ...

    @value.setter
    def value(self, value: System.UIntPtr):
        ...

    MultiplicativeIdentity: System.UIntPtr

    One: System.UIntPtr

    Radix: int

    @staticmethod
    def () -> System.UIntPtr:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any) -> None:
        ...

    @staticmethod
    def Abs(value: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def Add(pointer: System.UIntPtr, offset: int) -> System.UIntPtr:
        ...

    @staticmethod
    def Clamp(value: System.UIntPtr, min: System.UIntPtr, max: System.UIntPtr) -> System.UIntPtr:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: System.UIntPtr) -> int:
        ...

    @staticmethod
    def CopySign(value: System.UIntPtr, sign: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def CreateChecked(value: System_UIntPtr_CreateChecked_TOther) -> System.UIntPtr:
        ...

    @staticmethod
    def CreateSaturating(value: System_UIntPtr_CreateSaturating_TOther) -> System.UIntPtr:
        ...

    @staticmethod
    def CreateTruncating(value: System_UIntPtr_CreateTruncating_TOther) -> System.UIntPtr:
        ...

    @staticmethod
    def DivRem(left: System.UIntPtr, right: System.UIntPtr) -> System.ValueTuple[System.UIntPtr, System.UIntPtr]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: System.UIntPtr) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    @staticmethod
    def IsCanonical(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsFinite(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsInteger(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsNaN(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsNegative(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsNormal(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsPositive(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsPow2(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def IsZero(value: System.UIntPtr) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def Log2(value: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def Max(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def MaxMagnitude(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def MaxNumber(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def Min(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def MinMagnitude(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def MinNumber(x: System.UIntPtr, y: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.UIntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> System.UIntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.UIntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> System.UIntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System.UIntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> System.UIntPtr:
        ...

    @staticmethod
    def PopCount(value: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def RotateLeft(value: System.UIntPtr, rotateAmount: int) -> System.UIntPtr:
        ...

    @staticmethod
    def RotateRight(value: System.UIntPtr, rotateAmount: int) -> System.UIntPtr:
        ...

    @staticmethod
    def Sign(value: System.UIntPtr) -> int:
        ...

    @staticmethod
    def Subtract(pointer: System.UIntPtr, offset: int) -> System.UIntPtr:
        ...

    def ToPointer(self) -> typing.Any:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToUInt32(self) -> int:
        ...

    def ToUInt64(self) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: System.UIntPtr) -> System.UIntPtr:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromChecked_TOther, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromSaturating_TOther, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertFromTruncating_TOther, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    def TryConvertToChecked(value: System.UIntPtr, result: typing.Optional[System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: System.UIntPtr, result: typing.Optional[System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: System.UIntPtr, result: typing.Optional[System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_UIntPtr_System_Numerics_INumberBase<nuint>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        """
        Tries to parse a string into a value.
        
        :param s: A read-only span of characters containing a number to convert.
        :param provider: An object that provides culture-specific formatting information about .
        :param result: When this method returns, contains the result of successfully parsing  or an undefined value on failure.
        :returns: true if  was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[System.UIntPtr]) -> typing.Union[bool, System.UIntPtr]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class Array(System.Object, System.ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    IntrosortSizeThreshold: int = 16

    @property
    def Count(self) -> int:
        ...

    @property
    def SyncRoot(self) -> System.Object:
        ...

    @property
    def IsReadOnly(self) -> bool:
        ...

    @property
    def IsFixedSize(self) -> bool:
        ...

    @property
    def IsSynchronized(self) -> bool:
        ...

    MaxLength: int
    """Gets the maximum number of elements that may be contained in an array."""

    @property
    def Length(self) -> int:
        ...

    @property
    def NativeLength(self) -> System.UIntPtr:
        ...

    @property
    def LongLength(self) -> int:
        ...

    @property
    def Rank(self) -> int:
        ...

    def __getitem__(self, index: int) -> typing.Any:
        ...

    def __setitem__(self, index: int, value: typing.Any) -> None:
        ...

    def Add(self, value: typing.Any) -> int:
        ...

    @staticmethod
    def AsReadOnly(array: typing.List[System_Array_AsReadOnly_T]) -> System.Collections.ObjectModel.ReadOnlyCollection[System_Array_AsReadOnly_T]:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: System.Array, value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: System.Array, index: int, length: int, value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: System.Array, value: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: System.Array, index: int, length: int, value: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: typing.List[System_Array_BinarySearch_T], value: System_Array_BinarySearch_T) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: typing.List[System_Array_BinarySearch_T], value: System_Array_BinarySearch_T, comparer: System.Collections.Generic.IComparer[System_Array_BinarySearch_T]) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: typing.List[System_Array_BinarySearch_T], index: int, length: int, value: System_Array_BinarySearch_T) -> int:
        ...

    @staticmethod
    @overload
    def BinarySearch(array: typing.List[System_Array_BinarySearch_T], index: int, length: int, value: System_Array_BinarySearch_T, comparer: System.Collections.Generic.IComparer[System_Array_BinarySearch_T]) -> int:
        ...

    @overload
    def Clear(self) -> None:
        ...

    @staticmethod
    @overload
    def Clear(array: System.Array) -> None:
        ...

    @staticmethod
    @overload
    def Clear(array: System.Array, index: int, length: int) -> None:
        ...

    def Clone(self) -> System.Object:
        ...

    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @staticmethod
    def ConstrainedCopy(sourceArray: System.Array, sourceIndex: int, destinationArray: System.Array, destinationIndex: int, length: int) -> None:
        ...

    def Contains(self, value: typing.Any) -> bool:
        ...

    @staticmethod
    def ConvertAll(array: typing.List[System_Array_ConvertAll_TInput], converter: typing.Callable[[System_Array_ConvertAll_TInput], System_Array_ConvertAll_TOutput]) -> typing.List[System_Array_ConvertAll_TOutput]:
        ...

    @staticmethod
    @overload
    def Copy(sourceArray: System.Array, destinationArray: System.Array, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Copy(sourceArray: System.Array, sourceIndex: int, destinationArray: System.Array, destinationIndex: int, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Copy(sourceArray: System.Array, destinationArray: System.Array, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Copy(sourceArray: System.Array, sourceIndex: int, destinationArray: System.Array, destinationIndex: int, length: int) -> None:
        ...

    @overload
    def CopyTo(self, array: System.Array, index: int) -> None:
        ...

    @overload
    def CopyTo(self, array: System.Array, index: int) -> None:
        ...

    @staticmethod
    @overload
    def CreateInstance(elementType: typing.Type, length: int) -> System.Array:
        ...

    @staticmethod
    @overload
    def CreateInstance(elementType: typing.Type, length1: int, length2: int) -> System.Array:
        ...

    @staticmethod
    @overload
    def CreateInstance(elementType: typing.Type, length1: int, length2: int, length3: int) -> System.Array:
        ...

    @staticmethod
    @overload
    def CreateInstance(elementType: typing.Type, *lengths: int) -> System.Array:
        ...

    @staticmethod
    @overload
    def CreateInstance(elementType: typing.Type, lengths: typing.List[int], lowerBounds: typing.List[int]) -> System.Array:
        ...

    @staticmethod
    @overload
    def CreateInstance(elementType: typing.Type, *lengths: int) -> System.Array:
        ...

    @staticmethod
    def Empty() -> typing.List[System_Array_Empty_T]:
        ...

    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @staticmethod
    def Exists(array: typing.List[System_Array_Exists_T], match: typing.Callable[[System_Array_Exists_T], bool]) -> bool:
        ...

    @staticmethod
    @overload
    def Fill(array: typing.List[System_Array_Fill_T], value: System_Array_Fill_T) -> None:
        ...

    @staticmethod
    @overload
    def Fill(array: typing.List[System_Array_Fill_T], value: System_Array_Fill_T, startIndex: int, count: int) -> None:
        ...

    @staticmethod
    def Find(array: typing.List[System_Array_Find_T], match: typing.Callable[[System_Array_Find_T], bool]) -> System_Array_Find_T:
        ...

    @staticmethod
    def FindAll(array: typing.List[System_Array_FindAll_T], match: typing.Callable[[System_Array_FindAll_T], bool]) -> typing.List[System_Array_FindAll_T]:
        ...

    @staticmethod
    @overload
    def FindIndex(array: typing.List[System_Array_FindIndex_T], match: typing.Callable[[System_Array_FindIndex_T], bool]) -> int:
        ...

    @staticmethod
    @overload
    def FindIndex(array: typing.List[System_Array_FindIndex_T], startIndex: int, match: typing.Callable[[System_Array_FindIndex_T], bool]) -> int:
        ...

    @staticmethod
    @overload
    def FindIndex(array: typing.List[System_Array_FindIndex_T], startIndex: int, count: int, match: typing.Callable[[System_Array_FindIndex_T], bool]) -> int:
        ...

    @staticmethod
    def FindLast(array: typing.List[System_Array_FindLast_T], match: typing.Callable[[System_Array_FindLast_T], bool]) -> System_Array_FindLast_T:
        ...

    @staticmethod
    @overload
    def FindLastIndex(array: typing.List[System_Array_FindLastIndex_T], match: typing.Callable[[System_Array_FindLastIndex_T], bool]) -> int:
        ...

    @staticmethod
    @overload
    def FindLastIndex(array: typing.List[System_Array_FindLastIndex_T], startIndex: int, match: typing.Callable[[System_Array_FindLastIndex_T], bool]) -> int:
        ...

    @staticmethod
    @overload
    def FindLastIndex(array: typing.List[System_Array_FindLastIndex_T], startIndex: int, count: int, match: typing.Callable[[System_Array_FindLastIndex_T], bool]) -> int:
        ...

    @staticmethod
    def ForEach(array: typing.List[System_Array_ForEach_T], action: typing.Callable[[System_Array_ForEach_T], None]) -> None:
        ...

    def GetEnumerator(self) -> System.Collections.IEnumerator:
        ...

    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    def GetLength(self, dimension: int) -> int:
        ...

    def GetLongLength(self, dimension: int) -> int:
        ...

    def GetLowerBound(self, dimension: int) -> int:
        ...

    def GetUpperBound(self, dimension: int) -> int:
        ...

    @overload
    def GetValue(self, *indices: int) -> System.Object:
        ...

    @overload
    def GetValue(self, index: int) -> System.Object:
        ...

    @overload
    def GetValue(self, index1: int, index2: int) -> System.Object:
        ...

    @overload
    def GetValue(self, index1: int, index2: int, index3: int) -> System.Object:
        ...

    @overload
    def GetValue(self, index: int) -> System.Object:
        ...

    @overload
    def GetValue(self, index1: int, index2: int) -> System.Object:
        ...

    @overload
    def GetValue(self, index1: int, index2: int, index3: int) -> System.Object:
        ...

    @overload
    def GetValue(self, *indices: int) -> System.Object:
        ...

    @overload
    def IndexOf(self, value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def IndexOf(array: System.Array, value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def IndexOf(array: System.Array, value: typing.Any, startIndex: int) -> int:
        ...

    @staticmethod
    @overload
    def IndexOf(array: System.Array, value: typing.Any, startIndex: int, count: int) -> int:
        ...

    @staticmethod
    @overload
    def IndexOf(array: typing.List[System_Array_IndexOf_T], value: System_Array_IndexOf_T) -> int:
        ...

    @staticmethod
    @overload
    def IndexOf(array: typing.List[System_Array_IndexOf_T], value: System_Array_IndexOf_T, startIndex: int) -> int:
        ...

    @staticmethod
    @overload
    def IndexOf(array: typing.List[System_Array_IndexOf_T], value: System_Array_IndexOf_T, startIndex: int, count: int) -> int:
        ...

    def Initialize(self) -> None:
        ...

    def Insert(self, index: int, value: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def LastIndexOf(array: System.Array, value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOf(array: System.Array, value: typing.Any, startIndex: int) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOf(array: System.Array, value: typing.Any, startIndex: int, count: int) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOf(array: typing.List[System_Array_LastIndexOf_T], value: System_Array_LastIndexOf_T) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOf(array: typing.List[System_Array_LastIndexOf_T], value: System_Array_LastIndexOf_T, startIndex: int) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOf(array: typing.List[System_Array_LastIndexOf_T], value: System_Array_LastIndexOf_T, startIndex: int, count: int) -> int:
        ...

    def Remove(self, value: typing.Any) -> None:
        ...

    def RemoveAt(self, index: int) -> None:
        ...

    @staticmethod
    def Resize(array: typing.List[System_Array_Resize_T], newSize: int) -> None:
        ...

    @staticmethod
    @overload
    def Reverse(array: System.Array) -> None:
        ...

    @staticmethod
    @overload
    def Reverse(array: System.Array, index: int, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Reverse(array: typing.List[System_Array_Reverse_T]) -> None:
        ...

    @staticmethod
    @overload
    def Reverse(array: typing.List[System_Array_Reverse_T], index: int, length: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, index: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, index1: int, index2: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, index1: int, index2: int, index3: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, *indices: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, index: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, index1: int, index2: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, index1: int, index2: int, index3: int) -> None:
        ...

    @overload
    def SetValue(self, value: typing.Any, *indices: int) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: System.Array) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Array, items: System.Array) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: System.Array, index: int, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Array, items: System.Array, index: int, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: System.Array, comparer: System.Collections.IComparer) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Array, items: System.Array, comparer: System.Collections.IComparer) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: System.Array, index: int, length: int, comparer: System.Collections.IComparer) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Array, items: System.Array, index: int, length: int, comparer: System.Collections.IComparer) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: typing.List[System_Array_Sort_T]) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: typing.List[System_Array_Sort_TKey], items: typing.List[System_Array_Sort_TValue]) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: typing.List[System_Array_Sort_T], index: int, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: typing.List[System_Array_Sort_TKey], items: typing.List[System_Array_Sort_TValue], index: int, length: int) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: typing.List[System_Array_Sort_T], comparer: System.Collections.Generic.IComparer[System_Array_Sort_T]) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: typing.List[System_Array_Sort_TKey], items: typing.List[System_Array_Sort_TValue], comparer: System.Collections.Generic.IComparer[System_Array_Sort_TKey]) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: typing.List[System_Array_Sort_T], index: int, length: int, comparer: System.Collections.Generic.IComparer[System_Array_Sort_T]) -> None:
        ...

    @staticmethod
    @overload
    def Sort(keys: typing.List[System_Array_Sort_TKey], items: typing.List[System_Array_Sort_TValue], index: int, length: int, comparer: System.Collections.Generic.IComparer[System_Array_Sort_TKey]) -> None:
        ...

    @staticmethod
    @overload
    def Sort(array: typing.List[System_Array_Sort_T], comparison: typing.Callable[[System_Array_Sort_T, System_Array_Sort_T], int]) -> None:
        ...

    @staticmethod
    def TrueForAll(array: typing.List[System_Array_TrueForAll_T], match: typing.Callable[[System_Array_TrueForAll_T], bool]) -> bool:
        ...


class Enum(System.Object, System.IComparable, System.IFormattable, System.IConvertible, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def CompareTo(self, target: typing.Any) -> int:
        ...

    def Equals(self, obj: typing.Any) -> bool:
        ...

    @staticmethod
    def Format(enumType: typing.Type, value: typing.Any, format: str) -> str:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    @overload
    def GetName(value: System_Enum_GetName_TEnum) -> str:
        ...

    @staticmethod
    @overload
    def GetName(enumType: typing.Type, value: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def GetNames() -> typing.List[str]:
        ...

    @staticmethod
    @overload
    def GetNames(enumType: typing.Type) -> typing.List[str]:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def GetUnderlyingType(enumType: typing.Type) -> typing.Type:
        ...

    @staticmethod
    def GetValues(enumType: System_Enum_GetValues_TEnum) -> typing.List[System_Enum_GetValues_TEnum]:
        ...

    @staticmethod
    @overload
    def GetValuesAsUnderlyingType() -> System.Array:
        """
        Retrieves an array of the values of the underlying type constants in a specified enumeration type.
        
        :returns: An array that contains the values of the underlying type constants in TEnum.
        """
        ...

    @staticmethod
    @overload
    def GetValuesAsUnderlyingType(enumType: typing.Type) -> System.Array:
        """
        Retrieves an array of the values of the underlying type constants in a specified enumeration.
        
        :param enumType: An enumeration type.
        :returns: An array that contains the values of the underlying type constants in  .
        """
        ...

    def HasFlag(self, flag: System.Enum) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(value: System_Enum_IsDefined_TEnum) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(enumType: typing.Type, value: typing.Any) -> bool:
        ...

    @staticmethod
    @overload
    def Parse(enumType: typing.Type, value: str) -> System.Object:
        ...

    @staticmethod
    @overload
    def Parse(enumType: typing.Type, value: System.ReadOnlySpan[str]) -> System.Object:
        """
        Converts the span of chars representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.
        
        :param enumType: An enumeration type.
        :param value: A span containing the name or value to convert.
        :returns: An object of type  whose value is represented by .
        """
        ...

    @staticmethod
    @overload
    def Parse(enumType: typing.Type, value: str, ignoreCase: bool) -> System.Object:
        ...

    @staticmethod
    @overload
    def Parse(enumType: typing.Type, value: System.ReadOnlySpan[str], ignoreCase: bool) -> System.Object:
        """
        Converts the span of chars representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object. A parameter specifies whether the operation is case-insensitive.
        
        :param enumType: An enumeration type.
        :param value: A span containing the name or value to convert.
        :param ignoreCase: true to ignore case; false to regard case.
        :returns: An object of type  whose value is represented by .
        """
        ...

    @staticmethod
    @overload
    def Parse(value: str) -> System_Enum_Parse_TEnum:
        ...

    @staticmethod
    @overload
    def Parse(value: System.ReadOnlySpan[str]) -> System_Enum_Parse_TEnum:
        """
        Converts the span of chars representation of the name or numeric value of one or more enumerated constants specified by TEnum to an equivalent enumerated object.
        
        :param value: A span containing the name or value to convert.
        :returns: TEnum An object of type TEnum whose value is represented by .
        """
        ...

    @staticmethod
    @overload
    def Parse(value: str, ignoreCase: bool) -> System_Enum_Parse_TEnum:
        ...

    @staticmethod
    @overload
    def Parse(value: System.ReadOnlySpan[str], ignoreCase: bool) -> System_Enum_Parse_TEnum:
        """
        Converts the span of chars representation of the name or numeric value of one or more enumerated constants specified by TEnum to an equivalent enumerated object. A parameter specifies whether the operation is case-insensitive.
        
        :param value: A span containing the name or value to convert.
        :param ignoreCase: true to ignore case; false to regard case.
        :returns: TEnum An object of type TEnum whose value is represented by .
        """
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: typing.Any) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToObject(enumType: typing.Type, value: int) -> System.Object:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        """The provider argument is not used. Use ToString(String) instead."""
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        """The provider argument is not used. Use ToString() instead."""
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def TryParse(enumType: typing.Type, value: str, result: typing.Optional[typing.Any]) -> typing.Union[bool, typing.Any]:
        ...

    @staticmethod
    @overload
    def TryParse(enumType: typing.Type, value: System.ReadOnlySpan[str], result: typing.Optional[typing.Any]) -> typing.Union[bool, typing.Any]:
        """
        Converts the span of chars representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.
        
        :param enumType: The enum type to use for parsing.
        :param value: The span representation of the name or numeric value of one or more enumerated constants.
        :param result: When this method returns true, an object containing an enumeration constant representing the parsed value.
        :returns: true if the conversion succeeded; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryParse(enumType: typing.Type, value: str, ignoreCase: bool, result: typing.Optional[typing.Any]) -> typing.Union[bool, typing.Any]:
        ...

    @staticmethod
    @overload
    def TryParse(enumType: typing.Type, value: System.ReadOnlySpan[str], ignoreCase: bool, result: typing.Optional[typing.Any]) -> typing.Union[bool, typing.Any]:
        """
        Converts the span of chars representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object. A parameter specifies whether the operation is case-insensitive.
        
        :param enumType: The enum type to use for parsing.
        :param value: The span representation of the name or numeric value of one or more enumerated constants.
        :param ignoreCase: true to read  in case insensitive mode; false to read  in case sensitive mode.
        :param result: When this method returns true, an object containing an enumeration constant representing the parsed value.
        :returns: true if the conversion succeeded; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryParse(value: str, result: typing.Optional[System_Enum_TryParse_TEnum]) -> typing.Union[bool, System_Enum_TryParse_TEnum]:
        ...

    @staticmethod
    @overload
    def TryParse(value: System.ReadOnlySpan[str], result: typing.Optional[System_Enum_TryParse_TEnum]) -> typing.Union[bool, System_Enum_TryParse_TEnum]:
        """
        Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.
        
        :param value: The span representation of the name or numeric value of one or more enumerated constants.
        :param result: When this method returns true, an object containing an enumeration constant representing the parsed value.
        :returns: true if the conversion succeeded; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryParse(value: str, ignoreCase: bool, result: typing.Optional[System_Enum_TryParse_TEnum]) -> typing.Union[bool, System_Enum_TryParse_TEnum]:
        ...

    @staticmethod
    @overload
    def TryParse(value: System.ReadOnlySpan[str], ignoreCase: bool, result: typing.Optional[System_Enum_TryParse_TEnum]) -> typing.Union[bool, System_Enum_TryParse_TEnum]:
        """
        Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object. A parameter specifies whether the operation is case-sensitive. The return value indicates whether the conversion succeeded.
        
        :param value: The span representation of the name or numeric value of one or more enumerated constants.
        :param ignoreCase: true to ignore case; false to consider case.
        :param result: When this method returns true, an object containing an enumeration constant representing the parsed value.
        :returns: true if the conversion succeeded; false otherwise.
        """
        ...


class DateTimeKind(System.Enum):
    """This class has no documentation."""

    Unspecified = 0

    Utc = 1

    Local = 2


class DateTime(System.IComparable[datetime.datetime], System.ISpanFormattable, System.IConvertible, System.IEquatable[datetime.datetime], System.Runtime.Serialization.ISerializable, System.ISpanParsable[datetime.datetime]):
    """This class has no documentation."""

    MicrosecondsPerMillisecond: int = 1000

    DaysTo1970: int = ...

    MinTicks: int = 0

    MaxTicks: int = ...

    UnixEpochTicks: int = ...

    MinValue: datetime.datetime

    MaxValue: datetime.datetime = ...

    UnixEpoch: datetime.datetime = ...

    @property
    def Date(self) -> datetime.datetime:
        ...

    @property
    def Day(self) -> int:
        ...

    @property
    def DayOfWeek(self) -> int:
        """This property contains the int value of a member of the System.DayOfWeek enum."""
        ...

    @property
    def DayOfYear(self) -> int:
        ...

    @property
    def Hour(self) -> int:
        ...

    @property
    def Kind(self) -> int:
        """This property contains the int value of a member of the System.DateTimeKind enum."""
        ...

    @property
    def Millisecond(self) -> int:
        ...

    @property
    def Microsecond(self) -> int:
        """The microseconds component, expressed as a value between 0 and 999."""
        ...

    @property
    def Nanosecond(self) -> int:
        """The nanoseconds component, expressed as a value between 0 and 900 (in increments of 100 nanoseconds)."""
        ...

    @property
    def Minute(self) -> int:
        ...

    @property
    def Month(self) -> int:
        ...

    Now: datetime.datetime

    @property
    def Second(self) -> int:
        ...

    @property
    def Ticks(self) -> int:
        ...

    @property
    def TimeOfDay(self) -> datetime.timedelta:
        ...

    Today: datetime.datetime

    @property
    def Year(self) -> int:
        ...

    SystemSupportsLeapSeconds: bool

    UtcNow: datetime.datetime

    @overload
    def __init__(self, ticks: int) -> None:
        ...

    @overload
    def __init__(self, ticks: int, kind: System.DateTimeKind) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, calendar: System.Globalization.Calendar) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: System.Globalization.Calendar, kind: System.DateTimeKind) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through the number of years in ).
        :param month: The month (1 through the number of months in ).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param calendar: The calendar that is used to interpret , , and .
        :param kind: One of the enumeration values that indicates whether , , , , , , and  specify a local time, Coordinated Universal Time (UTC), or neither.
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, kind: System.DateTimeKind) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: System.Globalization.Calendar) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: System.DateTimeKind) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param kind: One of the enumeration values that indicates whether , , , , , , and  specify a local time, Coordinated Universal Time (UTC), or neither.
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: System.Globalization.Calendar) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through the number of years in ).
        :param month: The month (1 through the number of months in ).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param calendar: The calendar that is used to interpret , , and .
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param microsecond: The microseconds (0 through 999).
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, kind: System.DateTimeKind) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param microsecond: The microseconds (0 through 999).
        :param kind: One of the enumeration values that indicates whether , , , , , , and  specify a local time, Coordinated Universal Time (UTC), or neither.
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: System.Globalization.Calendar) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through the number of years in ).
        :param month: The month (1 through the number of months in ).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param microsecond: The microseconds (0 through 999).
        :param calendar: The calendar that is used to interpret , , and .
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: System.Globalization.Calendar, kind: System.DateTimeKind) -> None:
        """
        Initializes a new instance of the DateTime structure to the specified year, month, day, hour, minute, second,
        millisecond, and Coordinated Universal Time (UTC) or local time for the specified calendar.
        
        :param year: The year (1 through the number of years in ).
        :param month: The month (1 through the number of months in ).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param microsecond: The microseconds (0 through 999).
        :param calendar: The calendar that is used to interpret , , and .
        :param kind: One of the enumeration values that indicates whether , , , , , , and  specify a local time, Coordinated Universal Time (UTC), or neither.
        """
        ...

    def Add(self, value: datetime.timedelta) -> datetime.datetime:
        ...

    def AddDays(self, value: float) -> datetime.datetime:
        """
        Returns a new DateTime that adds the specified number of days to the value of this instance.
        
        :param value: A number of whole and fractional days. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the date and time represented by this instance and the number of days represented by value.
        """
        ...

    def AddHours(self, value: float) -> datetime.datetime:
        """
        Returns a new DateTime that adds the specified number of hours to the value of this instance.
        
        :param value: A number of whole and fractional hours. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the date and time represented by this instance and the number of hours represented by value.
        """
        ...

    def AddMicroseconds(self, value: float) -> datetime.datetime:
        """
        Returns a new DateTime that adds the specified number of microseconds to the value of this instance.
        
        :param value: A number of whole and fractional microseconds. The  parameter can be negative or positive. Note that this value is rounded to the nearest integer.
        :returns: An object whose value is the sum of the date and time represented by this instance and the number of microseconds represented by .
        """
        ...

    def AddMilliseconds(self, value: float) -> datetime.datetime:
        """
        Returns a new DateTime that adds the specified number of milliseconds to the value of this instance.
        
        :param value: A number of whole and fractional milliseconds. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the date and time represented by this instance and the number of milliseconds represented by value.
        """
        ...

    def AddMinutes(self, value: float) -> datetime.datetime:
        """
        Returns a new DateTime that adds the specified number of minutes to the value of this instance.
        
        :param value: A number of whole and fractional minutes. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the date and time represented by this instance and the number of minutes represented by value.
        """
        ...

    def AddMonths(self, months: int) -> datetime.datetime:
        ...

    def AddSeconds(self, value: float) -> datetime.datetime:
        """
        Returns a new DateTime that adds the specified number of seconds to the value of this instance.
        
        :param value: A number of whole and fractional seconds. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the date and time represented by this instance and the number of seconds represented by value.
        """
        ...

    def AddTicks(self, value: int) -> datetime.datetime:
        ...

    def AddYears(self, value: int) -> datetime.datetime:
        ...

    @staticmethod
    def Compare(t1: typing.Union[datetime.datetime, datetime.date], t2: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    def DaysInMonth(year: int, month: int) -> int:
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, value: typing.Union[datetime.datetime, datetime.date]) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(t1: typing.Union[datetime.datetime, datetime.date], t2: typing.Union[datetime.datetime, datetime.date]) -> bool:
        ...

    @staticmethod
    def FromBinary(dateData: int) -> datetime.datetime:
        ...

    @staticmethod
    def FromFileTime(fileTime: int) -> datetime.datetime:
        ...

    @staticmethod
    def FromFileTimeUtc(fileTime: int) -> datetime.datetime:
        ...

    @staticmethod
    def FromOADate(d: float) -> datetime.datetime:
        ...

    @overload
    def GetDateTimeFormats(self) -> typing.List[str]:
        ...

    @overload
    def GetDateTimeFormats(self, provider: System.IFormatProvider) -> typing.List[str]:
        ...

    @overload
    def GetDateTimeFormats(self, format: str) -> typing.List[str]:
        ...

    @overload
    def GetDateTimeFormats(self, format: str, provider: System.IFormatProvider) -> typing.List[str]:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    def IsDaylightSavingTime(self) -> bool:
        ...

    @staticmethod
    def IsLeapYear(year: int) -> bool:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider = None, styles: System.Globalization.DateTimeStyles = ...) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, format: str, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, format: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> datetime.datetime:
        ...

    @staticmethod
    def SpecifyKind(value: typing.Union[datetime.datetime, datetime.date], kind: System.DateTimeKind) -> datetime.datetime:
        ...

    @overload
    def Subtract(self, value: typing.Union[datetime.datetime, datetime.date]) -> datetime.timedelta:
        ...

    @overload
    def Subtract(self, value: datetime.timedelta) -> datetime.datetime:
        ...

    def ToBinary(self) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToFileTime(self) -> int:
        ...

    def ToFileTimeUtc(self) -> int:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToLocalTime(self) -> datetime.datetime:
        ...

    def ToLongDateString(self) -> str:
        ...

    def ToLongTimeString(self) -> str:
        ...

    def ToOADate(self) -> float:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToShortDateString(self) -> str:
        ...

    def ToShortTimeString(self) -> str:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUniversalTime(self) -> datetime.datetime:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, format: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[typing.Union[datetime.datetime, datetime.date]]) -> typing.Union[bool, typing.Union[datetime.datetime, datetime.date]]:
        ...


class Index(System.IEquatable[System_Index]):
    """Represent a type can be used to index a collection either from the start or the end."""

    Start: System.Index
    """Create an Index pointing at first element."""

    End: System.Index
    """Create an Index pointing at beyond last element."""

    @property
    def Value(self) -> int:
        """Returns the index value."""
        ...

    @property
    def IsFromEnd(self) -> bool:
        """Indicates whether the index is from the start or the end."""
        ...

    def __init__(self, value: int, fromEnd: bool = False) -> None:
        """
        Construct an Index using a value and indicating if the index is from the start or from the end.
        
        :param value: The index value. it has to be zero or positive number.
        :param fromEnd: Indicating if the index is from the start or from the end.
        """
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        """
        Indicates whether the current Index object is equal to another object of the same type.
        
        :param value: An object to compare with this object
        """
        ...

    @overload
    def Equals(self, other: System.Index) -> bool:
        """
        Indicates whether the current Index object is equal to another Index object.
        
        :param other: An object to compare with this object
        """
        ...

    @staticmethod
    def FromEnd(value: int) -> System.Index:
        """
        Create an Index from the end at the position indicated by the value.
        
        :param value: The index value from the end.
        """
        ...

    @staticmethod
    def FromStart(value: int) -> System.Index:
        """
        Create an Index from the start at the position indicated by the value.
        
        :param value: The index value from the start.
        """
        ...

    def GetHashCode(self) -> int:
        """Returns the hash code for this instance."""
        ...

    def GetOffset(self, length: int) -> int:
        """
        Calculate the offset from the start using the giving collection length.
        
        :param length: The length of the collection that the Index will be used with. length has to be a positive value
        """
        ...

    def ToString(self) -> str:
        """Converts the value of the current Index object to its equivalent string representation."""
        ...


class Range(System.IEquatable[System_Range]):
    """Represent a range has start and end indexes."""

    @property
    def Start(self) -> System.Index:
        """Represent the inclusive start index of the Range."""
        ...

    @property
    def End(self) -> System.Index:
        """Represent the exclusive end index of the Range."""
        ...

    All: System.Range
    """Create a Range object starting from first element to the end."""

    def __init__(self, start: System.Index, end: System.Index) -> None:
        """
        Construct a Range object using the start and end indexes.
        
        :param start: Represent the inclusive start index of the range.
        :param end: Represent the exclusive end index of the range.
        """
        ...

    @staticmethod
    def EndAt(end: System.Index) -> System.Range:
        """Create a Range object starting from first element in the collection to the end Index."""
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        """
        Indicates whether the current Range object is equal to another object of the same type.
        
        :param value: An object to compare with this object
        """
        ...

    @overload
    def Equals(self, other: System.Range) -> bool:
        """
        Indicates whether the current Range object is equal to another Range object.
        
        :param other: An object to compare with this object
        """
        ...

    def GetHashCode(self) -> int:
        """Returns the hash code for this instance."""
        ...

    def GetOffsetAndLength(self, length: int) -> System.ValueTuple[int, int]:
        """
        Calculate the start offset and length of range object using a collection length.
        
        :param length: The length of the collection that the range will be used with. length has to be a positive value.
        """
        ...

    @staticmethod
    def StartAt(start: System.Index) -> System.Range:
        """Create a Range object starting from start index to the end of the collection."""
        ...

    def ToString(self) -> str:
        """Converts the value of the current Range object to its equivalent string representation."""
        ...


class Memory(typing.Generic[System_Memory_T], System.IEquatable[System_Memory]):
    """
    Memory represents a contiguous region of arbitrary memory similar to Span{T}.
    Unlike Span{T}, it is not a byref-like type.
    """

    Empty: System.Memory[System_Memory_T]
    """Returns an empty Memory{T}"""

    @property
    def Length(self) -> int:
        """The number of items in the memory."""
        ...

    @property
    def IsEmpty(self) -> bool:
        """Returns true if Length is 0."""
        ...

    @property
    def Span(self) -> System.Span[System_Memory_T]:
        """Returns a span from the memory."""
        ...

    @overload
    def __init__(self, array: typing.List[System_Memory_T]) -> None:
        """
        Creates a new memory over the entirety of the target array.
        
        :param array: The target array.
        """
        ...

    @overload
    def __init__(self, array: typing.List[System_Memory_T], start: int, length: int) -> None:
        """
        Creates a new memory over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the memory.
        :param length: The number of items in the memory.
        """
        ...

    def CopyTo(self, destination: System.Memory[System_Memory_T]) -> None:
        """
        Copies the contents of the memory into the destination. If the source
        and destination overlap, this method behaves as if the original values are in
        a temporary location before the destination is overwritten.
        
        :param destination: The Memory to copy items into.
        """
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """
        Determines whether the specified object is equal to the current object.
        Returns true if the object is Memory or ReadOnlyMemory and if both objects point to the same array and have the same length.
        """
        ...

    @overload
    def Equals(self, other: System.Memory[System_Memory_T]) -> bool:
        """
        Returns true if the memory points to the same array and has the same length.  Note that
        this does *not* check to see if the *contents* are equal.
        """
        ...

    def GetHashCode(self) -> int:
        """Serves as the default hash function."""
        ...

    def Pin(self) -> System.Buffers.MemoryHandle:
        """
        Creates a handle for the memory.
        The GC will not move the memory until the returned MemoryHandle
        is disposed, enabling taking and using the memory's address.
        """
        ...

    @overload
    def Slice(self, start: int) -> System.Memory[System_Memory_T]:
        """
        Forms a slice out of the given memory, beginning at 'start'.
        
        :param start: The index at which to begin this slice.
        """
        ...

    @overload
    def Slice(self, start: int, length: int) -> System.Memory[System_Memory_T]:
        """
        Forms a slice out of the given memory, beginning at 'start', of given length
        
        :param start: The index at which to begin this slice.
        :param length: The desired length for the slice (exclusive).
        """
        ...

    def ToArray(self) -> typing.List[System_Memory_T]:
        """
        Copies the contents from the memory into a new array.  This heap
        allocates, so should generally be avoided, however it is sometimes
        necessary to bridge the gap with APIs written in terms of arrays.
        """
        ...

    def ToString(self) -> str:
        """
        For Memory{Char}, returns a new instance of string that represents the characters pointed to by the memory.
        Otherwise, returns a string with the name of the type and the number of elements.
        """
        ...

    def TryCopyTo(self, destination: System.Memory[System_Memory_T]) -> bool:
        """
        Copies the contents of the memory into the destination. If the source
        and destination overlap, this method behaves as if the original values are in
        a temporary location before the destination is overwritten.
        
        :param destination: The span to copy items into.
        :returns: If the destination is shorter than the source, this method return false and no data is written to the destination.
        """
        ...


class ReadOnlyMemory(typing.Generic[System_ReadOnlyMemory_T], System.IEquatable[System_ReadOnlyMemory]):
    """
    Represents a contiguous region of memory, similar to ReadOnlySpan{T}.
    Unlike ReadOnlySpan{T}, it is not a byref-like type.
    """

    RemoveFlagsBitMask: int = ...

    Empty: System.ReadOnlyMemory[System_ReadOnlyMemory_T]
    """Returns an empty ReadOnlyMemory{T}"""

    @property
    def Length(self) -> int:
        """The number of items in the memory."""
        ...

    @property
    def IsEmpty(self) -> bool:
        """Returns true if Length is 0."""
        ...

    @property
    def Span(self) -> System.ReadOnlySpan[System_ReadOnlyMemory_T]:
        """Returns a span from the memory."""
        ...

    @overload
    def __init__(self, array: typing.List[System_ReadOnlyMemory_T]) -> None:
        """
        Creates a new memory over the entirety of the target array.
        
        :param array: The target array.
        """
        ...

    @overload
    def __init__(self, array: typing.List[System_ReadOnlyMemory_T], start: int, length: int) -> None:
        """
        Creates a new memory over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the memory.
        :param length: The number of items in the memory.
        """
        ...

    def CopyTo(self, destination: System.Memory[System_ReadOnlyMemory_T]) -> None:
        """
        Copies the contents of the read-only memory into the destination. If the source
        and destination overlap, this method behaves as if the original values are in
        a temporary location before the destination is overwritten.
        
        :param destination: The Memory to copy items into.
        """
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """Determines whether the specified object is equal to the current object."""
        ...

    @overload
    def Equals(self, other: System.ReadOnlyMemory[System_ReadOnlyMemory_T]) -> bool:
        """
        Returns true if the memory points to the same array and has the same length.  Note that
        this does *not* check to see if the *contents* are equal.
        """
        ...

    def GetHashCode(self) -> int:
        """Returns the hash code for this ReadOnlyMemory{T}"""
        ...

    def Pin(self) -> System.Buffers.MemoryHandle:
        """
        Creates a handle for the memory.
        The GC will not move the memory until the returned MemoryHandle
        is disposed, enabling taking and using the memory's address.
        """
        ...

    @overload
    def Slice(self, start: int) -> System.ReadOnlyMemory[System_ReadOnlyMemory_T]:
        """
        Forms a slice out of the given memory, beginning at 'start'.
        
        :param start: The index at which to begin this slice.
        """
        ...

    @overload
    def Slice(self, start: int, length: int) -> System.ReadOnlyMemory[System_ReadOnlyMemory_T]:
        """
        Forms a slice out of the given memory, beginning at 'start', of given length
        
        :param start: The index at which to begin this slice.
        :param length: The desired length for the slice (exclusive).
        """
        ...

    def ToArray(self) -> typing.List[System_ReadOnlyMemory_T]:
        """
        Copies the contents from the memory into a new array.  This heap
        allocates, so should generally be avoided, however it is sometimes
        necessary to bridge the gap with APIs written in terms of arrays.
        """
        ...

    def ToString(self) -> str:
        """
        For ReadOnlyMemory{Char}, returns a new instance of string that represents the characters pointed to by the memory.
        Otherwise, returns a string with the name of the type and the number of elements.
        """
        ...

    def TryCopyTo(self, destination: System.Memory[System_ReadOnlyMemory_T]) -> bool:
        """
        Copies the contents of the readonly-only memory into the destination. If the source
        and destination overlap, this method behaves as if the original values are in
        a temporary location before the destination is overwritten.
        
        :param destination: The span to copy items into.
        :returns: If the destination is shorter than the source, this method return false and no data is written to the destination.
        """
        ...


class MemberAccessException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class MissingMemberException(System.MemberAccessException):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @property
    def ClassName(self) -> str:
        """This field is protected."""
        ...

    @ClassName.setter
    def ClassName(self, value: str):
        """This field is protected."""
        ...

    @property
    def MemberName(self) -> str:
        """This field is protected."""
        ...

    @MemberName.setter
    def MemberName(self, value: str):
        """This field is protected."""
        ...

    @property
    def Signature(self) -> typing.List[int]:
        """This field is protected."""
        ...

    @Signature.setter
    def Signature(self, value: typing.List[int]):
        """This field is protected."""
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, className: str, memberName: str) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...


class MissingMethodException(System.MissingMemberException):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, className: str, methodName: str) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class StringComparison(System.Enum):
    """This class has no documentation."""

    CurrentCulture = 0

    CurrentCultureIgnoreCase = 1

    InvariantCulture = 2

    InvariantCultureIgnoreCase = 3

    Ordinal = 4

    OrdinalIgnoreCase = 5


class ArraySegment(typing.Generic[System_ArraySegment_T], System.Collections.Generic.IList[System_ArraySegment_T], System.Collections.Generic.IReadOnlyList[System_ArraySegment_T], typing.Iterable[System_ArraySegment_T]):
    """This class has no documentation."""

    class Enumerator:
        """This class has no documentation."""

        @property
        def Current(self) -> System_ArraySegment_T:
            ...

        def Dispose(self) -> None:
            ...

        def MoveNext(self) -> bool:
            ...

        def Reset(self) -> None:
            ...

    Empty: System.ArraySegment[System_ArraySegment_T]

    @property
    def Array(self) -> typing.List[System_ArraySegment_T]:
        ...

    @property
    def Offset(self) -> int:
        ...

    @property
    def Count(self) -> int:
        ...

    @property
    def IsReadOnly(self) -> bool:
        ...

    @overload
    def __getitem__(self, index: int) -> System_ArraySegment_T:
        ...

    @overload
    def __getitem__(self, index: int) -> System_ArraySegment_T:
        ...

    @overload
    def __getitem__(self, index: int) -> System_ArraySegment_T:
        ...

    @overload
    def __init__(self, array: typing.List[System_ArraySegment_T]) -> None:
        ...

    @overload
    def __init__(self, array: typing.List[System_ArraySegment_T], offset: int, count: int) -> None:
        ...

    @overload
    def __setitem__(self, index: int, value: System_ArraySegment_T) -> None:
        ...

    @overload
    def __setitem__(self, index: int, value: System_ArraySegment_T) -> None:
        ...

    def Add(self, item: System_ArraySegment_T) -> None:
        ...

    def Clear(self) -> None:
        ...

    def Contains(self, item: System_ArraySegment_T) -> bool:
        ...

    @overload
    def CopyTo(self, destination: typing.List[System_ArraySegment_T]) -> None:
        ...

    @overload
    def CopyTo(self, destination: typing.List[System_ArraySegment_T], destinationIndex: int) -> None:
        ...

    @overload
    def CopyTo(self, destination: System.ArraySegment[System_ArraySegment_T]) -> None:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: System.ArraySegment[System_ArraySegment_T]) -> bool:
        ...

    @overload
    def GetEnumerator(self) -> System.ArraySegment.Enumerator:
        ...

    @overload
    def GetEnumerator(self) -> System.Collections.Generic.IEnumerator[System_ArraySegment_T]:
        ...

    @overload
    def GetEnumerator(self) -> System.Collections.IEnumerator:
        ...

    def GetHashCode(self) -> int:
        ...

    def IndexOf(self, item: System_ArraySegment_T) -> int:
        ...

    def Insert(self, index: int, item: System_ArraySegment_T) -> None:
        ...

    def Remove(self, item: System_ArraySegment_T) -> bool:
        ...

    def RemoveAt(self, index: int) -> None:
        ...

    @overload
    def Slice(self, index: int) -> System.ArraySegment[System_ArraySegment_T]:
        ...

    @overload
    def Slice(self, index: int, count: int) -> System.ArraySegment[System_ArraySegment_T]:
        ...

    def ToArray(self) -> typing.List[System_ArraySegment_T]:
        ...


class MemoryExtensions(System.Object):
    """Extension methods for Span{T}, Memory{T}, and friends."""

    class TryWriteInterpolatedStringHandler:
        """Provides a handler used by the language compiler to format interpolated strings into character spans."""

        @property
        def _pos(self) -> int:
            """The number of characters written to _destination."""
            ...

        @_pos.setter
        def _pos(self, value: int):
            """The number of characters written to _destination."""
            ...

        @property
        def _success(self) -> bool:
            """true if all formatting operations have succeeded; otherwise, false."""
            ...

        @_success.setter
        def _success(self, value: bool):
            """true if all formatting operations have succeeded; otherwise, false."""
            ...

        @overload
        def __init__(self, literalLength: int, formattedCount: int, destination: System.Span[str], shouldAppend: typing.Optional[bool]) -> typing.Union[None, bool]:
            """
            Creates a handler used to write an interpolated string into a Span{Char}.
            
            :param literalLength: The number of constant characters outside of interpolation expressions in the interpolated string.
            :param formattedCount: The number of interpolation expressions in the interpolated string.
            :param destination: The destination buffer.
            :param shouldAppend: Upon return, true if the destination may be long enough to support the formatting, or false if it won't be.
            """
            ...

        @overload
        def __init__(self, literalLength: int, formattedCount: int, destination: System.Span[str], provider: System.IFormatProvider, shouldAppend: typing.Optional[bool]) -> typing.Union[None, bool]:
            """
            Creates a handler used to write an interpolated string into a Span{Char}.
            
            :param literalLength: The number of constant characters outside of interpolation expressions in the interpolated string.
            :param formattedCount: The number of interpolation expressions in the interpolated string.
            :param destination: The destination buffer.
            :param provider: An object that supplies culture-specific formatting information.
            :param shouldAppend: Upon return, true if the destination may be long enough to support the formatting, or false if it won't be.
            """
            ...

        @overload
        def AppendFormatted(self, value: System_MemoryExtensions_AppendFormatted_TryWriteInterpolatedStringHandler_T) -> bool:
            ...

        @overload
        def AppendFormatted(self, value: System_MemoryExtensions_AppendFormatted_TryWriteInterpolatedStringHandler_T, format: str) -> bool:
            """
            Writes the specified value to the handler.
            
            :param value: The value to write.
            :param format: The format string.
            """
            ...

        @overload
        def AppendFormatted(self, value: System_MemoryExtensions_AppendFormatted_TryWriteInterpolatedStringHandler_T, alignment: int) -> bool:
            """
            Writes the specified value to the handler.
            
            :param value: The value to write.
            :param alignment: Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            """
            ...

        @overload
        def AppendFormatted(self, value: System_MemoryExtensions_AppendFormatted_TryWriteInterpolatedStringHandler_T, alignment: int, format: str) -> bool:
            """
            Writes the specified value to the handler.
            
            :param value: The value to write.
            :param alignment: Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            :param format: The format string.
            """
            ...

        @overload
        def AppendFormatted(self, value: str) -> bool:
            ...

        @overload
        def AppendFormatted(self, value: str, alignment: int = 0, format: str = None) -> bool:
            """
            Writes the specified value to the handler.
            
            :param value: The value to write.
            :param alignment: Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            :param format: The format string.
            """
            ...

        @overload
        def AppendFormatted(self, value: typing.Any, alignment: int = 0, format: str = None) -> bool:
            ...

        def AppendLiteral(self, value: str) -> bool:
            """
            Writes the specified string to the handler.
            
            :param value: The string to write.
            :returns: true if the value could be formatted to the span; otherwise, false.
            """
            ...

    @staticmethod
    @overload
    def AsMemory(text: str) -> System.ReadOnlyMemory[str]:
        """
        Creates a new ReadOnlyMemory{T} over the portion of the target string.
        
        :param text: The target string.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(text: str, start: int) -> System.ReadOnlyMemory[str]:
        """
        Creates a new ReadOnlyMemory{T} over the portion of the target string.
        
        :param text: The target string.
        :param start: The index at which to begin this slice.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(text: str, startIndex: System.Index) -> System.ReadOnlyMemory[str]:
        """
        Creates a new ReadOnlyMemory{T} over the portion of the target string.
        
        :param text: The target string.
        :param startIndex: The index at which to begin this slice.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(text: str, start: int, length: int) -> System.ReadOnlyMemory[str]:
        """
        Creates a new ReadOnlyMemory{T} over the portion of the target string.
        
        :param text: The target string.
        :param start: The index at which to begin this slice.
        :param length: The desired length for the slice (exclusive).
        """
        ...

    @staticmethod
    @overload
    def AsMemory(text: str, range: System.Range) -> System.ReadOnlyMemory[str]:
        """
        Creates a new ReadOnlyMemory{T} over the portion of the target string.
        
        :param text: The target string.
        :param range: The range used to indicate the start and length of the sliced string.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(array: typing.List[System_MemoryExtensions_AsMemory_T]) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """Creates a new memory over the target array."""
        ...

    @staticmethod
    @overload
    def AsMemory(array: typing.List[System_MemoryExtensions_AsMemory_T], start: int) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """
        Creates a new memory over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the memory.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(array: typing.List[System_MemoryExtensions_AsMemory_T], startIndex: System.Index) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """
        Creates a new memory over the portion of the target array starting from
        'startIndex' to the end of the array.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(array: typing.List[System_MemoryExtensions_AsMemory_T], start: int, length: int) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """
        Creates a new memory over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the memory.
        :param length: The number of items in the memory.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(array: typing.List[System_MemoryExtensions_AsMemory_T], range: System.Range) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """
        Creates a new memory over the portion of the target array beginning at inclusive start index of the range
        and ending at the exclusive end index of the range.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(segment: System.ArraySegment[System_MemoryExtensions_AsMemory_T]) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """Creates a new memory over the portion of the target array."""
        ...

    @staticmethod
    @overload
    def AsMemory(segment: System.ArraySegment[System_MemoryExtensions_AsMemory_T], start: int) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """
        Creates a new memory over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param segment: The target array.
        :param start: The index at which to begin the memory.
        """
        ...

    @staticmethod
    @overload
    def AsMemory(segment: System.ArraySegment[System_MemoryExtensions_AsMemory_T], start: int, length: int) -> System.Memory[System_MemoryExtensions_AsMemory_T]:
        """
        Creates a new memory over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param segment: The target array.
        :param start: The index at which to begin the memory.
        :param length: The number of items in the memory.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(array: typing.List[System_MemoryExtensions_AsSpan_T], start: int) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """Creates a new span over the portion of the target array."""
        ...

    @staticmethod
    @overload
    def AsSpan(array: typing.List[System_MemoryExtensions_AsSpan_T], startIndex: System.Index) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """Creates a new span over the portion of the target array."""
        ...

    @staticmethod
    @overload
    def AsSpan(array: typing.List[System_MemoryExtensions_AsSpan_T], range: System.Range) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """Creates a new span over the portion of the target array."""
        ...

    @staticmethod
    @overload
    def AsSpan(text: str) -> System.ReadOnlySpan[str]:
        """
        Creates a new readonly span over the portion of the target string.
        
        :param text: The target string.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(text: str, start: int) -> System.ReadOnlySpan[str]:
        """
        Creates a new readonly span over the portion of the target string.
        
        :param text: The target string.
        :param start: The index at which to begin this slice.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(text: str, start: int, length: int) -> System.ReadOnlySpan[str]:
        """
        Creates a new readonly span over the portion of the target string.
        
        :param text: The target string.
        :param start: The index at which to begin this slice.
        :param length: The desired length for the slice (exclusive).
        """
        ...

    @staticmethod
    @overload
    def AsSpan(array: typing.List[System_MemoryExtensions_AsSpan_T]) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """Creates a new span over the target array."""
        ...

    @staticmethod
    @overload
    def AsSpan(array: typing.List[System_MemoryExtensions_AsSpan_T], start: int, length: int) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """
        Creates a new Span over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param array: The target array.
        :param start: The index at which to begin the Span.
        :param length: The number of items in the Span.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(segment: System.ArraySegment[System_MemoryExtensions_AsSpan_T]) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """Creates a new span over the portion of the target array segment."""
        ...

    @staticmethod
    @overload
    def AsSpan(segment: System.ArraySegment[System_MemoryExtensions_AsSpan_T], start: int) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """
        Creates a new Span over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param segment: The target array.
        :param start: The index at which to begin the Span.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(segment: System.ArraySegment[System_MemoryExtensions_AsSpan_T], startIndex: System.Index) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """
        Creates a new Span over the portion of the target array beginning
        at 'startIndex' and ending at the end of the segment.
        
        :param segment: The target array.
        :param startIndex: The index at which to begin the Span.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(segment: System.ArraySegment[System_MemoryExtensions_AsSpan_T], start: int, length: int) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """
        Creates a new Span over the portion of the target array beginning
        at 'start' index and ending at 'end' index (exclusive).
        
        :param segment: The target array.
        :param start: The index at which to begin the Span.
        :param length: The number of items in the Span.
        """
        ...

    @staticmethod
    @overload
    def AsSpan(segment: System.ArraySegment[System_MemoryExtensions_AsSpan_T], range: System.Range) -> System.Span[System_MemoryExtensions_AsSpan_T]:
        """
        Creates a new Span over the portion of the target array using the range start and end indexes
        
        :param segment: The target array.
        :param range: The range which has start and end indexes to use for slicing the array.
        """
        ...

    @staticmethod
    @overload
    def BinarySearch(span: System.Span[System_MemoryExtensions_BinarySearch_T], comparable: System.IComparable[System_MemoryExtensions_BinarySearch_T]) -> int:
        """
        Searches an entire sorted Span{T} for a value
        using the specified IComparable{T} generic interface.
        
        :param span: The sorted Span{T} to search.
        :param comparable: The IComparable{T} to use when comparing.
        :returns: The zero-based index of  in the sorted , if  is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than  or, if there is no larger element, the bitwise complement of Span{T}.Length.
        """
        ...

    @staticmethod
    @overload
    def BinarySearch(span: System.Span[System_MemoryExtensions_BinarySearch_T], comparable: System_MemoryExtensions_BinarySearch_TComparable) -> int:
        """
        Searches an entire sorted Span{T} for a value
        using the specified TComparable generic type.
        
        :param span: The sorted Span{T} to search.
        :param comparable: The TComparable to use when comparing.
        :returns: The zero-based index of  in the sorted , if  is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than  or, if there is no larger element, the bitwise complement of Span{T}.Length.
        """
        ...

    @staticmethod
    @overload
    def BinarySearch(span: System.Span[System_MemoryExtensions_BinarySearch_T], value: System_MemoryExtensions_BinarySearch_T, comparer: System_MemoryExtensions_BinarySearch_TComparer) -> int:
        """
        Searches an entire sorted Span{T} for the specified 
        using the specified TComparer generic type.
        
        :param span: The sorted Span{T} to search.
        :param value: The object to locate. The value can be null for reference types.
        :param comparer: The TComparer to use when comparing.
        :returns: The zero-based index of  in the sorted , if  is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than  or, if there is no larger element, the bitwise complement of Span{T}.Length.
        """
        ...

    @staticmethod
    @overload
    def BinarySearch(span: System.ReadOnlySpan[System_MemoryExtensions_BinarySearch_T], comparable: System.IComparable[System_MemoryExtensions_BinarySearch_T]) -> int:
        """
        Searches an entire sorted ReadOnlySpan{T} for a value
        using the specified IComparable{T} generic interface.
        
        :param span: The sorted ReadOnlySpan{T} to search.
        :param comparable: The IComparable{T} to use when comparing.
        :returns: The zero-based index of  in the sorted , if  is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than  or, if there is no larger element, the bitwise complement of ReadOnlySpan{T}.Length.
        """
        ...

    @staticmethod
    @overload
    def BinarySearch(span: System.ReadOnlySpan[System_MemoryExtensions_BinarySearch_T], comparable: System_MemoryExtensions_BinarySearch_TComparable) -> int:
        """
        Searches an entire sorted ReadOnlySpan{T} for a value
        using the specified TComparable generic type.
        
        :param span: The sorted ReadOnlySpan{T} to search.
        :param comparable: The TComparable to use when comparing.
        :returns: The zero-based index of  in the sorted , if  is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than  or, if there is no larger element, the bitwise complement of ReadOnlySpan{T}.Length.
        """
        ...

    @staticmethod
    @overload
    def BinarySearch(span: System.ReadOnlySpan[System_MemoryExtensions_BinarySearch_T], value: System_MemoryExtensions_BinarySearch_T, comparer: System_MemoryExtensions_BinarySearch_TComparer) -> int:
        """
        Searches an entire sorted ReadOnlySpan{T} for the specified 
        using the specified TComparer generic type.
        
        :param span: The sorted ReadOnlySpan{T} to search.
        :param value: The object to locate. The value can be null for reference types.
        :param comparer: The TComparer to use when comparing.
        :returns: The zero-based index of  in the sorted , if  is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than  or, if there is no larger element, the bitwise complement of ReadOnlySpan{T}.Length.
        """
        ...

    @staticmethod
    @overload
    def CommonPrefixLength(span: System.Span[System_MemoryExtensions_CommonPrefixLength_T], other: System.ReadOnlySpan[System_MemoryExtensions_CommonPrefixLength_T]) -> int:
        """
        Finds the length of any common prefix shared between  and .
        
        :param span: The first sequence to compare.
        :param other: The second sequence to compare.
        :returns: The length of the common prefix shared by the two spans.  If there's no shared prefix, 0 is returned.
        """
        ...

    @staticmethod
    @overload
    def CommonPrefixLength(span: System.Span[System_MemoryExtensions_CommonPrefixLength_T], other: System.ReadOnlySpan[System_MemoryExtensions_CommonPrefixLength_T], comparer: System.Collections.Generic.IEqualityComparer[System_MemoryExtensions_CommonPrefixLength_T]) -> int:
        """
        Finds the length of any common prefix shared between  and .
        
        :param span: The first sequence to compare.
        :param other: The second sequence to compare.
        :param comparer: The IEqualityComparer{T} implementation to use when comparing elements, or null to use the default IEqualityComparer{T} for the type of an element.
        :returns: The length of the common prefix shared by the two spans.  If there's no shared prefix, 0 is returned.
        """
        ...

    @staticmethod
    @overload
    def CommonPrefixLength(span: System.ReadOnlySpan[System_MemoryExtensions_CommonPrefixLength_T], other: System.ReadOnlySpan[System_MemoryExtensions_CommonPrefixLength_T]) -> int:
        """
        Finds the length of any common prefix shared between  and .
        
        :param span: The first sequence to compare.
        :param other: The second sequence to compare.
        :returns: The length of the common prefix shared by the two spans.  If there's no shared prefix, 0 is returned.
        """
        ...

    @staticmethod
    @overload
    def CommonPrefixLength(span: System.ReadOnlySpan[System_MemoryExtensions_CommonPrefixLength_T], other: System.ReadOnlySpan[System_MemoryExtensions_CommonPrefixLength_T], comparer: System.Collections.Generic.IEqualityComparer[System_MemoryExtensions_CommonPrefixLength_T]) -> int:
        """
        Determines the length of any common prefix shared between  and .
        
        :param span: The first sequence to compare.
        :param other: The second sequence to compare.
        :param comparer: The IEqualityComparer{T} implementation to use when comparing elements, or null to use the default IEqualityComparer{T} for the type of an element.
        :returns: The length of the common prefix shared by the two spans.  If there's no shared prefix, 0 is returned.
        """
        ...

    @staticmethod
    def CompareTo(span: System.ReadOnlySpan[str], other: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> int:
        """
        Compares the specified  and  using the specified ,
        and returns an integer that indicates their relative position in the sort order.
        
        :param span: The source span.
        :param other: The value to compare with the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def Contains(span: System.ReadOnlySpan[str], value: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> bool:
        """
        Returns a value indicating whether the specified  occurs within the .
        
        :param span: The source span.
        :param value: The value to seek within the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def Contains(span: System.Span[System_MemoryExtensions_Contains_T], value: System_MemoryExtensions_Contains_T) -> bool:
        """
        Searches for the specified value and returns true if found. If not found, returns false. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The value to search for.
        """
        ...

    @staticmethod
    @overload
    def Contains(span: System.ReadOnlySpan[System_MemoryExtensions_Contains_T], value: System_MemoryExtensions_Contains_T) -> bool:
        """
        Searches for the specified value and returns true if found. If not found, returns false. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The value to search for.
        """
        ...

    @staticmethod
    @overload
    def CopyTo(source: typing.List[System_MemoryExtensions_CopyTo_T], destination: System.Span[System_MemoryExtensions_CopyTo_T]) -> None:
        """
        Copies the contents of the array into the span. If the source
        and destinations overlap, this method behaves as if the original values in
        a temporary location before the destination is overwritten.
        
        :param source: The array to copy items from.
        :param destination: The span to copy items into.
        """
        ...

    @staticmethod
    @overload
    def CopyTo(source: typing.List[System_MemoryExtensions_CopyTo_T], destination: System.Memory[System_MemoryExtensions_CopyTo_T]) -> None:
        """
        Copies the contents of the array into the memory. If the source
        and destinations overlap, this method behaves as if the original values are in
        a temporary location before the destination is overwritten.
        
        :param source: The array to copy items from.
        :param destination: The memory to copy items into.
        """
        ...

    @staticmethod
    @overload
    def EndsWith(span: System.ReadOnlySpan[str], value: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> bool:
        """
        Determines whether the end of the  matches the specified  when compared using the specified  option.
        
        :param span: The source span.
        :param value: The sequence to compare to the end of the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def EndsWith(span: System.Span[System_MemoryExtensions_EndsWith_T], value: System.ReadOnlySpan[System_MemoryExtensions_EndsWith_T]) -> bool:
        """Determines whether the specified sequence appears at the end of the span."""
        ...

    @staticmethod
    @overload
    def EndsWith(span: System.ReadOnlySpan[System_MemoryExtensions_EndsWith_T], value: System.ReadOnlySpan[System_MemoryExtensions_EndsWith_T]) -> bool:
        """Determines whether the specified sequence appears at the end of the span."""
        ...

    @staticmethod
    @overload
    def EnumerateLines(span: System.ReadOnlySpan[str]) -> System.Text.SpanLineEnumerator:
        """Returns an enumeration of lines over the provided span."""
        ...

    @staticmethod
    @overload
    def EnumerateLines(span: System.Span[str]) -> System.Text.SpanLineEnumerator:
        """Returns an enumeration of lines over the provided span."""
        ...

    @staticmethod
    @overload
    def EnumerateRunes(span: System.ReadOnlySpan[str]) -> System.Text.SpanRuneEnumerator:
        """Returns an enumeration of Rune from the provided span."""
        ...

    @staticmethod
    @overload
    def EnumerateRunes(span: System.Span[str]) -> System.Text.SpanRuneEnumerator:
        """Returns an enumeration of Rune from the provided span."""
        ...

    @staticmethod
    def Equals(span: System.ReadOnlySpan[str], other: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> bool:
        """
        Determines whether this  and the specified  span have the same characters
        when compared using the specified  option.
        
        :param span: The source span.
        :param other: The value to compare with the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def IndexOf(span: System.ReadOnlySpan[str], value: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> int:
        """
        Reports the zero-based index of the first occurrence of the specified  in the current .
        
        :param span: The source span.
        :param value: The value to seek within the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def IndexOf(span: System.Span[System_MemoryExtensions_IndexOf_T], value: System_MemoryExtensions_IndexOf_T) -> int:
        """
        Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The value to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOf(span: System.Span[System_MemoryExtensions_IndexOf_T], value: System.ReadOnlySpan[System_MemoryExtensions_IndexOf_T]) -> int:
        """
        Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The sequence to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOf(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOf_T], value: System_MemoryExtensions_IndexOf_T) -> int:
        """
        Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The value to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOf(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOf_T], value: System.ReadOnlySpan[System_MemoryExtensions_IndexOf_T]) -> int:
        """
        Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The sequence to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAny(span: System.Span[System_MemoryExtensions_IndexOfAny_T], value0: System_MemoryExtensions_IndexOfAny_T, value1: System_MemoryExtensions_IndexOfAny_T) -> int:
        """
        Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAny(span: System.Span[System_MemoryExtensions_IndexOfAny_T], value0: System_MemoryExtensions_IndexOfAny_T, value1: System_MemoryExtensions_IndexOfAny_T, value2: System_MemoryExtensions_IndexOfAny_T) -> int:
        """
        Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        :param value2: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAny(span: System.Span[System_MemoryExtensions_IndexOfAny_T], values: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAny_T]) -> int:
        """
        Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param values: The set of values to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAny(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAny_T], value0: System_MemoryExtensions_IndexOfAny_T, value1: System_MemoryExtensions_IndexOfAny_T) -> int:
        """
        Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAny(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAny_T], value0: System_MemoryExtensions_IndexOfAny_T, value1: System_MemoryExtensions_IndexOfAny_T, value2: System_MemoryExtensions_IndexOfAny_T) -> int:
        """
        Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        :param value2: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAny(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAny_T], values: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAny_T]) -> int:
        """
        Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param values: The set of values to search for.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.Span[System_MemoryExtensions_IndexOfAnyExcept_T], value: System_MemoryExtensions_IndexOfAnyExcept_T) -> int:
        """
        Searches for the first index of any value other than the specified .
        
        :param span: The span to search.
        :param value: A value to avoid.
        :returns: The index in the span of the first occurrence of any value other than . If all of the values are , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.Span[System_MemoryExtensions_IndexOfAnyExcept_T], value0: System_MemoryExtensions_IndexOfAnyExcept_T, value1: System_MemoryExtensions_IndexOfAnyExcept_T) -> int:
        """
        Searches for the first index of any value other than the specified  or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :returns: The index in the span of the first occurrence of any value other than  and . If all of the values are  or , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.Span[System_MemoryExtensions_IndexOfAnyExcept_T], value0: System_MemoryExtensions_IndexOfAnyExcept_T, value1: System_MemoryExtensions_IndexOfAnyExcept_T, value2: System_MemoryExtensions_IndexOfAnyExcept_T) -> int:
        """
        Searches for the first index of any value other than the specified , , or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :param value2: A value to avoid
        :returns: The index in the span of the first occurrence of any value other than , , and . If all of the values are , , and , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.Span[System_MemoryExtensions_IndexOfAnyExcept_T], values: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExcept_T]) -> int:
        """
        Searches for the first index of any value other than the specified .
        
        :param span: The span to search.
        :param values: The values to avoid.
        :returns: The index in the span of the first occurrence of any value other than those in . If all of the values are in , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExcept_T], value: System_MemoryExtensions_IndexOfAnyExcept_T) -> int:
        """
        Searches for the first index of any value other than the specified .
        
        :param span: The span to search.
        :param value: A value to avoid.
        :returns: The index in the span of the first occurrence of any value other than . If all of the values are , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExcept_T], value0: System_MemoryExtensions_IndexOfAnyExcept_T, value1: System_MemoryExtensions_IndexOfAnyExcept_T) -> int:
        """
        Searches for the first index of any value other than the specified  or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :returns: The index in the span of the first occurrence of any value other than  and . If all of the values are  or , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExcept_T], value0: System_MemoryExtensions_IndexOfAnyExcept_T, value1: System_MemoryExtensions_IndexOfAnyExcept_T, value2: System_MemoryExtensions_IndexOfAnyExcept_T) -> int:
        """
        Searches for the first index of any value other than the specified , , or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :param value2: A value to avoid
        :returns: The index in the span of the first occurrence of any value other than , , and . If all of the values are , , and , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExcept_T], values: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExcept_T]) -> int:
        """
        Searches for the first index of any value other than the specified .
        
        :param span: The span to search.
        :param values: The values to avoid.
        :returns: The index in the span of the first occurrence of any value other than those in . If all of the values are in , returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyExceptInRange(span: System.Span[System_MemoryExtensions_IndexOfAnyExceptInRange_T], lowInclusive: System_MemoryExtensions_IndexOfAnyExceptInRange_T, highInclusive: System_MemoryExtensions_IndexOfAnyExceptInRange_T) -> int:
        ...

    @staticmethod
    @overload
    def IndexOfAnyExceptInRange(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyExceptInRange_T], lowInclusive: System_MemoryExtensions_IndexOfAnyExceptInRange_T, highInclusive: System_MemoryExtensions_IndexOfAnyExceptInRange_T) -> int:
        """
        Searches for the first index of any value outside of the range between  and , inclusive.
        
        :param span: The span to search.
        :param lowInclusive: A lower bound, inclusive, of the excluded range.
        :param highInclusive: A upper bound, inclusive, of the excluded range.
        :returns: The index in the span of the first occurrence of any value outside of the specified range. If all of the values are inside of the specified range, returns -1.
        """
        ...

    @staticmethod
    @overload
    def IndexOfAnyInRange(span: System.Span[System_MemoryExtensions_IndexOfAnyInRange_T], lowInclusive: System_MemoryExtensions_IndexOfAnyInRange_T, highInclusive: System_MemoryExtensions_IndexOfAnyInRange_T) -> int:
        ...

    @staticmethod
    @overload
    def IndexOfAnyInRange(span: System.ReadOnlySpan[System_MemoryExtensions_IndexOfAnyInRange_T], lowInclusive: System_MemoryExtensions_IndexOfAnyInRange_T, highInclusive: System_MemoryExtensions_IndexOfAnyInRange_T) -> int:
        """
        Searches for the first index of any value in the range between  and , inclusive.
        
        :param span: The span to search.
        :param lowInclusive: A lower bound, inclusive, of the range for which to search.
        :param highInclusive: A upper bound, inclusive, of the range for which to search.
        :returns: The index in the span of the first occurrence of any value in the specified range. If all of the values are outside of the specified range, returns -1.
        """
        ...

    @staticmethod
    def IsWhiteSpace(span: System.ReadOnlySpan[str]) -> bool:
        """Indicates whether the specified span contains only white-space characters."""
        ...

    @staticmethod
    @overload
    def LastIndexOf(span: System.ReadOnlySpan[str], value: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> int:
        """
        Reports the zero-based index of the last occurrence of the specified  in the current .
        
        :param span: The source span.
        :param value: The value to seek within the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOf(span: System.Span[System_MemoryExtensions_LastIndexOf_T], value: System_MemoryExtensions_LastIndexOf_T) -> int:
        """
        Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The value to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOf(span: System.Span[System_MemoryExtensions_LastIndexOf_T], value: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOf_T]) -> int:
        """
        Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The sequence to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOf(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOf_T], value: System_MemoryExtensions_LastIndexOf_T) -> int:
        """
        Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The value to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOf(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOf_T], value: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOf_T]) -> int:
        """
        Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
        
        :param span: The span to search.
        :param value: The sequence to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAny(span: System.Span[System_MemoryExtensions_LastIndexOfAny_T], value0: System_MemoryExtensions_LastIndexOfAny_T, value1: System_MemoryExtensions_LastIndexOfAny_T) -> int:
        """
        Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAny(span: System.Span[System_MemoryExtensions_LastIndexOfAny_T], value0: System_MemoryExtensions_LastIndexOfAny_T, value1: System_MemoryExtensions_LastIndexOfAny_T, value2: System_MemoryExtensions_LastIndexOfAny_T) -> int:
        """
        Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        :param value2: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAny(span: System.Span[System_MemoryExtensions_LastIndexOfAny_T], values: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAny_T]) -> int:
        """
        Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param values: The set of values to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAny(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAny_T], value0: System_MemoryExtensions_LastIndexOfAny_T, value1: System_MemoryExtensions_LastIndexOfAny_T) -> int:
        """
        Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAny(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAny_T], value0: System_MemoryExtensions_LastIndexOfAny_T, value1: System_MemoryExtensions_LastIndexOfAny_T, value2: System_MemoryExtensions_LastIndexOfAny_T) -> int:
        """
        Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param value0: One of the values to search for.
        :param value1: One of the values to search for.
        :param value2: One of the values to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAny(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAny_T], values: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAny_T]) -> int:
        """
        Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
        
        :param span: The span to search.
        :param values: The set of values to search for.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.Span[System_MemoryExtensions_LastIndexOfAnyExcept_T], value: System_MemoryExtensions_LastIndexOfAnyExcept_T) -> int:
        """
        Searches for the last index of any value other than the specified .
        
        :param span: The span to search.
        :param value: A value to avoid.
        :returns: The index in the span of the last occurrence of any value other than . If all of the values are , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.Span[System_MemoryExtensions_LastIndexOfAnyExcept_T], value0: System_MemoryExtensions_LastIndexOfAnyExcept_T, value1: System_MemoryExtensions_LastIndexOfAnyExcept_T) -> int:
        """
        Searches for the last index of any value other than the specified  or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :returns: The index in the span of the last occurrence of any value other than  and . If all of the values are  or , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.Span[System_MemoryExtensions_LastIndexOfAnyExcept_T], value0: System_MemoryExtensions_LastIndexOfAnyExcept_T, value1: System_MemoryExtensions_LastIndexOfAnyExcept_T, value2: System_MemoryExtensions_LastIndexOfAnyExcept_T) -> int:
        """
        Searches for the last index of any value other than the specified , , or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :param value2: A value to avoid
        :returns: The index in the span of the last occurrence of any value other than , , and . If all of the values are , , and , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.Span[System_MemoryExtensions_LastIndexOfAnyExcept_T], values: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExcept_T]) -> int:
        """
        Searches for the last index of any value other than the specified .
        
        :param span: The span to search.
        :param values: The values to avoid.
        :returns: The index in the span of the last occurrence of any value other than those in . If all of the values are in , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExcept_T], value: System_MemoryExtensions_LastIndexOfAnyExcept_T) -> int:
        """
        Searches for the last index of any value other than the specified .
        
        :param span: The span to search.
        :param value: A value to avoid.
        :returns: The index in the span of the last occurrence of any value other than . If all of the values are , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExcept_T], value0: System_MemoryExtensions_LastIndexOfAnyExcept_T, value1: System_MemoryExtensions_LastIndexOfAnyExcept_T) -> int:
        """
        Searches for the last index of any value other than the specified  or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :returns: The index in the span of the last occurrence of any value other than  and . If all of the values are  or , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExcept_T], value0: System_MemoryExtensions_LastIndexOfAnyExcept_T, value1: System_MemoryExtensions_LastIndexOfAnyExcept_T, value2: System_MemoryExtensions_LastIndexOfAnyExcept_T) -> int:
        """
        Searches for the last index of any value other than the specified , , or .
        
        :param span: The span to search.
        :param value0: A value to avoid.
        :param value1: A value to avoid
        :param value2: A value to avoid
        :returns: The index in the span of the last occurrence of any value other than , , and . If all of the values are , , and , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExcept(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExcept_T], values: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExcept_T]) -> int:
        """
        Searches for the last index of any value other than the specified .
        
        :param span: The span to search.
        :param values: The values to avoid.
        :returns: The index in the span of the first occurrence of any value other than those in . If all of the values are in , returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExceptInRange(span: System.Span[System_MemoryExtensions_LastIndexOfAnyExceptInRange_T], lowInclusive: System_MemoryExtensions_LastIndexOfAnyExceptInRange_T, highInclusive: System_MemoryExtensions_LastIndexOfAnyExceptInRange_T) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyExceptInRange(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyExceptInRange_T], lowInclusive: System_MemoryExtensions_LastIndexOfAnyExceptInRange_T, highInclusive: System_MemoryExtensions_LastIndexOfAnyExceptInRange_T) -> int:
        """
        Searches for the last index of any value outside of the range between  and , inclusive.
        
        :param span: The span to search.
        :param lowInclusive: A lower bound, inclusive, of the excluded range.
        :param highInclusive: A upper bound, inclusive, of the excluded range.
        :returns: The index in the span of the last occurrence of any value outside of the specified range. If all of the values are inside of the specified range, returns -1.
        """
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyInRange(span: System.Span[System_MemoryExtensions_LastIndexOfAnyInRange_T], lowInclusive: System_MemoryExtensions_LastIndexOfAnyInRange_T, highInclusive: System_MemoryExtensions_LastIndexOfAnyInRange_T) -> int:
        ...

    @staticmethod
    @overload
    def LastIndexOfAnyInRange(span: System.ReadOnlySpan[System_MemoryExtensions_LastIndexOfAnyInRange_T], lowInclusive: System_MemoryExtensions_LastIndexOfAnyInRange_T, highInclusive: System_MemoryExtensions_LastIndexOfAnyInRange_T) -> int:
        """
        Searches for the last index of any value in the range between  and , inclusive.
        
        :param span: The span to search.
        :param lowInclusive: A lower bound, inclusive, of the range for which to search.
        :param highInclusive: A upper bound, inclusive, of the range for which to search.
        :returns: The index in the span of the last occurrence of any value in the specified range. If all of the values are outside of the specified range, returns -1.
        """
        ...

    @staticmethod
    @overload
    def Overlaps(span: System.Span[System_MemoryExtensions_Overlaps_T], other: System.ReadOnlySpan[System_MemoryExtensions_Overlaps_T]) -> bool:
        ...

    @staticmethod
    @overload
    def Overlaps(span: System.Span[System_MemoryExtensions_Overlaps_T], other: System.ReadOnlySpan[System_MemoryExtensions_Overlaps_T], elementOffset: typing.Optional[int]) -> typing.Union[bool, int]:
        """Determines whether two sequences overlap in memory and outputs the element offset."""
        ...

    @staticmethod
    @overload
    def Overlaps(span: System.ReadOnlySpan[System_MemoryExtensions_Overlaps_T], other: System.ReadOnlySpan[System_MemoryExtensions_Overlaps_T]) -> bool:
        """Determines whether two sequences overlap in memory."""
        ...

    @staticmethod
    @overload
    def Overlaps(span: System.ReadOnlySpan[System_MemoryExtensions_Overlaps_T], other: System.ReadOnlySpan[System_MemoryExtensions_Overlaps_T], elementOffset: typing.Optional[int]) -> typing.Union[bool, int]:
        """Determines whether two sequences overlap in memory and outputs the element offset."""
        ...

    @staticmethod
    def Replace(span: System.Span[System_MemoryExtensions_Replace_T], oldValue: System_MemoryExtensions_Replace_T, newValue: System_MemoryExtensions_Replace_T) -> None:
        """
        Replaces all occurrences of  with .
        
        :param span: The span in which the elements should be replaced.
        :param oldValue: The value to be replaced with .
        :param newValue: The value to replace all occurrences of .
        """
        ...

    @staticmethod
    def Reverse(span: System.Span[System_MemoryExtensions_Reverse_T]) -> None:
        """Reverses the sequence of the elements in the entire span."""
        ...

    @staticmethod
    @overload
    def SequenceCompareTo(span: System.Span[System_MemoryExtensions_SequenceCompareTo_T], other: System.ReadOnlySpan[System_MemoryExtensions_SequenceCompareTo_T]) -> int:
        """Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T)."""
        ...

    @staticmethod
    @overload
    def SequenceCompareTo(span: System.ReadOnlySpan[System_MemoryExtensions_SequenceCompareTo_T], other: System.ReadOnlySpan[System_MemoryExtensions_SequenceCompareTo_T]) -> int:
        """Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T)."""
        ...

    @staticmethod
    @overload
    def SequenceEqual(span: System.Span[System_MemoryExtensions_SequenceEqual_T], other: System.ReadOnlySpan[System_MemoryExtensions_SequenceEqual_T]) -> bool:
        """Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T)."""
        ...

    @staticmethod
    @overload
    def SequenceEqual(span: System.ReadOnlySpan[System_MemoryExtensions_SequenceEqual_T], other: System.ReadOnlySpan[System_MemoryExtensions_SequenceEqual_T]) -> bool:
        """Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T)."""
        ...

    @staticmethod
    @overload
    def SequenceEqual(span: System.Span[System_MemoryExtensions_SequenceEqual_T], other: System.ReadOnlySpan[System_MemoryExtensions_SequenceEqual_T], comparer: System.Collections.Generic.IEqualityComparer[System_MemoryExtensions_SequenceEqual_T] = None) -> bool:
        """
        Determines whether two sequences are equal by comparing the elements using an IEqualityComparer{T}.
        
        :param span: The first sequence to compare.
        :param other: The second sequence to compare.
        :param comparer: The IEqualityComparer{T} implementation to use when comparing elements, or null to use the default IEqualityComparer{T} for the type of an element.
        :returns: true if the two sequences are equal; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def SequenceEqual(span: System.ReadOnlySpan[System_MemoryExtensions_SequenceEqual_T], other: System.ReadOnlySpan[System_MemoryExtensions_SequenceEqual_T], comparer: System.Collections.Generic.IEqualityComparer[System_MemoryExtensions_SequenceEqual_T] = None) -> bool:
        """
        Determines whether two sequences are equal by comparing the elements using an IEqualityComparer{T}.
        
        :param span: The first sequence to compare.
        :param other: The second sequence to compare.
        :param comparer: The IEqualityComparer{T} implementation to use when comparing elements, or null to use the default IEqualityComparer{T} for the type of an element.
        :returns: true if the two sequences are equal; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def Sort(span: System.Span[System_MemoryExtensions_Sort_T]) -> None:
        """
        Sorts the elements in the entire Span{T} using the IComparable{T} implementation
        of each element of the Span{T}
        
        :param span: The Span{T} to sort.
        """
        ...

    @staticmethod
    @overload
    def Sort(span: System.Span[System_MemoryExtensions_Sort_T], comparer: System_MemoryExtensions_Sort_TComparer) -> None:
        """
        Sorts the elements in the entire Span{T} using the TComparer.
        
        :param span: The Span{T} to sort.
        :param comparer: The IComparer{T} implementation to use when comparing elements, or null to use the IComparable{T} interface implementation of each element.
        """
        ...

    @staticmethod
    @overload
    def Sort(span: System.Span[System_MemoryExtensions_Sort_T], comparison: typing.Callable[[System_MemoryExtensions_Sort_T, System_MemoryExtensions_Sort_T], int]) -> None:
        """
        Sorts the elements in the entire Span{T} using the specified Comparison{T}.
        
        :param span: The Span{T} to sort.
        :param comparison: The Comparison{T} to use when comparing elements.
        """
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Span[System_MemoryExtensions_Sort_TKey], items: System.Span[System_MemoryExtensions_Sort_TValue]) -> None:
        """
        Sorts a pair of spans (one containing the keys and the other containing the corresponding items)
        based on the keys in the first Span{TKey} using the IComparable{T}
        implementation of each key.
        
        :param keys: The span that contains the keys to sort.
        :param items: The span that contains the items that correspond to the keys in .
        """
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Span[System_MemoryExtensions_Sort_TKey], items: System.Span[System_MemoryExtensions_Sort_TValue], comparer: System_MemoryExtensions_Sort_TComparer) -> None:
        """
        Sorts a pair of spans (one containing the keys and the other containing the corresponding items)
        based on the keys in the first Span{TKey} using the specified comparer.
        
        :param keys: The span that contains the keys to sort.
        :param items: The span that contains the items that correspond to the keys in .
        :param comparer: The IComparer{T} implementation to use when comparing elements, or null to use the IComparable{T} interface implementation of each element.
        """
        ...

    @staticmethod
    @overload
    def Sort(keys: System.Span[System_MemoryExtensions_Sort_TKey], items: System.Span[System_MemoryExtensions_Sort_TValue], comparison: typing.Callable[[System_MemoryExtensions_Sort_TKey, System_MemoryExtensions_Sort_TKey], int]) -> None:
        """
        Sorts a pair of spans (one containing the keys and the other containing the corresponding items)
        based on the keys in the first Span{TKey} using the specified comparison.
        
        :param keys: The span that contains the keys to sort.
        :param items: The span that contains the items that correspond to the keys in .
        :param comparison: The Comparison{T} to use when comparing elements.
        """
        ...

    @staticmethod
    @overload
    def StartsWith(span: System.ReadOnlySpan[str], value: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> bool:
        """
        Determines whether the beginning of the  matches the specified  when compared using the specified  option.
        
        :param span: The source span.
        :param value: The sequence to compare to the beginning of the source span.
        :param comparisonType: One of the enumeration values that determines how the  and  are compared.
        """
        ...

    @staticmethod
    @overload
    def StartsWith(span: System.Span[System_MemoryExtensions_StartsWith_T], value: System.ReadOnlySpan[System_MemoryExtensions_StartsWith_T]) -> bool:
        """Determines whether the specified sequence appears at the start of the span."""
        ...

    @staticmethod
    @overload
    def StartsWith(span: System.ReadOnlySpan[System_MemoryExtensions_StartsWith_T], value: System.ReadOnlySpan[System_MemoryExtensions_StartsWith_T]) -> bool:
        """Determines whether the specified sequence appears at the start of the span."""
        ...

    @staticmethod
    def ToLower(source: System.ReadOnlySpan[str], destination: System.Span[str], culture: System.Globalization.CultureInfo) -> int:
        """
        Copies the characters from the source span into the destination, converting each character to lowercase,
        using the casing rules of the specified culture.
        
        :param source: The source span.
        :param destination: The destination span which contains the transformed characters.
        :param culture: An object that supplies culture-specific casing rules.
        :returns: The number of characters written into the destination span. If the destination is too small, returns -1.
        """
        ...

    @staticmethod
    def ToLowerInvariant(source: System.ReadOnlySpan[str], destination: System.Span[str]) -> int:
        """
        Copies the characters from the source span into the destination, converting each character to lowercase,
        using the casing rules of the invariant culture.
        
        :param source: The source span.
        :param destination: The destination span which contains the transformed characters.
        :returns: The number of characters written into the destination span. If the destination is too small, returns -1.
        """
        ...

    @staticmethod
    def ToUpper(source: System.ReadOnlySpan[str], destination: System.Span[str], culture: System.Globalization.CultureInfo) -> int:
        """
        Copies the characters from the source span into the destination, converting each character to uppercase,
        using the casing rules of the specified culture.
        
        :param source: The source span.
        :param destination: The destination span which contains the transformed characters.
        :param culture: An object that supplies culture-specific casing rules.
        :returns: The number of characters written into the destination span. If the destination is too small, returns -1.
        """
        ...

    @staticmethod
    def ToUpperInvariant(source: System.ReadOnlySpan[str], destination: System.Span[str]) -> int:
        """
        Copies the characters from the source span into the destination, converting each character to uppercase
        using the casing rules of the invariant culture.
        
        :param source: The source span.
        :param destination: The destination span which contains the transformed characters.
        :returns: The number of characters written into the destination span. If the destination is too small, returns -1.
        """
        ...

    @staticmethod
    @overload
    def Trim(memory: System.Memory[System_MemoryExtensions_Trim_T], trimElement: System_MemoryExtensions_Trim_T) -> System.Memory[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a specified element from the memory.
        
        :param memory: The source memory from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(memory: System.ReadOnlyMemory[System_MemoryExtensions_Trim_T], trimElement: System_MemoryExtensions_Trim_T) -> System.ReadOnlyMemory[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a specified element from the memory.
        
        :param memory: The source memory from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.Span[System_MemoryExtensions_Trim_T], trimElement: System_MemoryExtensions_Trim_T) -> System.Span[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a specified element from the span.
        
        :param span: The source span from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.ReadOnlySpan[System_MemoryExtensions_Trim_T], trimElement: System_MemoryExtensions_Trim_T) -> System.ReadOnlySpan[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a specified element from the span.
        
        :param span: The source span from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(memory: System.Memory[System_MemoryExtensions_Trim_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_Trim_T]) -> System.Memory[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a set of elements specified
        in a readonly span from the memory.
        
        :param memory: The source memory from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(memory: System.ReadOnlyMemory[System_MemoryExtensions_Trim_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_Trim_T]) -> System.ReadOnlyMemory[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a set of elements specified
        in a readonly span from the memory.
        
        :param memory: The source memory from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.Span[System_MemoryExtensions_Trim_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_Trim_T]) -> System.Span[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a set of elements specified
        in a readonly span from the span.
        
        :param span: The source span from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.ReadOnlySpan[System_MemoryExtensions_Trim_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_Trim_T]) -> System.ReadOnlySpan[System_MemoryExtensions_Trim_T]:
        """
        Removes all leading and trailing occurrences of a set of elements specified
        in a readonly span from the span.
        
        :param span: The source span from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(memory: System.Memory[str]) -> System.Memory[str]:
        """
        Removes all leading and trailing white-space characters from the memory.
        
        :param memory: The source memory from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def Trim(memory: System.ReadOnlyMemory[str]) -> System.ReadOnlyMemory[str]:
        """
        Removes all leading and trailing white-space characters from the memory.
        
        :param memory: The source memory from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.ReadOnlySpan[str]) -> System.ReadOnlySpan[str]:
        """
        Removes all leading and trailing white-space characters from the span.
        
        :param span: The source span from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.ReadOnlySpan[str], trimChar: str) -> System.ReadOnlySpan[str]:
        """
        Removes all leading and trailing occurrences of a specified character from the span.
        
        :param span: The source span from which the character is removed.
        :param trimChar: The specified character to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.ReadOnlySpan[str], trimChars: System.ReadOnlySpan[str]) -> System.ReadOnlySpan[str]:
        """
        Removes all leading and trailing occurrences of a set of characters specified
        in a readonly span from the span.
        
        :param span: The source span from which the characters are removed.
        :param trimChars: The span which contains the set of characters to remove.
        """
        ...

    @staticmethod
    @overload
    def Trim(span: System.Span[str]) -> System.Span[str]:
        """
        Removes all leading and trailing white-space characters from the span.
        
        :param span: The source span from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(memory: System.Memory[System_MemoryExtensions_TrimEnd_T], trimElement: System_MemoryExtensions_TrimEnd_T) -> System.Memory[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a specified element from the memory.
        
        :param memory: The source memory from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(memory: System.ReadOnlyMemory[System_MemoryExtensions_TrimEnd_T], trimElement: System_MemoryExtensions_TrimEnd_T) -> System.ReadOnlyMemory[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a specified element from the memory.
        
        :param memory: The source memory from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.Span[System_MemoryExtensions_TrimEnd_T], trimElement: System_MemoryExtensions_TrimEnd_T) -> System.Span[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a specified element from the span.
        
        :param span: The source span from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T], trimElement: System_MemoryExtensions_TrimEnd_T) -> System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a specified element from the span.
        
        :param span: The source span from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(memory: System.Memory[System_MemoryExtensions_TrimEnd_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T]) -> System.Memory[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a set of elements specified
        in a readonly span from the memory.
        
        :param memory: The source memory from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(memory: System.ReadOnlyMemory[System_MemoryExtensions_TrimEnd_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T]) -> System.ReadOnlyMemory[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a set of elements specified
        in a readonly span from the memory.
        
        :param memory: The source memory from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.Span[System_MemoryExtensions_TrimEnd_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T]) -> System.Span[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a set of elements specified
        in a readonly span from the span.
        
        :param span: The source span from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T]) -> System.ReadOnlySpan[System_MemoryExtensions_TrimEnd_T]:
        """
        Removes all trailing occurrences of a set of elements specified
        in a readonly span from the span.
        
        :param span: The source span from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(memory: System.Memory[str]) -> System.Memory[str]:
        """
        Removes all trailing white-space characters from the memory.
        
        :param memory: The source memory from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(memory: System.ReadOnlyMemory[str]) -> System.ReadOnlyMemory[str]:
        """
        Removes all trailing white-space characters from the memory.
        
        :param memory: The source memory from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.ReadOnlySpan[str]) -> System.ReadOnlySpan[str]:
        """
        Removes all trailing white-space characters from the span.
        
        :param span: The source span from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.ReadOnlySpan[str], trimChar: str) -> System.ReadOnlySpan[str]:
        """
        Removes all trailing occurrences of a specified character from the span.
        
        :param span: The source span from which the character is removed.
        :param trimChar: The specified character to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.ReadOnlySpan[str], trimChars: System.ReadOnlySpan[str]) -> System.ReadOnlySpan[str]:
        """
        Removes all trailing occurrences of a set of characters specified
        in a readonly span from the span.
        
        :param span: The source span from which the characters are removed.
        :param trimChars: The span which contains the set of characters to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimEnd(span: System.Span[str]) -> System.Span[str]:
        """
        Removes all trailing white-space characters from the span.
        
        :param span: The source span from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(memory: System.Memory[System_MemoryExtensions_TrimStart_T], trimElement: System_MemoryExtensions_TrimStart_T) -> System.Memory[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a specified element from the memory.
        
        :param memory: The source memory from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(memory: System.ReadOnlyMemory[System_MemoryExtensions_TrimStart_T], trimElement: System_MemoryExtensions_TrimStart_T) -> System.ReadOnlyMemory[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a specified element from the memory.
        
        :param memory: The source memory from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.Span[System_MemoryExtensions_TrimStart_T], trimElement: System_MemoryExtensions_TrimStart_T) -> System.Span[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a specified element from the span.
        
        :param span: The source span from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T], trimElement: System_MemoryExtensions_TrimStart_T) -> System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a specified element from the span.
        
        :param span: The source span from which the element is removed.
        :param trimElement: The specified element to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(memory: System.Memory[System_MemoryExtensions_TrimStart_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T]) -> System.Memory[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a set of elements specified
        in a readonly span from the memory.
        
        :param memory: The source memory from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(memory: System.ReadOnlyMemory[System_MemoryExtensions_TrimStart_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T]) -> System.ReadOnlyMemory[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a set of elements specified
        in a readonly span from the memory.
        
        :param memory: The source memory from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.Span[System_MemoryExtensions_TrimStart_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T]) -> System.Span[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a set of elements specified
        in a readonly span from the span.
        
        :param span: The source span from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T], trimElements: System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T]) -> System.ReadOnlySpan[System_MemoryExtensions_TrimStart_T]:
        """
        Removes all leading occurrences of a set of elements specified
        in a readonly span from the span.
        
        :param span: The source span from which the elements are removed.
        :param trimElements: The span which contains the set of elements to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(memory: System.Memory[str]) -> System.Memory[str]:
        """
        Removes all leading white-space characters from the memory.
        
        :param memory: The source memory from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(memory: System.ReadOnlyMemory[str]) -> System.ReadOnlyMemory[str]:
        """
        Removes all leading white-space characters from the memory.
        
        :param memory: The source memory from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.ReadOnlySpan[str]) -> System.ReadOnlySpan[str]:
        """
        Removes all leading white-space characters from the span.
        
        :param span: The source span from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.ReadOnlySpan[str], trimChar: str) -> System.ReadOnlySpan[str]:
        """
        Removes all leading occurrences of a specified character from the span.
        
        :param span: The source span from which the character is removed.
        :param trimChar: The specified character to look for and remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.ReadOnlySpan[str], trimChars: System.ReadOnlySpan[str]) -> System.ReadOnlySpan[str]:
        """
        Removes all leading occurrences of a set of characters specified
        in a readonly span from the span.
        
        :param span: The source span from which the characters are removed.
        :param trimChars: The span which contains the set of characters to remove.
        """
        ...

    @staticmethod
    @overload
    def TrimStart(span: System.Span[str]) -> System.Span[str]:
        """
        Removes all leading white-space characters from the span.
        
        :param span: The source span from which the characters are removed.
        """
        ...

    @staticmethod
    @overload
    def TryWrite(destination: System.Span[str], handler: System.MemoryExtensions.TryWriteInterpolatedStringHandler, charsWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        """
        Writes the specified interpolated string to the character span.
        
        :param destination: The span to which the interpolated string should be formatted.
        :param handler: The interpolated string.
        :param charsWritten: The number of characters written to the span.
        :returns: true if the entire interpolated string could be formatted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryWrite(destination: System.Span[str], provider: System.IFormatProvider, handler: System.MemoryExtensions.TryWriteInterpolatedStringHandler, charsWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        """
        Writes the specified interpolated string to the character span.
        
        :param destination: The span to which the interpolated string should be formatted.
        :param provider: An object that supplies culture-specific formatting information.
        :param handler: The interpolated string.
        :param charsWritten: The number of characters written to the span.
        :returns: true if the entire interpolated string could be formatted successfully; otherwise, false.
        """
        ...


class Version(System.Object, System.ICloneable, System.IComparable[System_Version], System.IEquatable[System_Version], System.ISpanFormattable):
    """This class has no documentation."""

    @property
    def Major(self) -> int:
        ...

    @property
    def Minor(self) -> int:
        ...

    @property
    def Build(self) -> int:
        ...

    @property
    def Revision(self) -> int:
        ...

    @property
    def MajorRevision(self) -> int:
        ...

    @property
    def MinorRevision(self) -> int:
        ...

    @overload
    def __init__(self, major: int, minor: int, build: int, revision: int) -> None:
        ...

    @overload
    def __init__(self, major: int, minor: int, build: int) -> None:
        ...

    @overload
    def __init__(self, major: int, minor: int) -> None:
        ...

    @overload
    def __init__(self, version: str) -> None:
        ...

    @overload
    def __init__(self) -> None:
        ...

    def Clone(self) -> System.Object:
        ...

    @overload
    def CompareTo(self, version: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: System.Version) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: System.Version) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    @overload
    def Parse(input: str) -> System.Version:
        ...

    @staticmethod
    @overload
    def Parse(input: System.ReadOnlySpan[str]) -> System.Version:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, fieldCount: int) -> str:
        ...

    @overload
    def ToString(self, format: str, formatProvider: System.IFormatProvider) -> str:
        ...

    @overload
    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @overload
    def TryFormat(self, destination: System.Span[str], fieldCount: int, charsWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @overload
    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(input: str, result: typing.Optional[System.Version]) -> typing.Union[bool, System.Version]:
        ...

    @staticmethod
    @overload
    def TryParse(input: System.ReadOnlySpan[str], result: typing.Optional[System.Version]) -> typing.Union[bool, System.Version]:
        ...


class PlatformID(System.Enum):
    """This class has no documentation."""

    Win32S = 0

    Win32Windows = 1

    Win32NT = 2

    WinCE = 3

    Unix = 4

    Xbox = 5

    MacOSX = 6

    Other = 7


class OperatingSystem(System.Object, System.Runtime.Serialization.ISerializable, System.ICloneable):
    """This class has no documentation."""

    @property
    def Platform(self) -> int:
        """This property contains the int value of a member of the System.PlatformID enum."""
        ...

    @property
    def ServicePack(self) -> str:
        ...

    @property
    def Version(self) -> System.Version:
        ...

    @property
    def VersionString(self) -> str:
        ...

    def __init__(self, platform: System.PlatformID, version: System.Version) -> None:
        ...

    def Clone(self) -> System.Object:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    @staticmethod
    def IsAndroid() -> bool:
        """Indicates whether the current application is running on Android."""
        ...

    @staticmethod
    def IsAndroidVersionAtLeast(major: int, minor: int = 0, build: int = 0, revision: int = 0) -> bool:
        ...

    @staticmethod
    def IsBrowser() -> bool:
        """Indicates whether the current application is running as WASM in a Browser."""
        ...

    @staticmethod
    def IsFreeBSD() -> bool:
        ...

    @staticmethod
    def IsFreeBSDVersionAtLeast(major: int, minor: int = 0, build: int = 0, revision: int = 0) -> bool:
        ...

    @staticmethod
    def IsIOS() -> bool:
        """Indicates whether the current application is running on iOS or MacCatalyst."""
        ...

    @staticmethod
    def IsIOSVersionAtLeast(major: int, minor: int = 0, build: int = 0) -> bool:
        ...

    @staticmethod
    def IsLinux() -> bool:
        ...

    @staticmethod
    def IsMacCatalyst() -> bool:
        """Indicates whether the current application is running on Mac Catalyst."""
        ...

    @staticmethod
    def IsMacCatalystVersionAtLeast(major: int, minor: int = 0, build: int = 0) -> bool:
        ...

    @staticmethod
    def IsMacOS() -> bool:
        """Indicates whether the current application is running on macOS."""
        ...

    @staticmethod
    def IsMacOSVersionAtLeast(major: int, minor: int = 0, build: int = 0) -> bool:
        ...

    @staticmethod
    def IsOSPlatform(platform: str) -> bool:
        """
        Indicates whether the current application is running on the specified platform.
        
        :param platform: Case-insensitive platform name. Examples: Browser, Linux, FreeBSD, Android, iOS, macOS, tvOS, watchOS, Windows.
        """
        ...

    @staticmethod
    def IsOSPlatformVersionAtLeast(platform: str, major: int, minor: int = 0, build: int = 0, revision: int = 0) -> bool:
        """
        Check for the OS with a >= version comparison. Used to guard APIs that were added in the given OS release.
        
        :param platform: Case-insensitive platform name. Examples: Browser, Linux, FreeBSD, Android, iOS, macOS, tvOS, watchOS, Windows.
        :param major: Major OS version number.
        :param minor: Minor OS version number (optional).
        :param build: Build OS version number (optional).
        :param revision: Revision OS version number (optional).
        """
        ...

    @staticmethod
    def IsTvOS() -> bool:
        """Indicates whether the current application is running on tvOS."""
        ...

    @staticmethod
    def IsTvOSVersionAtLeast(major: int, minor: int = 0, build: int = 0) -> bool:
        ...

    @staticmethod
    def IsWatchOS() -> bool:
        """Indicates whether the current application is running on watchOS."""
        ...

    @staticmethod
    def IsWatchOSVersionAtLeast(major: int, minor: int = 0, build: int = 0) -> bool:
        ...

    @staticmethod
    def IsWindows() -> bool:
        """Indicates whether the current application is running on Windows."""
        ...

    @staticmethod
    def IsWindowsVersionAtLeast(major: int, minor: int = 0, build: int = 0, revision: int = 0) -> bool:
        ...

    def ToString(self) -> str:
        ...


class EnvironmentVariableTarget(System.Enum):
    """This class has no documentation."""

    Process = 0

    User = 1

    Machine = 2


class Environment(System.Object):
    """This class has no documentation."""

    class SpecialFolder(System.Enum):
        """This class has no documentation."""

        ApplicationData = ...

        CommonApplicationData = ...

        LocalApplicationData = ...

        Cookies = ...

        Desktop = ...

        Favorites = ...

        History = ...

        InternetCache = ...

        Programs = ...

        MyComputer = ...

        MyMusic = ...

        MyPictures = ...

        MyVideos = ...

        Recent = ...

        SendTo = ...

        StartMenu = ...

        Startup = ...

        System = ...

        Templates = ...

        DesktopDirectory = ...

        Personal = ...

        MyDocuments = ...

        ProgramFiles = ...

        CommonProgramFiles = ...

        AdminTools = ...

        CDBurning = ...

        CommonAdminTools = ...

        CommonDocuments = ...

        CommonMusic = ...

        CommonOemLinks = ...

        CommonPictures = ...

        CommonStartMenu = ...

        CommonPrograms = ...

        CommonStartup = ...

        CommonDesktopDirectory = ...

        CommonTemplates = ...

        CommonVideos = ...

        Fonts = ...

        NetworkShortcuts = ...

        PrinterShortcuts = ...

        UserProfile = ...

        CommonProgramFilesX86 = ...

        ProgramFilesX86 = ...

        Resources = ...

        LocalizedResources = ...

        SystemX86 = ...

        Windows = ...

    class SpecialFolderOption(System.Enum):
        """This class has no documentation."""

        # Cannot convert to Python: None = 0

        Create = ...

        DoNotVerify = ...

    NewLineConst: str = "\\r\\n"

    MachineName: str

    SystemDirectory: str

    UserInteractive: bool

    WorkingSet: int

    IsWindows8OrAbove: bool

    UserName: str

    UserDomainName: str

    ProcessorCount: int

    IsSingleProcessor: bool
    """Gets whether the current machine has only a single processor."""

    IsPrivilegedProcess: bool
    """Gets whether the current process is authorized to perform security-relevant functions."""

    HasShutdownStarted: bool

    CommandLine: str

    CurrentDirectory: str

    ProcessId: int
    """Gets the unique identifier for the current process."""

    ProcessPath: str
    """Returns the path of the executable that started the currently executing process. Returns null when the path is not available."""

    Is64BitProcess: bool

    Is64BitOperatingSystem: bool

    NewLine: str

    OSVersion: System.OperatingSystem

    Version: System.Version

    StackTrace: str

    SystemPageSize: int

    NewLineConst: str = "\\n"

    CurrentManagedThreadId: int

    ExitCode: int

    TickCount: int

    TickCount64: int

    @staticmethod
    def Exit(exitCode: int) -> None:
        ...

    @staticmethod
    def ExpandEnvironmentVariables(name: str) -> str:
        ...

    @staticmethod
    @overload
    def FailFast(message: str) -> None:
        ...

    @staticmethod
    @overload
    def FailFast(message: str, exception: System.Exception) -> None:
        ...

    @staticmethod
    def GetCommandLineArgs() -> typing.List[str]:
        ...

    @staticmethod
    @overload
    def GetEnvironmentVariable(variable: str) -> str:
        ...

    @staticmethod
    @overload
    def GetEnvironmentVariable(variable: str, target: System.EnvironmentVariableTarget) -> str:
        ...

    @staticmethod
    @overload
    def GetEnvironmentVariables() -> System.Collections.IDictionary:
        ...

    @staticmethod
    @overload
    def GetEnvironmentVariables() -> System.Collections.IDictionary:
        ...

    @staticmethod
    @overload
    def GetEnvironmentVariables(target: System.EnvironmentVariableTarget) -> System.Collections.IDictionary:
        ...

    @staticmethod
    @overload
    def GetFolderPath(folder: System.Environment.SpecialFolder) -> str:
        ...

    @staticmethod
    @overload
    def GetFolderPath(folder: System.Environment.SpecialFolder, option: System.Environment.SpecialFolderOption) -> str:
        ...

    @staticmethod
    @overload
    def GetLogicalDrives() -> typing.List[str]:
        ...

    @staticmethod
    @overload
    def GetLogicalDrives() -> typing.List[str]:
        ...

    @staticmethod
    @overload
    def GetLogicalDrives() -> typing.List[str]:
        ...

    @staticmethod
    @overload
    def SetEnvironmentVariable(variable: str, value: str) -> None:
        ...

    @staticmethod
    @overload
    def SetEnvironmentVariable(variable: str, value: str, target: System.EnvironmentVariableTarget) -> None:
        ...

    @staticmethod
    def SetEnvironmentVariableFromRegistry(variable: str, value: str, fromMachine: bool) -> None:
        ...


class Activator(System.Object):
    """Activator contains the Activation (CreateInstance/New) methods for late bound support."""

    @staticmethod
    @overload
    def CreateInstance(type: typing.Type, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo) -> System.Object:
        ...

    @staticmethod
    @overload
    def CreateInstance(type: typing.Type, *args: typing.Any) -> System.Object:
        ...

    @staticmethod
    @overload
    def CreateInstance(type: typing.Type, args: typing.List[System.Object], activationAttributes: typing.List[System.Object]) -> System.Object:
        ...

    @staticmethod
    @overload
    def CreateInstance(type: typing.Type) -> System.Object:
        ...

    @staticmethod
    @overload
    def CreateInstance(type: typing.Type, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Object:
        ...

    @staticmethod
    @overload
    def CreateInstance(assemblyName: str, typeName: str) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @staticmethod
    @overload
    def CreateInstance(assemblyName: str, typeName: str, ignoreCase: bool, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @staticmethod
    @overload
    def CreateInstance(assemblyName: str, typeName: str, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @staticmethod
    @overload
    def CreateInstance(type: typing.Type, nonPublic: bool) -> System.Object:
        ...

    @staticmethod
    @overload
    def CreateInstance() -> System_Activator_CreateInstance_T:
        ...

    @staticmethod
    @overload
    def CreateInstanceFrom(assemblyFile: str, typeName: str) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @staticmethod
    @overload
    def CreateInstanceFrom(assemblyFile: str, typeName: str, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @staticmethod
    @overload
    def CreateInstanceFrom(assemblyFile: str, typeName: str, ignoreCase: bool, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...


class DateTimeOffset(System.IComparable[System_DateTimeOffset], System.ISpanFormattable, System.IEquatable[System_DateTimeOffset], System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.ISpanParsable[System_DateTimeOffset]):
    """This class has no documentation."""

    MaxOffset: int = ...

    MinOffset: int = ...

    UnixMinSeconds: int = ...

    UnixMaxSeconds: int = ...

    MinValue: System.DateTimeOffset = ...

    MaxValue: System.DateTimeOffset = ...

    UnixEpoch: System.DateTimeOffset = ...

    UtcNow: System.DateTimeOffset

    @property
    def DateTime(self) -> datetime.datetime:
        ...

    @property
    def UtcDateTime(self) -> datetime.datetime:
        ...

    @property
    def LocalDateTime(self) -> datetime.datetime:
        ...

    @property
    def Date(self) -> datetime.datetime:
        ...

    @property
    def Day(self) -> int:
        ...

    @property
    def DayOfWeek(self) -> int:
        """This property contains the int value of a member of the System.DayOfWeek enum."""
        ...

    @property
    def DayOfYear(self) -> int:
        ...

    @property
    def Hour(self) -> int:
        ...

    @property
    def Millisecond(self) -> int:
        ...

    @property
    def Microsecond(self) -> int:
        """Gets the microsecond component of the time represented by the current DateTimeOffset object."""
        ...

    @property
    def Nanosecond(self) -> int:
        """Gets the nanosecond component of the time represented by the current DateTimeOffset object."""
        ...

    @property
    def Minute(self) -> int:
        ...

    @property
    def Month(self) -> int:
        ...

    @property
    def Offset(self) -> datetime.timedelta:
        ...

    @property
    def Second(self) -> int:
        ...

    @property
    def Ticks(self) -> int:
        ...

    @property
    def UtcTicks(self) -> int:
        ...

    @property
    def TimeOfDay(self) -> datetime.timedelta:
        ...

    @property
    def Year(self) -> int:
        ...

    Now: System.DateTimeOffset

    @overload
    def __init__(self, ticks: int, offset: datetime.timedelta) -> None:
        ...

    @overload
    def __init__(self, dateTime: typing.Union[datetime.datetime, datetime.date]) -> None:
        ...

    @overload
    def __init__(self, dateTime: typing.Union[datetime.datetime, datetime.date], offset: datetime.timedelta) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, offset: datetime.timedelta) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, offset: datetime.timedelta) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: System.Globalization.Calendar, offset: datetime.timedelta) -> None:
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, offset: datetime.timedelta) -> None:
        """
        Initializes a new instance of the DateTimeOffset structure using the
        specified , , , , ,
        , ,  and .
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param microsecond: The microseconds (0 through 999).
        :param offset: The time's offset from Coordinated Universal Time (UTC).
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: System.Globalization.Calendar, offset: datetime.timedelta) -> None:
        """
        Initializes a new instance of the DateTimeOffset structure using the
        specified , , , , ,
        , ,  and .
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The milliseconds (0 through 999).
        :param microsecond: The microseconds (0 through 999).
        :param calendar: The calendar that is used to interpret , , and .
        :param offset: The time's offset from Coordinated Universal Time (UTC).
        """
        ...

    def Add(self, timeSpan: datetime.timedelta) -> System.DateTimeOffset:
        ...

    def AddDays(self, days: float) -> System.DateTimeOffset:
        ...

    def AddHours(self, hours: float) -> System.DateTimeOffset:
        ...

    def AddMicroseconds(self, microseconds: float) -> System.DateTimeOffset:
        """
        Returns a new DateTimeOffset object that adds a specified number of microseconds to the value of this instance.
        
        :param microseconds: A number of whole and fractional microseconds. The number can be negative or positive.
        :returns: An object whose value is the sum of the date and time represented by the current DateTimeOffset object and the number of whole microseconds represented by .
        """
        ...

    def AddMilliseconds(self, milliseconds: float) -> System.DateTimeOffset:
        ...

    def AddMinutes(self, minutes: float) -> System.DateTimeOffset:
        ...

    def AddMonths(self, months: int) -> System.DateTimeOffset:
        ...

    def AddSeconds(self, seconds: float) -> System.DateTimeOffset:
        ...

    def AddTicks(self, ticks: int) -> System.DateTimeOffset:
        ...

    def AddYears(self, years: int) -> System.DateTimeOffset:
        ...

    @staticmethod
    def Compare(first: System.DateTimeOffset, second: System.DateTimeOffset) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: System.DateTimeOffset) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: System.DateTimeOffset) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(first: System.DateTimeOffset, second: System.DateTimeOffset) -> bool:
        ...

    def EqualsExact(self, other: System.DateTimeOffset) -> bool:
        ...

    @staticmethod
    def FromFileTime(fileTime: int) -> System.DateTimeOffset:
        ...

    @staticmethod
    def FromUnixTimeMilliseconds(milliseconds: int) -> System.DateTimeOffset:
        ...

    @staticmethod
    def FromUnixTimeSeconds(seconds: int) -> System.DateTimeOffset:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def OnDeserialization(self, sender: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Parse(input: str) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def Parse(input: str, formatProvider: System.IFormatProvider) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def Parse(input: str, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def Parse(input: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider = None, styles: System.Globalization.DateTimeStyles = ...) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, format: str, formatProvider: System.IFormatProvider) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, format: str, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def ParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles = ...) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) -> System.DateTimeOffset:
        ...

    @staticmethod
    @overload
    def ParseExact(input: System.ReadOnlySpan[str], formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles = ...) -> System.DateTimeOffset:
        ...

    @overload
    def Subtract(self, value: System.DateTimeOffset) -> datetime.timedelta:
        ...

    @overload
    def Subtract(self, value: datetime.timedelta) -> System.DateTimeOffset:
        ...

    def ToFileTime(self) -> int:
        ...

    def ToLocalTime(self) -> System.DateTimeOffset:
        ...

    def ToOffset(self, offset: datetime.timedelta) -> System.DateTimeOffset:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, formatProvider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, formatProvider: System.IFormatProvider) -> str:
        ...

    def ToUniversalTime(self) -> System.DateTimeOffset:
        ...

    def ToUnixTimeMilliseconds(self) -> int:
        ...

    def ToUnixTimeSeconds(self) -> int:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., formatProvider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(input: str, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParse(input: System.ReadOnlySpan[str], result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParse(input: str, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParse(input: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, format: str, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateTimeOffset]) -> typing.Union[bool, System.DateTimeOffset]:
        ...


class DayOfWeek(System.Enum):
    """This class has no documentation."""

    Sunday = 0

    Monday = 1

    Tuesday = 2

    Wednesday = 3

    Thursday = 4

    Friday = 5

    Saturday = 6


class TimeZoneInfo(System.Object, System.IEquatable[System_TimeZoneInfo], System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback):
    """This class has no documentation."""

    class AdjustmentRule(System.Object, System.IEquatable[System_TimeZoneInfo_AdjustmentRule], System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback):
        """This class has no documentation."""

        @property
        def DateStart(self) -> datetime.datetime:
            ...

        @property
        def DateEnd(self) -> datetime.datetime:
            ...

        @property
        def DaylightDelta(self) -> datetime.timedelta:
            ...

        @property
        def DaylightTransitionStart(self) -> System.TimeZoneInfo.TransitionTime:
            ...

        @property
        def DaylightTransitionEnd(self) -> System.TimeZoneInfo.TransitionTime:
            ...

        @property
        def BaseUtcOffsetDelta(self) -> datetime.timedelta:
            """Gets the time difference with the base UTC offset for the time zone during the adjustment-rule period."""
            ...

        @property
        def NoDaylightTransitions(self) -> bool:
            """
            Gets a value indicating that this AdjustmentRule fixes the time zone offset
            from DateStart to DateEnd without any daylight transitions in between.
            """
            ...

        @property
        def HasDaylightSaving(self) -> bool:
            ...

        @staticmethod
        @overload
        def CreateAdjustmentRule(dateStart: typing.Union[datetime.datetime, datetime.date], dateEnd: typing.Union[datetime.datetime, datetime.date], daylightDelta: datetime.timedelta, daylightTransitionStart: System.TimeZoneInfo.TransitionTime, daylightTransitionEnd: System.TimeZoneInfo.TransitionTime, baseUtcOffsetDelta: datetime.timedelta) -> System.TimeZoneInfo.AdjustmentRule:
            """
            Creates a new adjustment rule for a particular time zone.
            
            :param dateStart: The effective date of the adjustment rule. If the value is DateTime.MinValue.Date, this is the first adjustment rule in effect for a time zone.
            :param dateEnd: The last date that the adjustment rule is in force. If the value is DateTime.MaxValue.Date, the adjustment rule has no end date.
            :param daylightDelta: The time change that results from the adjustment. This value is added to the time zone's System.TimeZoneInfo.BaseUtcOffset and System.TimeZoneInfo.BaseUtcOffsetDelta properties to obtain the correct daylight offset from Coordinated Universal Time (UTC). This value can range from -14 to 14.
            :param daylightTransitionStart: The start of daylight saving time.
            :param daylightTransitionEnd: The end of daylight saving time.
            :param baseUtcOffsetDelta: The time difference with the base UTC offset for the time zone during the adjustment-rule period.
            :returns: The new adjustment rule.
            """
            ...

        @staticmethod
        @overload
        def CreateAdjustmentRule(dateStart: typing.Union[datetime.datetime, datetime.date], dateEnd: typing.Union[datetime.datetime, datetime.date], daylightDelta: datetime.timedelta, daylightTransitionStart: System.TimeZoneInfo.TransitionTime, daylightTransitionEnd: System.TimeZoneInfo.TransitionTime) -> System.TimeZoneInfo.AdjustmentRule:
            ...

        @overload
        def Equals(self, other: System.TimeZoneInfo.AdjustmentRule) -> bool:
            ...

        @overload
        def Equals(self, obj: typing.Any) -> bool:
            """
            Indicates whether the current instance is equal to another instance.
            
            :param obj: An instance to compare with this instance.
            :returns: true if the current instance is equal to the other instance; otherwise, false.
            """
            ...

        def GetHashCode(self) -> int:
            ...

        def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
            ...

        def OnDeserialization(self, sender: typing.Any) -> None:
            ...

    class TransitionTime(System.IEquatable[System_TimeZoneInfo_TransitionTime], System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback):
        """This class has no documentation."""

        @property
        def TimeOfDay(self) -> datetime.datetime:
            ...

        @property
        def Month(self) -> int:
            ...

        @property
        def Week(self) -> int:
            ...

        @property
        def Day(self) -> int:
            ...

        @property
        def DayOfWeek(self) -> int:
            """This property contains the int value of a member of the System.DayOfWeek enum."""
            ...

        @property
        def IsFixedDateRule(self) -> bool:
            ...

        @staticmethod
        def CreateFixedDateRule(timeOfDay: typing.Union[datetime.datetime, datetime.date], month: int, day: int) -> System.TimeZoneInfo.TransitionTime:
            ...

        @staticmethod
        def CreateFloatingDateRule(timeOfDay: typing.Union[datetime.datetime, datetime.date], month: int, week: int, dayOfWeek: System.DayOfWeek) -> System.TimeZoneInfo.TransitionTime:
            ...

        @overload
        def Equals(self, obj: typing.Any) -> bool:
            ...

        @overload
        def Equals(self, other: System.TimeZoneInfo.TransitionTime) -> bool:
            ...

        def GetHashCode(self) -> int:
            ...

        def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
            ...

        def OnDeserialization(self, sender: typing.Any) -> None:
            ...

    @property
    def Id(self) -> str:
        ...

    @property
    def HasIanaId(self) -> bool:
        """Returns true if this TimeZoneInfo object has an IANA ID."""
        ...

    @property
    def DisplayName(self) -> str:
        ...

    @property
    def StandardName(self) -> str:
        ...

    @property
    def DaylightName(self) -> str:
        ...

    @property
    def BaseUtcOffset(self) -> datetime.timedelta:
        ...

    @property
    def SupportsDaylightSavingTime(self) -> bool:
        ...

    Local: System.TimeZoneInfo
    """
    Returns a TimeZoneInfo instance that represents the local time on the machine.
    Accessing this property may throw InvalidTimeZoneException or COMException
    if the machine is in an unstable or corrupt state.
    """

    Utc: System.TimeZoneInfo
    """Returns a TimeZoneInfo instance that represents Universal Coordinated Time (UTC)"""

    @staticmethod
    def ClearCachedData() -> None:
        """Clears data from static members."""
        ...

    @staticmethod
    @overload
    def ConvertTime(dateTimeOffset: System.DateTimeOffset, destinationTimeZone: System.TimeZoneInfo) -> System.DateTimeOffset:
        """Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone"""
        ...

    @staticmethod
    @overload
    def ConvertTime(dateTime: typing.Union[datetime.datetime, datetime.date], destinationTimeZone: System.TimeZoneInfo) -> datetime.datetime:
        """Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone"""
        ...

    @staticmethod
    @overload
    def ConvertTime(dateTime: typing.Union[datetime.datetime, datetime.date], sourceTimeZone: System.TimeZoneInfo, destinationTimeZone: System.TimeZoneInfo) -> datetime.datetime:
        """Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone"""
        ...

    @staticmethod
    @overload
    def ConvertTimeBySystemTimeZoneId(dateTimeOffset: System.DateTimeOffset, destinationTimeZoneId: str) -> System.DateTimeOffset:
        """Converts the value of a DateTime object from sourceTimeZone to destinationTimeZone."""
        ...

    @staticmethod
    @overload
    def ConvertTimeBySystemTimeZoneId(dateTime: typing.Union[datetime.datetime, datetime.date], destinationTimeZoneId: str) -> datetime.datetime:
        """Converts the value of a DateTime object from sourceTimeZone to destinationTimeZone."""
        ...

    @staticmethod
    @overload
    def ConvertTimeBySystemTimeZoneId(dateTime: typing.Union[datetime.datetime, datetime.date], sourceTimeZoneId: str, destinationTimeZoneId: str) -> datetime.datetime:
        """Converts the value of a DateTime object from sourceTimeZone to destinationTimeZone."""
        ...

    @staticmethod
    def ConvertTimeFromUtc(dateTime: typing.Union[datetime.datetime, datetime.date], destinationTimeZone: System.TimeZoneInfo) -> datetime.datetime:
        """Converts the value of a DateTime object from Coordinated Universal Time (UTC) to the destinationTimeZone."""
        ...

    @staticmethod
    @overload
    def ConvertTimeToUtc(dateTime: typing.Union[datetime.datetime, datetime.date]) -> datetime.datetime:
        """Converts the value of a DateTime object to Coordinated Universal Time (UTC)."""
        ...

    @staticmethod
    @overload
    def ConvertTimeToUtc(dateTime: typing.Union[datetime.datetime, datetime.date], sourceTimeZone: System.TimeZoneInfo) -> datetime.datetime:
        """Converts the value of a DateTime object to Coordinated Universal Time (UTC)."""
        ...

    @staticmethod
    @overload
    def CreateCustomTimeZone(id: str, baseUtcOffset: datetime.timedelta, displayName: str, standardDisplayName: str) -> System.TimeZoneInfo:
        """Returns a simple TimeZoneInfo instance that does not support Daylight Saving Time."""
        ...

    @staticmethod
    @overload
    def CreateCustomTimeZone(id: str, baseUtcOffset: datetime.timedelta, displayName: str, standardDisplayName: str, daylightDisplayName: str, adjustmentRules: typing.List[System.TimeZoneInfo.AdjustmentRule]) -> System.TimeZoneInfo:
        """Returns a TimeZoneInfo instance that may support Daylight Saving Time."""
        ...

    @staticmethod
    @overload
    def CreateCustomTimeZone(id: str, baseUtcOffset: datetime.timedelta, displayName: str, standardDisplayName: str, daylightDisplayName: str, adjustmentRules: typing.List[System.TimeZoneInfo.AdjustmentRule], disableDaylightSavingTime: bool) -> System.TimeZoneInfo:
        """Returns a TimeZoneInfo instance that may support Daylight Saving Time."""
        ...

    @overload
    def Equals(self, other: System.TimeZoneInfo) -> bool:
        """
        Returns value equality. Equals does not compare any localizable
        String objects (DisplayName, StandardName, DaylightName).
        """
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @staticmethod
    @overload
    def FindSystemTimeZoneById(id: str) -> System.TimeZoneInfo:
        """
        Helper function for retrieving a TimeZoneInfo object by time_zone_name.
        This function wraps the logic necessary to keep the private
        SystemTimeZones cache in working order
        
        This function will either return a valid TimeZoneInfo instance or
        it will throw 'InvalidTimeZoneException' / 'TimeZoneNotFoundException'.
        """
        ...

    @staticmethod
    @overload
    def FindSystemTimeZoneById(id: str) -> System.TimeZoneInfo:
        """
        Helper function for retrieving a TimeZoneInfo object by time_zone_name.
        This function wraps the logic necessary to keep the private
        SystemTimeZones cache in working order
        
        This function will either return a valid TimeZoneInfo instance or
        it will throw 'InvalidTimeZoneException' / 'TimeZoneNotFoundException'.
        """
        ...

    @staticmethod
    def FromSerializedString(source: str) -> System.TimeZoneInfo:
        ...

    @overload
    def GetAdjustmentRules(self) -> typing.List[System.TimeZoneInfo.AdjustmentRule]:
        """Returns a cloned array of AdjustmentRule objects"""
        ...

    @overload
    def GetAdjustmentRules(self) -> typing.List[System.TimeZoneInfo.AdjustmentRule]:
        """Returns a cloned array of AdjustmentRule objects"""
        ...

    @overload
    def GetAmbiguousTimeOffsets(self, dateTimeOffset: System.DateTimeOffset) -> typing.List[datetime.timedelta]:
        """
        Returns an array of TimeSpan objects representing all of
        the possible UTC offset values for this ambiguous time.
        """
        ...

    @overload
    def GetAmbiguousTimeOffsets(self, dateTime: typing.Union[datetime.datetime, datetime.date]) -> typing.List[datetime.timedelta]:
        """
        Returns an array of TimeSpan objects representing all of
        possible UTC offset values for this ambiguous time.
        """
        ...

    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    @staticmethod
    def GetSystemTimeZones() -> System.Collections.ObjectModel.ReadOnlyCollection[System.TimeZoneInfo]:
        """
        Returns a ReadOnlyCollection{TimeZoneInfo} containing all valid TimeZone's
        from the local machine. The entries in the collection are sorted by
        DisplayName.
        This method does *not* throw TimeZoneNotFoundException or InvalidTimeZoneException.
        """
        ...

    @overload
    def GetUtcOffset(self, dateTimeOffset: System.DateTimeOffset) -> datetime.timedelta:
        """Returns the Universal Coordinated Time (UTC) Offset for the current TimeZoneInfo instance."""
        ...

    @overload
    def GetUtcOffset(self, dateTime: typing.Union[datetime.datetime, datetime.date]) -> datetime.timedelta:
        """Returns the Universal Coordinated Time (UTC) Offset for the current TimeZoneInfo instance."""
        ...

    def HasSameRules(self, other: System.TimeZoneInfo) -> bool:
        """Value equality on the "adjustmentRules" array"""
        ...

    @overload
    def IsAmbiguousTime(self, dateTimeOffset: System.DateTimeOffset) -> bool:
        """
        Returns true if the time is during the ambiguous time period
        for the current TimeZoneInfo instance.
        """
        ...

    @overload
    def IsAmbiguousTime(self, dateTime: typing.Union[datetime.datetime, datetime.date]) -> bool:
        """
        Returns true if the time is during the ambiguous time period
        for the current TimeZoneInfo instance.
        """
        ...

    @overload
    def IsDaylightSavingTime(self, dateTimeOffset: System.DateTimeOffset) -> bool:
        """Returns true if the time is during Daylight Saving time for the current TimeZoneInfo instance."""
        ...

    @overload
    def IsDaylightSavingTime(self, dateTime: typing.Union[datetime.datetime, datetime.date]) -> bool:
        """Returns true if the time is during Daylight Saving time for the current TimeZoneInfo instance."""
        ...

    def IsInvalidTime(self, dateTime: typing.Union[datetime.datetime, datetime.date]) -> bool:
        """Returns true when dateTime falls into a "hole in time"."""
        ...

    def OnDeserialization(self, sender: typing.Any) -> None:
        ...

    def ToSerializedString(self) -> str:
        ...

    def ToString(self) -> str:
        """Returns the DisplayName: "(GMT-08:00) Pacific Time (US & Canada); Tijuana\""""
        ...

    @staticmethod
    def TryConvertIanaIdToWindowsId(ianaId: str, windowsId: typing.Optional[str]) -> typing.Union[bool, str]:
        """
        Tries to convert an IANA time zone ID to a Windows ID.
        
        :param ianaId: The IANA time zone ID.
        :param windowsId: String object holding the Windows ID which resulted from the IANA ID conversion.
        :returns: True if the ID conversion succeeded, false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryConvertWindowsIdToIanaId(windowsId: str, ianaId: typing.Optional[str]) -> typing.Union[bool, str]:
        """
        Tries to convert a Windows time zone ID to an IANA ID.
        
        :param windowsId: The Windows time zone ID.
        :param ianaId: String object holding the IANA ID which resulted from the Windows ID conversion.
        :returns: True if the ID conversion succeeded, false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryConvertWindowsIdToIanaId(windowsId: str, region: str, ianaId: typing.Optional[str]) -> typing.Union[bool, str]:
        """
        Tries to convert a Windows time zone ID to an IANA ID.
        
        :param windowsId: The Windows time zone ID.
        :param region: The ISO 3166 code for the country/region.
        :param ianaId: String object holding the IANA ID which resulted from the Windows ID conversion.
        :returns: True if the ID conversion succeeded, false otherwise.
        """
        ...

    @staticmethod
    def TryPopulateTimeZoneDisplayNamesFromGlobalizationData(timeZoneId: str, baseUtcOffset: datetime.timedelta, standardDisplayName: str, daylightDisplayName: str, displayName: str) -> None:
        ...


class Int128(System.IBinaryInteger[System_Int128], System.IMinMaxValue[System_Int128], System.ISignedNumber[System_Int128]):
    """Represents a 128-bit signed integer."""

    Size: int = 16

    @property
    def Lower(self) -> int:
        ...

    @property
    def Upper(self) -> int:
        ...

    def __init__(self, upper: int, lower: int) -> None:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: System.Int128) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: System.Int128) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.Int128:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> System.Int128:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.Int128:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> System.Int128:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> System.Int128:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.Int128]) -> typing.Union[bool, System.Int128]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.Int128]) -> typing.Union[bool, System.Int128]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.Int128]) -> typing.Union[bool, System.Int128]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.Int128]) -> typing.Union[bool, System.Int128]:
        ...


class ArithmeticException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class NotFiniteNumberException(System.ArithmeticException):
    """This class has no documentation."""

    @property
    def OffendingNumber(self) -> float:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, offendingNumber: float) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, offendingNumber: float) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, message: str, offendingNumber: float, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...


class SByte(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.ISignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = ...

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    NegativeOne: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_SByte_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_SByte_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_SByte_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_SByte_System_Numerics_INumberBase<System_SByte>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class EventArgs(System.Object):
    """This class has no documentation."""

    Empty: System.EventArgs = ...

    def __init__(self) -> None:
        ...


class UnhandledExceptionEventArgs(System.EventArgs):
    """This class has no documentation."""

    @property
    def ExceptionObject(self) -> System.Object:
        ...

    @property
    def IsTerminating(self) -> bool:
        ...

    def __init__(self, exception: typing.Any, isTerminating: bool) -> None:
        ...


class AppContext(System.Object):
    """This class has no documentation."""

    BaseDirectory: str

    TargetFrameworkName: str

    UnhandledException: _EventContainer[typing.Callable[[System.Object, System.UnhandledExceptionEventArgs], None], None]

    FirstChanceException: _EventContainer[typing.Callable[[System.Object, System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs], None], None]

    ProcessExit: _EventContainer[typing.Callable[[System.Object, System.EventArgs], None], None]

    @staticmethod
    def GetData(name: str) -> System.Object:
        ...

    @staticmethod
    def SetData(name: str, data: typing.Any) -> None:
        """
        Sets the value of the named data element assigned to the current application domain.
        
        :param name: The name of the data element
        :param data: The value of
        """
        ...

    @staticmethod
    def SetSwitch(switchName: str, isEnabled: bool) -> None:
        """
        Assign a switch a value
        
        :param switchName: The name of the switch
        :param isEnabled: The value to assign
        """
        ...

    @staticmethod
    def TryGetSwitch(switchName: str, isEnabled: typing.Optional[bool]) -> typing.Union[bool, bool]:
        """
        Try to get the value of the switch.
        
        :param switchName: The name of the switch
        :param isEnabled: A variable where to place the value of the switch
        :returns: A return value of true represents that the switch was set and  contains the value of the switch.
        """
        ...


class MidpointRounding(System.Enum):
    """This class has no documentation."""

    ToEven = 0

    AwayFromZero = 1

    ToZero = 2

    ToNegativeInfinity = 3

    ToPositiveInfinity = 4


class MathF(System.Object):
    """This class has no documentation."""

    E: float = ...

    PI: float = ...

    Tau: float = ...

    @staticmethod
    def Abs(x: float) -> float:
        ...

    @staticmethod
    def Acos(x: float) -> float:
        ...

    @staticmethod
    def Acosh(x: float) -> float:
        ...

    @staticmethod
    def Asin(x: float) -> float:
        ...

    @staticmethod
    def Asinh(x: float) -> float:
        ...

    @staticmethod
    def Atan(x: float) -> float:
        ...

    @staticmethod
    def Atan2(y: float, x: float) -> float:
        ...

    @staticmethod
    def Atanh(x: float) -> float:
        ...

    @staticmethod
    def BitDecrement(x: float) -> float:
        ...

    @staticmethod
    def BitIncrement(x: float) -> float:
        ...

    @staticmethod
    def Cbrt(x: float) -> float:
        ...

    @staticmethod
    def Ceiling(x: float) -> float:
        ...

    @staticmethod
    def CopySign(x: float, y: float) -> float:
        ...

    @staticmethod
    def Cos(x: float) -> float:
        ...

    @staticmethod
    def Cosh(x: float) -> float:
        ...

    @staticmethod
    def Exp(x: float) -> float:
        ...

    @staticmethod
    def Floor(x: float) -> float:
        ...

    @staticmethod
    def FusedMultiplyAdd(x: float, y: float, z: float) -> float:
        ...

    @staticmethod
    def IEEERemainder(x: float, y: float) -> float:
        ...

    @staticmethod
    def ILogB(x: float) -> int:
        ...

    @staticmethod
    @overload
    def Log(x: float, y: float) -> float:
        ...

    @staticmethod
    @overload
    def Log(x: float) -> float:
        ...

    @staticmethod
    def Log10(x: float) -> float:
        ...

    @staticmethod
    def Log2(x: float) -> float:
        ...

    @staticmethod
    def Max(x: float, y: float) -> float:
        ...

    @staticmethod
    def MaxMagnitude(x: float, y: float) -> float:
        ...

    @staticmethod
    def Min(x: float, y: float) -> float:
        ...

    @staticmethod
    def MinMagnitude(x: float, y: float) -> float:
        ...

    @staticmethod
    def Pow(x: float, y: float) -> float:
        ...

    @staticmethod
    def ReciprocalEstimate(x: float) -> float:
        """
        Returns an estimate of the reciprocal of a specified number.
        
        :param x: The number whose reciprocal is to be estimated.
        :returns: An estimate of the reciprocal of .
        """
        ...

    @staticmethod
    def ReciprocalSqrtEstimate(x: float) -> float:
        """
        Returns an estimate of the reciprocal square root of a specified number.
        
        :param x: The number whose reciprocal square root is to be estimated.
        :returns: An estimate of the reciprocal square root .
        """
        ...

    @staticmethod
    @overload
    def Round(x: float) -> float:
        ...

    @staticmethod
    @overload
    def Round(x: float, digits: int) -> float:
        ...

    @staticmethod
    @overload
    def Round(x: float, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    @overload
    def Round(x: float, digits: int, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    def ScaleB(x: float, n: int) -> float:
        ...

    @staticmethod
    def Sign(x: float) -> int:
        ...

    @staticmethod
    def Sin(x: float) -> float:
        ...

    @staticmethod
    def SinCos(x: float) -> System.ValueTuple[float, float]:
        ...

    @staticmethod
    def Sinh(x: float) -> float:
        ...

    @staticmethod
    def Sqrt(x: float) -> float:
        ...

    @staticmethod
    def Tan(x: float) -> float:
        ...

    @staticmethod
    def Tanh(x: float) -> float:
        ...

    @staticmethod
    def Truncate(x: float) -> float:
        ...


class TimeZone(System.Object, metaclass=abc.ABCMeta):
    """System.TimeZone has been deprecated. Investigate the use of System.TimeZoneInfo instead."""

    CurrentTimeZone: System.TimeZone

    @property
    @abc.abstractmethod
    def StandardName(self) -> str:
        ...

    @property
    @abc.abstractmethod
    def DaylightName(self) -> str:
        ...

    def __init__(self) -> None:
        """This method is protected."""
        ...

    def GetDaylightChanges(self, year: int) -> System.Globalization.DaylightTime:
        ...

    def GetUtcOffset(self, time: typing.Union[datetime.datetime, datetime.date]) -> datetime.timedelta:
        ...

    @overload
    def IsDaylightSavingTime(self, time: typing.Union[datetime.datetime, datetime.date]) -> bool:
        ...

    @staticmethod
    @overload
    def IsDaylightSavingTime(time: typing.Union[datetime.datetime, datetime.date], daylightTimes: System.Globalization.DaylightTime) -> bool:
        ...

    def ToLocalTime(self, time: typing.Union[datetime.datetime, datetime.date]) -> datetime.datetime:
        ...

    def ToUniversalTime(self, time: typing.Union[datetime.datetime, datetime.date]) -> datetime.datetime:
        ...


class ApplicationException(System.Exception):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Random(System.Object):
    """
    Represents a pseudo-random number generator, which is an algorithm that produces a sequence of numbers
    that meet certain statistical requirements for randomness.
    """

    Shared: System.Random
    """Provides a thread-safe Random instance that may be used concurrently from any thread."""

    @overload
    def __init__(self) -> None:
        """Initializes a new instance of the Random class using a default seed value."""
        ...

    @overload
    def __init__(self, Seed: int) -> None:
        """
        Initializes a new instance of the Random class, using the specified seed value.
        
        :param Seed: A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.
        """
        ...

    @overload
    def Next(self) -> int:
        """
        Returns a non-negative random integer.
        
        :returns: A 32-bit signed integer that is greater than or equal to 0 and less than int.MaxValue.
        """
        ...

    @overload
    def Next(self, maxValue: int) -> int:
        """
        Returns a non-negative random integer that is less than the specified maximum.
        
        :param maxValue: The exclusive upper bound of the random number to be generated.  must be greater than or equal to 0.
        :returns: A 32-bit signed integer that is greater than or equal to 0, and less than ; that is, the range of return values ordinarily includes 0 but not . However, if  equals 0,  is returned.
        """
        ...

    @overload
    def Next(self, minValue: int, maxValue: int) -> int:
        """
        Returns a random integer that is within a specified range.
        
        :param minValue: The inclusive lower bound of the random number returned.
        :param maxValue: The exclusive upper bound of the random number returned.  must be greater than or equal to .
        :returns: A 32-bit signed integer greater than or equal to  and less than ; that is, the range of return values includes  but not . If minValue equals ,  is returned.
        """
        ...

    @overload
    def NextBytes(self, buffer: typing.List[int]) -> None:
        """
        Fills the elements of a specified array of bytes with random numbers.
        
        :param buffer: The array to be filled with random numbers.
        """
        ...

    @overload
    def NextBytes(self, buffer: System.Span[int]) -> None:
        """
        Fills the elements of a specified span of bytes with random numbers.
        
        :param buffer: The array to be filled with random numbers.
        """
        ...

    def NextDouble(self) -> float:
        """
        Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
        
        :returns: A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
        """
        ...

    @overload
    def NextInt64(self) -> int:
        """
        Returns a non-negative random integer.
        
        :returns: A 64-bit signed integer that is greater than or equal to 0 and less than long.MaxValue.
        """
        ...

    @overload
    def NextInt64(self, maxValue: int) -> int:
        """
        Returns a non-negative random integer that is less than the specified maximum.
        
        :param maxValue: The exclusive upper bound of the random number to be generated.  must be greater than or equal to 0.
        :returns: A 64-bit signed integer that is greater than or equal to 0, and less than ; that is, the range of return values ordinarily includes 0 but not . However, if  equals 0,  is returned.
        """
        ...

    @overload
    def NextInt64(self, minValue: int, maxValue: int) -> int:
        """
        Returns a random integer that is within a specified range.
        
        :param minValue: The inclusive lower bound of the random number returned.
        :param maxValue: The exclusive upper bound of the random number returned.  must be greater than or equal to .
        :returns: A 64-bit signed integer greater than or equal to  and less than ; that is, the range of return values includes  but not . If minValue equals ,  is returned.
        """
        ...

    def NextSingle(self) -> float:
        """
        Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
        
        :returns: A single-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
        """
        ...

    def Sample(self) -> float:
        """
        Returns a random floating-point number between 0.0 and 1.0.
        
        This method is protected.
        
        :returns: A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
        """
        ...


class MarshalByRefObject(System.Object, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def __init__(self) -> None:
        """This method is protected."""
        ...

    def GetLifetimeService(self) -> System.Object:
        """Obsoletions.RemotingApisMessage"""
        warnings.warn("Obsoletions.RemotingApisMessage", DeprecationWarning)

    def InitializeLifetimeService(self) -> System.Object:
        """Obsoletions.RemotingApisMessage"""
        warnings.warn("Obsoletions.RemotingApisMessage", DeprecationWarning)

    def MemberwiseClone(self, cloneIdentity: bool) -> System.MarshalByRefObject:
        """This method is protected."""
        ...


class ContextBoundObject(System.MarshalByRefObject, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def __init__(self) -> None:
        """This method is protected."""
        ...


class ContextMarshalException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Attribute(System.Object, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    @property
    def TypeId(self) -> System.Object:
        ...

    def __init__(self) -> None:
        """This method is protected."""
        ...

    def Equals(self, obj: typing.Any) -> bool:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.Assembly, attributeType: typing.Type) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.Assembly, attributeType: typing.Type, inherit: bool) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.MemberInfo, attributeType: typing.Type) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.MemberInfo, attributeType: typing.Type, inherit: bool) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.Module, attributeType: typing.Type) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.Module, attributeType: typing.Type, inherit: bool) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.ParameterInfo, attributeType: typing.Type) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttribute(element: System.Reflection.ParameterInfo, attributeType: typing.Type, inherit: bool) -> System.Attribute:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Assembly) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Assembly, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Assembly, attributeType: typing.Type) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Assembly, attributeType: typing.Type, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.MemberInfo) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.MemberInfo, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.MemberInfo, attributeType: typing.Type) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.MemberInfo, attributeType: typing.Type, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Module) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Module, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Module, attributeType: typing.Type) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.Module, attributeType: typing.Type, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.ParameterInfo) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.ParameterInfo, inherit: bool) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.ParameterInfo, attributeType: typing.Type) -> typing.List[System.Attribute]:
        ...

    @staticmethod
    @overload
    def GetCustomAttributes(element: System.Reflection.ParameterInfo, attributeType: typing.Type, inherit: bool) -> typing.List[System.Attribute]:
        ...

    def GetHashCode(self) -> int:
        ...

    def IsDefaultAttribute(self) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.Assembly, attributeType: typing.Type) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.Assembly, attributeType: typing.Type, inherit: bool) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.MemberInfo, attributeType: typing.Type) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.MemberInfo, attributeType: typing.Type, inherit: bool) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.Module, attributeType: typing.Type) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.Module, attributeType: typing.Type, inherit: bool) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.ParameterInfo, attributeType: typing.Type) -> bool:
        ...

    @staticmethod
    @overload
    def IsDefined(element: System.Reflection.ParameterInfo, attributeType: typing.Type, inherit: bool) -> bool:
        ...

    def Match(self, obj: typing.Any) -> bool:
        ...


class ContextStaticAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class IAsyncResult(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    @property
    @abc.abstractmethod
    def IsCompleted(self) -> bool:
        ...

    @property
    @abc.abstractmethod
    def AsyncWaitHandle(self) -> System.Threading.WaitHandle:
        ...

    @property
    @abc.abstractmethod
    def AsyncState(self) -> System.Object:
        ...

    @property
    @abc.abstractmethod
    def CompletedSynchronously(self) -> bool:
        ...


class StringSplitOptions(System.Enum):
    """This class has no documentation."""

    # Cannot convert to Python: None = 0
    """Do not transform the results. This is the default behavior."""

    RemoveEmptyEntries = 1
    """Remove empty (zero-length) substrings from the result."""

    TrimEntries = 2
    """Trim whitespace from each substring in the result."""


class CharEnumerator(System.Object, System.ICloneable):
    """This class has no documentation."""

    @property
    def Current(self) -> System.Object:
        ...

    def Clone(self) -> System.Object:
        ...

    def Dispose(self) -> None:
        ...

    def MoveNext(self) -> bool:
        ...

    def Reset(self) -> None:
        ...


class String(System.Object, System.IComparable[str], System.IConvertible, System.IEquatable[str], System.ICloneable, typing.Iterable[str]):
    """This class has no documentation."""

    MaxLength: int = ...
    """Maximum length allowed for a string."""

    Empty: str

    @property
    def Length(self) -> int:
        ...

    def __getitem__(self, index: int) -> str:
        ...

    @overload
    def __init__(self, value: typing.List[str]) -> None:
        ...

    @overload
    def __init__(self, value: typing.List[str], startIndex: int, length: int) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any, startIndex: int, length: int) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any, startIndex: int, length: int) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any, startIndex: int, length: int, enc: System.Text.Encoding) -> None:
        ...

    @overload
    def __init__(self, c: str, count: int) -> None:
        ...

    @overload
    def __init__(self, value: System.ReadOnlySpan[str]) -> None:
        ...

    def Clone(self) -> System.Object:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, strB: str) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, strB: str, ignoreCase: bool) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, strB: str, comparisonType: System.StringComparison) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, strB: str, culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, strB: str, ignoreCase: bool, culture: System.Globalization.CultureInfo) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, indexA: int, strB: str, indexB: int, length: int) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, indexA: int, strB: str, indexB: int, length: int, ignoreCase: bool) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, indexA: int, strB: str, indexB: int, length: int, ignoreCase: bool, culture: System.Globalization.CultureInfo) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, indexA: int, strB: str, indexB: int, length: int, culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions) -> int:
        ...

    @staticmethod
    @overload
    def Compare(strA: str, indexA: int, strB: str, indexB: int, length: int, comparisonType: System.StringComparison) -> int:
        ...

    @staticmethod
    @overload
    def CompareOrdinal(strA: str, strB: str) -> int:
        ...

    @staticmethod
    @overload
    def CompareOrdinal(strA: str, indexA: int, strB: str, indexB: int, length: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, strB: str) -> int:
        ...

    @staticmethod
    @overload
    def Concat(arg0: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Concat(arg0: typing.Any, arg1: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Concat(arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Concat(*args: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Concat(values: System.Collections.Generic.IEnumerable[System_String_Concat_T]) -> str:
        ...

    @staticmethod
    @overload
    def Concat(values: System.Collections.Generic.IEnumerable[str]) -> str:
        ...

    @staticmethod
    @overload
    def Concat(str0: str, str1: str) -> str:
        ...

    @staticmethod
    @overload
    def Concat(str0: str, str1: str, str2: str) -> str:
        ...

    @staticmethod
    @overload
    def Concat(str0: str, str1: str, str2: str, str3: str) -> str:
        ...

    @staticmethod
    @overload
    def Concat(str0: System.ReadOnlySpan[str], str1: System.ReadOnlySpan[str]) -> str:
        ...

    @staticmethod
    @overload
    def Concat(str0: System.ReadOnlySpan[str], str1: System.ReadOnlySpan[str], str2: System.ReadOnlySpan[str]) -> str:
        ...

    @staticmethod
    @overload
    def Concat(str0: System.ReadOnlySpan[str], str1: System.ReadOnlySpan[str], str2: System.ReadOnlySpan[str], str3: System.ReadOnlySpan[str]) -> str:
        ...

    @staticmethod
    @overload
    def Concat(*values: str) -> str:
        ...

    @overload
    def Contains(self, value: str) -> bool:
        ...

    @overload
    def Contains(self, value: str, comparisonType: System.StringComparison) -> bool:
        ...

    @overload
    def Contains(self, value: str) -> bool:
        ...

    @overload
    def Contains(self, value: str, comparisonType: System.StringComparison) -> bool:
        ...

    @staticmethod
    def Copy(str: str) -> str:
        """This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives."""
        warnings.warn("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.", DeprecationWarning)

    @overload
    def CopyTo(self, sourceIndex: int, destination: typing.List[str], destinationIndex: int, count: int) -> None:
        ...

    @overload
    def CopyTo(self, destination: System.Span[str]) -> None:
        """
        Copies the contents of this string into the destination span.
        
        :param destination: The span into which to copy this string's contents.
        """
        ...

    @staticmethod
    @overload
    def Create(length: int, state: System_String_Create_TState, action: typing.Callable[[System.Span[str], System_String_Create_TState], None]) -> str:
        ...

    @staticmethod
    @overload
    def Create(provider: System.IFormatProvider, handler: System.Runtime.CompilerServices.DefaultInterpolatedStringHandler) -> str:
        """
        Creates a new string by using the specified provider to control the formatting of the specified interpolated string.
        
        :param provider: An object that supplies culture-specific formatting information.
        :param handler: The interpolated string.
        :returns: The string that results for formatting the interpolated string using the specified format provider.
        """
        ...

    @staticmethod
    @overload
    def Create(provider: System.IFormatProvider, initialBuffer: System.Span[str], handler: System.Runtime.CompilerServices.DefaultInterpolatedStringHandler) -> str:
        """
        Creates a new string by using the specified provider to control the formatting of the specified interpolated string.
        
        :param provider: An object that supplies culture-specific formatting information.
        :param initialBuffer: The initial buffer that may be used as temporary space as part of the formatting operation. The contents of this buffer may be overwritten.
        :param handler: The interpolated string.
        :returns: The string that results for formatting the interpolated string using the specified format provider.
        """
        ...

    @overload
    def EndsWith(self, value: str) -> bool:
        ...

    @overload
    def EndsWith(self, value: str, comparisonType: System.StringComparison) -> bool:
        ...

    @overload
    def EndsWith(self, value: str, ignoreCase: bool, culture: System.Globalization.CultureInfo) -> bool:
        ...

    @overload
    def EndsWith(self, value: str) -> bool:
        ...

    def EnumerateRunes(self) -> System.Text.StringRuneEnumerator:
        """Returns an enumeration of Rune from this string."""
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, value: str) -> bool:
        ...

    @overload
    def Equals(self, value: str, comparisonType: System.StringComparison) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(a: str, b: str) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(a: str, b: str, comparisonType: System.StringComparison) -> bool:
        ...

    @staticmethod
    @overload
    def Format(format: str, arg0: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(format: str, arg0: typing.Any, arg1: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(format: str, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(format: str, *args: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(provider: System.IFormatProvider, format: str, arg0: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(provider: System.IFormatProvider, format: str, arg0: typing.Any, arg1: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(provider: System.IFormatProvider, format: str, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Format(provider: System.IFormatProvider, format: str, *args: typing.Any) -> str:
        ...

    @overload
    def GetEnumerator(self) -> System.CharEnumerator:
        ...

    @overload
    def GetEnumerator(self) -> System.Collections.Generic.IEnumerator[str]:
        ...

    @overload
    def GetEnumerator(self) -> System.Collections.IEnumerator:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparisonType: System.StringComparison) -> int:
        ...

    @staticmethod
    @overload
    def GetHashCode(value: System.ReadOnlySpan[str]) -> int:
        ...

    @staticmethod
    @overload
    def GetHashCode(value: System.ReadOnlySpan[str], comparisonType: System.StringComparison) -> int:
        ...

    def GetPinnableReference(self) -> typing.Any:
        """Returns a reference to the first element of the String. If the string is null, an access will throw a NullReferenceException."""
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @overload
    def IndexOf(self, value: str) -> int:
        ...

    @overload
    def IndexOf(self, value: str, startIndex: int) -> int:
        ...

    @overload
    def IndexOf(self, value: str, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def IndexOf(self, value: str, startIndex: int, count: int) -> int:
        ...

    @overload
    def IndexOf(self, value: str) -> int:
        ...

    @overload
    def IndexOf(self, value: str, startIndex: int) -> int:
        ...

    @overload
    def IndexOf(self, value: str, startIndex: int, count: int) -> int:
        ...

    @overload
    def IndexOf(self, value: str, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def IndexOf(self, value: str, startIndex: int, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def IndexOf(self, value: str, startIndex: int, count: int, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def IndexOfAny(self, anyOf: typing.List[str]) -> int:
        ...

    @overload
    def IndexOfAny(self, anyOf: typing.List[str], startIndex: int) -> int:
        ...

    @overload
    def IndexOfAny(self, anyOf: typing.List[str], startIndex: int, count: int) -> int:
        ...

    def Insert(self, startIndex: int, value: str) -> str:
        ...

    @staticmethod
    def Intern(str: str) -> str:
        ...

    @staticmethod
    def IsInterned(str: str) -> str:
        ...

    @overload
    def IsNormalized(self) -> bool:
        ...

    @overload
    def IsNormalized(self, normalizationForm: System.Text.NormalizationForm) -> bool:
        ...

    @staticmethod
    def IsNullOrEmpty(value: str) -> bool:
        ...

    @staticmethod
    def IsNullOrWhiteSpace(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def Join(separator: str, *value: str) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, *value: str) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, value: typing.List[str], startIndex: int, count: int) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, value: typing.List[str], startIndex: int, count: int) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, values: System.Collections.Generic.IEnumerable[str]) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, *values: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, *values: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, values: System.Collections.Generic.IEnumerable[System_String_Join_T]) -> str:
        ...

    @staticmethod
    @overload
    def Join(separator: str, values: System.Collections.Generic.IEnumerable[System_String_Join_T]) -> str:
        ...

    @overload
    def LastIndexOf(self, value: str) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, startIndex: int) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, startIndex: int, count: int) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, startIndex: int) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, startIndex: int, count: int) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, startIndex: int, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def LastIndexOf(self, value: str, startIndex: int, count: int, comparisonType: System.StringComparison) -> int:
        ...

    @overload
    def LastIndexOfAny(self, anyOf: typing.List[str]) -> int:
        ...

    @overload
    def LastIndexOfAny(self, anyOf: typing.List[str], startIndex: int) -> int:
        ...

    @overload
    def LastIndexOfAny(self, anyOf: typing.List[str], startIndex: int, count: int) -> int:
        ...

    @overload
    def Normalize(self) -> str:
        ...

    @overload
    def Normalize(self, normalizationForm: System.Text.NormalizationForm) -> str:
        ...

    @overload
    def PadLeft(self, totalWidth: int) -> str:
        ...

    @overload
    def PadLeft(self, totalWidth: int, paddingChar: str) -> str:
        ...

    @overload
    def PadRight(self, totalWidth: int) -> str:
        ...

    @overload
    def PadRight(self, totalWidth: int, paddingChar: str) -> str:
        ...

    @overload
    def Remove(self, startIndex: int, count: int) -> str:
        ...

    @overload
    def Remove(self, startIndex: int) -> str:
        ...

    @overload
    def Replace(self, oldValue: str, newValue: str, ignoreCase: bool, culture: System.Globalization.CultureInfo) -> str:
        ...

    @overload
    def Replace(self, oldValue: str, newValue: str, comparisonType: System.StringComparison) -> str:
        ...

    @overload
    def Replace(self, oldChar: str, newChar: str) -> str:
        ...

    @overload
    def Replace(self, oldValue: str, newValue: str) -> str:
        ...

    @overload
    def ReplaceLineEndings(self) -> str:
        """
        Replaces all newline sequences in the current string with Environment.NewLine.
        
        :returns: A string whose contents match the current string, but with all newline sequences replaced with Environment.NewLine.
        """
        ...

    @overload
    def ReplaceLineEndings(self, replacementText: str) -> str:
        """
        Replaces all newline sequences in the current string with .
        
        :returns: A string whose contents match the current string, but with all newline sequences replaced with .
        """
        ...

    @overload
    def Split(self, separator: str, options: System.StringSplitOptions = ...) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: str, count: int, options: System.StringSplitOptions = ...) -> typing.List[str]:
        ...

    @overload
    def Split(self, *separator: str) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: typing.List[str], count: int) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: typing.List[str], options: System.StringSplitOptions) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: typing.List[str], count: int, options: System.StringSplitOptions) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: str, options: System.StringSplitOptions = ...) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: str, count: int, options: System.StringSplitOptions = ...) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: typing.List[str], options: System.StringSplitOptions) -> typing.List[str]:
        ...

    @overload
    def Split(self, separator: typing.List[str], count: int, options: System.StringSplitOptions) -> typing.List[str]:
        ...

    @overload
    def StartsWith(self, value: str) -> bool:
        ...

    @overload
    def StartsWith(self, value: str, comparisonType: System.StringComparison) -> bool:
        ...

    @overload
    def StartsWith(self, value: str, ignoreCase: bool, culture: System.Globalization.CultureInfo) -> bool:
        ...

    @overload
    def StartsWith(self, value: str) -> bool:
        ...

    @overload
    def Substring(self, startIndex: int) -> str:
        ...

    @overload
    def Substring(self, startIndex: int, length: int) -> str:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToCharArray(self) -> typing.List[str]:
        ...

    @overload
    def ToCharArray(self, startIndex: int, length: int) -> typing.List[str]:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @overload
    def ToLower(self) -> str:
        ...

    @overload
    def ToLower(self, culture: System.Globalization.CultureInfo) -> str:
        ...

    def ToLowerInvariant(self) -> str:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @overload
    def ToUpper(self) -> str:
        ...

    @overload
    def ToUpper(self, culture: System.Globalization.CultureInfo) -> str:
        ...

    def ToUpperInvariant(self) -> str:
        ...

    @overload
    def Trim(self) -> str:
        ...

    @overload
    def Trim(self, trimChar: str) -> str:
        ...

    @overload
    def Trim(self, *trimChars: str) -> str:
        ...

    @overload
    def TrimEnd(self) -> str:
        ...

    @overload
    def TrimEnd(self, trimChar: str) -> str:
        ...

    @overload
    def TrimEnd(self, *trimChars: str) -> str:
        ...

    @overload
    def TrimStart(self) -> str:
        ...

    @overload
    def TrimStart(self, trimChar: str) -> str:
        ...

    @overload
    def TrimStart(self, *trimChars: str) -> str:
        ...

    def TryCopyTo(self, destination: System.Span[str]) -> bool:
        """
        Copies the contents of this string into the destination span.
        
        :param destination: The span into which to copy this string's contents.
        :returns: true if the data was copied; false if the destination was too short to fit the contents of the string.
        """
        ...


class Guid(System.ISpanFormattable, System.IComparable[System_Guid], System.IEquatable[System_Guid], System.ISpanParsable[System_Guid]):
    """This class has no documentation."""

    Empty: System.Guid

    @overload
    def __init__(self, b: typing.List[int]) -> None:
        ...

    @overload
    def __init__(self, b: System.ReadOnlySpan[int]) -> None:
        ...

    @overload
    def __init__(self, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int, j: int, k: int) -> None:
        ...

    @overload
    def __init__(self, a: int, b: int, c: int, d: typing.List[int]) -> None:
        ...

    @overload
    def __init__(self, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int, j: int, k: int) -> None:
        ...

    @overload
    def __init__(self, g: str) -> None:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: System.Guid) -> int:
        ...

    @overload
    def Equals(self, o: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, g: System.Guid) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    @overload
    def NewGuid() -> System.Guid:
        ...

    @staticmethod
    @overload
    def NewGuid() -> System.Guid:
        ...

    @staticmethod
    @overload
    def Parse(input: str) -> System.Guid:
        ...

    @staticmethod
    @overload
    def Parse(input: System.ReadOnlySpan[str]) -> System.Guid:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.Guid:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System.Guid:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, format: str) -> System.Guid:
        ...

    @staticmethod
    @overload
    def ParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str]) -> System.Guid:
        ...

    def ToByteArray(self) -> typing.List[int]:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ...) -> typing.Union[bool, int]:
        ...

    @overload
    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(input: str, result: typing.Optional[System.Guid]) -> typing.Union[bool, System.Guid]:
        ...

    @staticmethod
    @overload
    def TryParse(input: System.ReadOnlySpan[str], result: typing.Optional[System.Guid]) -> typing.Union[bool, System.Guid]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System.Guid]) -> typing.Union[bool, System.Guid]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System.Guid]) -> typing.Union[bool, System.Guid]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, format: str, result: typing.Optional[System.Guid]) -> typing.Union[bool, System.Guid]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], result: typing.Optional[System.Guid]) -> typing.Union[bool, System.Guid]:
        ...

    def TryWriteBytes(self, destination: System.Span[int]) -> bool:
        ...


class ExecutionEngineException(System.SystemException):
    """ExecutionEngineException previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...


class MethodAccessException(System.MemberAccessException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Byte(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.IUnsignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = 0

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_Byte_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_Byte_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_Byte_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_Byte_System_Numerics_INumberBase<System_Byte>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class DataMisalignedException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...


class AggregateException(System.Exception):
    """Represents one or more errors that occur during application execution."""

    @property
    def InnerExceptions(self) -> System.Collections.ObjectModel.ReadOnlyCollection[System.Exception]:
        """
        Gets a read-only collection of the System.Exception instances that caused the
        current exception.
        """
        ...

    @property
    def Message(self) -> str:
        """Gets a message that describes the exception."""
        ...

    @property
    def InnerExceptionCount(self) -> int:
        """
        This helper property is used by the DebuggerDisplay.
        
        Note that we don't want to remove this property and change the debugger display to {InnerExceptions.Count}
        because DebuggerDisplay should be a single property access or parameterless method call, so that the debugger
        can use a fast path without using the expression evaluator.
        
        See https://docs.microsoft.com/en-us/visualstudio/debugger/using-the-debuggerdisplay-attribute
        """
        ...

    @property
    def InternalInnerExceptions(self) -> typing.List[System.Exception]:
        ...

    @overload
    def __init__(self) -> None:
        """Initializes a new instance of the AggregateException class."""
        ...

    @overload
    def __init__(self, message: str) -> None:
        """
        Initializes a new instance of the AggregateException class with
        a specified error message.
        
        :param message: The error message that explains the reason for the exception.
        """
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        """
        Initializes a new instance of the AggregateException class with a specified error
        message and a reference to the inner exception that is the cause of this exception.
        
        :param message: The error message that explains the reason for the exception.
        :param innerException: The exception that is the cause of the current exception.
        """
        ...

    @overload
    def __init__(self, innerExceptions: System.Collections.Generic.IEnumerable[System.Exception]) -> None:
        """
        Initializes a new instance of the AggregateException class with
        references to the inner exceptions that are the cause of this exception.
        
        :param innerExceptions: The exceptions that are the cause of the current exception.
        """
        ...

    @overload
    def __init__(self, *innerExceptions: System.Exception) -> None:
        """
        Initializes a new instance of the AggregateException class with
        references to the inner exceptions that are the cause of this exception.
        
        :param innerExceptions: The exceptions that are the cause of the current exception.
        """
        ...

    @overload
    def __init__(self, message: str, innerExceptions: System.Collections.Generic.IEnumerable[System.Exception]) -> None:
        """
        Initializes a new instance of the AggregateException class with a specified error
        message and references to the inner exceptions that are the cause of this exception.
        
        :param message: The error message that explains the reason for the exception.
        :param innerExceptions: The exceptions that are the cause of the current exception.
        """
        ...

    @overload
    def __init__(self, message: str, *innerExceptions: System.Exception) -> None:
        """
        Initializes a new instance of the AggregateException class with a specified error
        message and references to the inner exceptions that are the cause of this exception.
        
        :param message: The error message that explains the reason for the exception.
        :param innerExceptions: The exceptions that are the cause of the current exception.
        """
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """
        Initializes a new instance of the AggregateException class with serialized data.
        
        This method is protected.
        
        :param info: The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.
        :param context: The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.
        """
        ...

    def Flatten(self) -> System.AggregateException:
        """
        Flattens the inner instances of AggregateException by expanding its contained Exception instances
        into a new AggregateException
        
        :returns: A new, flattened AggregateException.
        """
        ...

    def GetBaseException(self) -> System.Exception:
        """Returns the System.AggregateException that is the root cause of this exception."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """
        Sets the System.Runtime.Serialization.SerializationInfo with information about
        the exception.
        
        :param info: The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.
        :param context: The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.
        """
        ...

    def Handle(self, predicate: typing.Callable[[System.Exception], bool]) -> None:
        """
        Invokes a handler on each System.Exception contained by this AggregateException.
        
        :param predicate: The predicate to execute for each exception. The predicate accepts as an argument the System.Exception to be processed and returns a Boolean to indicate whether the exception was handled.
        """
        ...

    def ToString(self) -> str:
        """
        Creates and returns a string representation of the current AggregateException.
        
        :returns: A string representation of the current exception.
        """
        ...


class IObserver(typing.Generic[System_IObserver_T], metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def OnCompleted(self) -> None:
        ...

    def OnError(self, error: System.Exception) -> None:
        ...

    def OnNext(self, value: System_IObserver_T) -> None:
        ...


class IntPtr(System.Runtime.Serialization.ISerializable, System.IBinaryInteger[System_IntPtr], System.IMinMaxValue[System_IntPtr], System.ISignedNumber[System_IntPtr]):
    """This class has no documentation."""

    Zero: System.IntPtr

    Size: int

    MaxValue: System.IntPtr

    MinValue: System.IntPtr

    AdditiveIdentity: System.IntPtr

    AllBitsSet: System.IntPtr

    @property
    def value(self) -> System.IntPtr:
        ...

    @value.setter
    def value(self, value: System.IntPtr):
        ...

    MultiplicativeIdentity: System.IntPtr

    One: System.IntPtr

    Radix: int

    NegativeOne: System.IntPtr

    @staticmethod
    def () -> System.IntPtr:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: typing.Any) -> None:
        ...

    @staticmethod
    def Abs(value: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def Add(pointer: System.IntPtr, offset: int) -> System.IntPtr:
        ...

    @staticmethod
    def Clamp(value: System.IntPtr, min: System.IntPtr, max: System.IntPtr) -> System.IntPtr:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: System.IntPtr) -> int:
        ...

    @staticmethod
    def CopySign(value: System.IntPtr, sign: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def CreateChecked(value: System_IntPtr_CreateChecked_TOther) -> System.IntPtr:
        ...

    @staticmethod
    def CreateSaturating(value: System_IntPtr_CreateSaturating_TOther) -> System.IntPtr:
        ...

    @staticmethod
    def CreateTruncating(value: System_IntPtr_CreateTruncating_TOther) -> System.IntPtr:
        ...

    @staticmethod
    def DivRem(left: System.IntPtr, right: System.IntPtr) -> System.ValueTuple[System.IntPtr, System.IntPtr]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: System.IntPtr) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    @staticmethod
    def IsCanonical(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsFinite(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsInteger(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsNaN(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsNegative(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsNormal(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsPositive(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsPow2(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def IsZero(value: System.IntPtr) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def Log2(value: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def Max(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def MaxMagnitude(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def MaxNumber(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def Min(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def MinMagnitude(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def MinNumber(x: System.IntPtr, y: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.IntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> System.IntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.IntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> System.IntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System.IntPtr:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> System.IntPtr:
        ...

    @staticmethod
    def PopCount(value: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def RotateLeft(value: System.IntPtr, rotateAmount: int) -> System.IntPtr:
        ...

    @staticmethod
    def RotateRight(value: System.IntPtr, rotateAmount: int) -> System.IntPtr:
        ...

    @staticmethod
    def Sign(value: System.IntPtr) -> int:
        ...

    @staticmethod
    def Subtract(pointer: System.IntPtr, offset: int) -> System.IntPtr:
        ...

    def ToInt32(self) -> int:
        ...

    def ToInt64(self) -> int:
        ...

    def ToPointer(self) -> typing.Any:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    def TrailingZeroCount(value: System.IntPtr) -> System.IntPtr:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromChecked_TOther, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromSaturating_TOther, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertFromTruncating_TOther, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    def TryConvertToChecked(value: System.IntPtr, result: typing.Optional[System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: System.IntPtr, result: typing.Optional[System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: System.IntPtr, result: typing.Optional[System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_IntPtr_System_Numerics_INumberBase<nint>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        """
        Tries to parse a string into a value.
        
        :param s: A read-only span of characters containing a number to convert.
        :param provider: An object that provides culture-specific formatting information about .
        :param result: When this method returns, contains the result of successfully parsing  or an undefined value on failure.
        :returns: true if  was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[System.IntPtr]) -> typing.Union[bool, System.IntPtr]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class Math(System.Object):
    """This class has no documentation."""

    E: float = 2.7182818284590452354

    PI: float = 3.14159265358979323846

    Tau: float = 6.283185307179586476925

    @staticmethod
    @overload
    def Abs(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Abs(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Abs(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Abs(value: System.IntPtr) -> System.IntPtr:
        """
        Returns the absolute value of a native signed integer.
        
        :param value: A number that is greater than IntPtr.MinValue, but less than or equal to IntPtr.MaxValue.
        :returns: A native signed integer, x, such that 0  x  IntPtr.MaxValue.
        """
        ...

    @staticmethod
    @overload
    def Abs(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Abs(value: float) -> float:
        ...

    @staticmethod
    @overload
    def Abs(value: float) -> float:
        ...

    @staticmethod
    @overload
    def Abs(value: float) -> float:
        ...

    @staticmethod
    def Acos(d: float) -> float:
        ...

    @staticmethod
    def Acosh(d: float) -> float:
        ...

    @staticmethod
    def Asin(d: float) -> float:
        ...

    @staticmethod
    def Asinh(d: float) -> float:
        ...

    @staticmethod
    def Atan(d: float) -> float:
        ...

    @staticmethod
    def Atan2(y: float, x: float) -> float:
        ...

    @staticmethod
    def Atanh(d: float) -> float:
        ...

    @staticmethod
    @overload
    def BigMul(a: int, b: int) -> int:
        ...

    @staticmethod
    @overload
    def BigMul(a: int, b: int, low: typing.Optional[int]) -> typing.Union[int, int]:
        """
        Produces the full product of two unsigned 64-bit numbers.
        
        :param a: The first number to multiply.
        :param b: The second number to multiply.
        :param low: The low 64-bit of the product of the specified numbers.
        :returns: The high 64-bit of the product of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def BigMul(a: int, b: int, low: typing.Optional[int]) -> typing.Union[int, int]:
        """
        Produces the full product of two 64-bit numbers.
        
        :param a: The first number to multiply.
        :param b: The second number to multiply.
        :param low: The low 64-bit of the product of the specified numbers.
        :returns: The high 64-bit of the product of the specified numbers.
        """
        ...

    @staticmethod
    def BitDecrement(x: float) -> float:
        ...

    @staticmethod
    def BitIncrement(x: float) -> float:
        ...

    @staticmethod
    def Cbrt(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Ceiling(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Ceiling(a: float) -> float:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: float, min: float, max: float) -> float:
        ...

    @staticmethod
    @overload
    def Clamp(value: float, min: float, max: float) -> float:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: System.IntPtr, min: System.IntPtr, max: System.IntPtr) -> System.IntPtr:
        """
        Returns  clamped to the inclusive range of  and .
        
        :param value: The value to be clamped.
        :param min: The lower bound of the result.
        :param max: The upper bound of the result.
        :returns: if     .    -or-     if  < .    -or-     if  < .
        """
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: float, min: float, max: float) -> float:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @staticmethod
    @overload
    def Clamp(value: System.UIntPtr, min: System.UIntPtr, max: System.UIntPtr) -> System.UIntPtr:
        """
        Returns  clamped to the inclusive range of  and .
        
        :param value: The value to be clamped.
        :param min: The lower bound of the result.
        :param max: The upper bound of the result.
        :returns: if     .    -or-     if  < .    -or-     if  < .
        """
        ...

    @staticmethod
    def CopySign(x: float, y: float) -> float:
        ...

    @staticmethod
    def Cos(d: float) -> float:
        ...

    @staticmethod
    def Cosh(value: float) -> float:
        ...

    @staticmethod
    @overload
    def DivRem(a: int, b: int, result: typing.Optional[int]) -> typing.Union[int, int]:
        ...

    @staticmethod
    @overload
    def DivRem(a: int, b: int, result: typing.Optional[int]) -> typing.Union[int, int]:
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two signed 8-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two unsigned 8-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two signed 16-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two unsigned 16-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two signed 32-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two unsigned 32-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two signed 64-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        """
        Produces the quotient and the remainder of two unsigned 64-bit numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: System.IntPtr, right: System.IntPtr) -> System.ValueTuple[System.IntPtr, System.IntPtr]:
        """
        Produces the quotient and the remainder of two signed native-size numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    @overload
    def DivRem(left: System.UIntPtr, right: System.UIntPtr) -> System.ValueTuple[System.UIntPtr, System.UIntPtr]:
        """
        Produces the quotient and the remainder of two unsigned native-size numbers.
        
        :param left: The dividend.
        :param right: The divisor.
        :returns: The quotient and the remainder of the specified numbers.
        """
        ...

    @staticmethod
    def Exp(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Floor(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Floor(d: float) -> float:
        ...

    @staticmethod
    def FusedMultiplyAdd(x: float, y: float, z: float) -> float:
        ...

    @staticmethod
    def IEEERemainder(x: float, y: float) -> float:
        ...

    @staticmethod
    def ILogB(x: float) -> int:
        ...

    @staticmethod
    @overload
    def Log(a: float, newBase: float) -> float:
        ...

    @staticmethod
    @overload
    def Log(d: float) -> float:
        ...

    @staticmethod
    def Log10(d: float) -> float:
        ...

    @staticmethod
    def Log2(x: float) -> float:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: float, val2: float) -> float:
        ...

    @staticmethod
    @overload
    def Max(val1: float, val2: float) -> float:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: System.IntPtr, val2: System.IntPtr) -> System.IntPtr:
        """
        Returns the larger of two native signed integers.
        
        :param val1: The first of two native signed integers to compare.
        :param val2: The second of two native signed integers to compare.
        :returns: Parameter  or , whichever is larger.
        """
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: float, val2: float) -> float:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Max(val1: System.UIntPtr, val2: System.UIntPtr) -> System.UIntPtr:
        """
        Returns the larger of two native unsigned integers.
        
        :param val1: The first of two native unsigned integers to compare.
        :param val2: The second of two native unsigned integers to compare.
        :returns: Parameter  or , whichever is larger.
        """
        ...

    @staticmethod
    def MaxMagnitude(x: float, y: float) -> float:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: float, val2: float) -> float:
        ...

    @staticmethod
    @overload
    def Min(val1: float, val2: float) -> float:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: System.IntPtr, val2: System.IntPtr) -> System.IntPtr:
        """
        Returns the smaller of two native signed integers.
        
        :param val1: The first of two native signed integers to compare.
        :param val2: The second of two native signed integers to compare.
        :returns: Parameter  or , whichever is smaller.
        """
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: float, val2: float) -> float:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: int, val2: int) -> int:
        ...

    @staticmethod
    @overload
    def Min(val1: System.UIntPtr, val2: System.UIntPtr) -> System.UIntPtr:
        """
        Returns the smaller of two native unsigned integers.
        
        :param val1: The first of two native unsigned integers to compare.
        :param val2: The second of two native unsigned integers to compare.
        :returns: Parameter  or , whichever is smaller.
        """
        ...

    @staticmethod
    def MinMagnitude(x: float, y: float) -> float:
        ...

    @staticmethod
    def Pow(x: float, y: float) -> float:
        ...

    @staticmethod
    def ReciprocalEstimate(d: float) -> float:
        """
        Returns an estimate of the reciprocal of a specified number.
        
        :param d: The number whose reciprocal is to be estimated.
        :returns: An estimate of the reciprocal of .
        """
        ...

    @staticmethod
    def ReciprocalSqrtEstimate(d: float) -> float:
        """
        Returns an estimate of the reciprocal square root of a specified number.
        
        :param d: The number whose reciprocal square root is to be estimated.
        :returns: An estimate of the reciprocal square root .
        """
        ...

    @staticmethod
    @overload
    def Round(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float, decimals: int) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float, decimals: int, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    @overload
    def Round(a: float) -> float:
        ...

    @staticmethod
    @overload
    def Round(value: float, digits: int) -> float:
        ...

    @staticmethod
    @overload
    def Round(value: float, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    @overload
    def Round(value: float, digits: int, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    def ScaleB(x: float, n: int) -> float:
        ...

    @staticmethod
    @overload
    def Sign(value: float) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: float) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: System.IntPtr) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: int) -> int:
        ...

    @staticmethod
    @overload
    def Sign(value: float) -> int:
        ...

    @staticmethod
    def Sin(a: float) -> float:
        ...

    @staticmethod
    def SinCos(x: float) -> System.ValueTuple[float, float]:
        ...

    @staticmethod
    def Sinh(value: float) -> float:
        ...

    @staticmethod
    def Sqrt(d: float) -> float:
        ...

    @staticmethod
    def Tan(a: float) -> float:
        ...

    @staticmethod
    def Tanh(value: float) -> float:
        ...

    @staticmethod
    @overload
    def Truncate(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Truncate(d: float) -> float:
        ...


class CLSCompliantAttribute(System.Attribute):
    """This class has no documentation."""

    @property
    def IsCompliant(self) -> bool:
        ...

    def __init__(self, isCompliant: bool) -> None:
        ...


class Type(System.Reflection.MemberInfo, System.Reflection.IReflect, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    @property
    def MemberType(self) -> int:
        """This property contains the int value of a member of the System.Reflection.MemberTypes enum."""
        ...

    @property
    @abc.abstractmethod
    def Namespace(self) -> str:
        ...

    @property
    @abc.abstractmethod
    def AssemblyQualifiedName(self) -> str:
        ...

    @property
    @abc.abstractmethod
    def FullName(self) -> str:
        ...

    @property
    @abc.abstractmethod
    def Assembly(self) -> System.Reflection.Assembly:
        ...

    @property
    @abc.abstractmethod
    def Module(self) -> System.Reflection.Module:
        ...

    @property
    def IsNested(self) -> bool:
        ...

    @property
    def DeclaringType(self) -> typing.Type:
        ...

    @property
    def DeclaringMethod(self) -> System.Reflection.MethodBase:
        ...

    @property
    def ReflectedType(self) -> typing.Type:
        ...

    @property
    @abc.abstractmethod
    def UnderlyingSystemType(self) -> typing.Type:
        ...

    @property
    def IsTypeDefinition(self) -> bool:
        ...

    @property
    def IsArray(self) -> bool:
        ...

    @property
    def IsByRef(self) -> bool:
        ...

    @property
    def IsPointer(self) -> bool:
        ...

    @property
    def IsConstructedGenericType(self) -> bool:
        ...

    @property
    def IsGenericParameter(self) -> bool:
        ...

    @property
    def IsGenericTypeParameter(self) -> bool:
        ...

    @property
    def IsGenericMethodParameter(self) -> bool:
        ...

    @property
    def IsGenericType(self) -> bool:
        ...

    @property
    def IsGenericTypeDefinition(self) -> bool:
        ...

    @property
    def IsSZArray(self) -> bool:
        ...

    @property
    def IsVariableBoundArray(self) -> bool:
        ...

    @property
    def IsByRefLike(self) -> bool:
        ...

    @property
    def HasElementType(self) -> bool:
        ...

    @property
    def GenericTypeArguments(self) -> typing.List[typing.Type]:
        ...

    @property
    def GenericParameterPosition(self) -> int:
        ...

    @property
    def GenericParameterAttributes(self) -> int:
        """This property contains the int value of a member of the System.Reflection.GenericParameterAttributes enum."""
        ...

    @property
    def Attributes(self) -> int:
        """This property contains the int value of a member of the System.Reflection.TypeAttributes enum."""
        ...

    @property
    def IsAbstract(self) -> bool:
        ...

    @property
    def IsImport(self) -> bool:
        ...

    @property
    def IsSealed(self) -> bool:
        ...

    @property
    def IsSpecialName(self) -> bool:
        ...

    @property
    def IsClass(self) -> bool:
        ...

    @property
    def IsNestedAssembly(self) -> bool:
        ...

    @property
    def IsNestedFamANDAssem(self) -> bool:
        ...

    @property
    def IsNestedFamily(self) -> bool:
        ...

    @property
    def IsNestedFamORAssem(self) -> bool:
        ...

    @property
    def IsNestedPrivate(self) -> bool:
        ...

    @property
    def IsNestedPublic(self) -> bool:
        ...

    @property
    def IsNotPublic(self) -> bool:
        ...

    @property
    def IsPublic(self) -> bool:
        ...

    @property
    def IsAutoLayout(self) -> bool:
        ...

    @property
    def IsExplicitLayout(self) -> bool:
        ...

    @property
    def IsLayoutSequential(self) -> bool:
        ...

    @property
    def IsAnsiClass(self) -> bool:
        ...

    @property
    def IsAutoClass(self) -> bool:
        ...

    @property
    def IsUnicodeClass(self) -> bool:
        ...

    @property
    def IsCOMObject(self) -> bool:
        ...

    @property
    def IsContextful(self) -> bool:
        ...

    @property
    def IsEnum(self) -> bool:
        ...

    @property
    def IsMarshalByRef(self) -> bool:
        ...

    @property
    def IsPrimitive(self) -> bool:
        ...

    @property
    def IsValueType(self) -> bool:
        ...

    @property
    def IsSignatureType(self) -> bool:
        ...

    @property
    def IsSecurityCritical(self) -> bool:
        ...

    @property
    def IsSecuritySafeCritical(self) -> bool:
        ...

    @property
    def IsSecurityTransparent(self) -> bool:
        ...

    @property
    def StructLayoutAttribute(self) -> System.Runtime.InteropServices.StructLayoutAttribute:
        ...

    @property
    def TypeInitializer(self) -> System.Reflection.ConstructorInfo:
        ...

    @property
    def TypeHandle(self) -> System.RuntimeTypeHandle:
        ...

    @property
    @abc.abstractmethod
    def GUID(self) -> System.Guid:
        ...

    @property
    @abc.abstractmethod
    def BaseType(self) -> typing.Type:
        ...

    DefaultBinder: System.Reflection.Binder

    Delimiter: str = ...

    EmptyTypes: typing.List[typing.Type] = ...

    Missing: System.Object = ...

    FilterAttribute: typing.Callable[[System.Reflection.MemberInfo, System.Object], bool] = ...

    FilterName: typing.Callable[[System.Reflection.MemberInfo, System.Object], bool] = ...

    FilterNameIgnoreCase: typing.Callable[[System.Reflection.MemberInfo, System.Object], bool] = ...

    GetAllMembers: System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes = ...

    @property
    def IsSerializable(self) -> bool:
        ...

    @property
    def ContainsGenericParameters(self) -> bool:
        ...

    @property
    def IsVisible(self) -> bool:
        ...

    @property
    def _impl(self) -> System.RuntimeTypeHandle:
        ...

    @_impl.setter
    def _impl(self, value: System.RuntimeTypeHandle):
        ...

    @property
    def IsInterface(self) -> bool:
        ...

    @property
    def IsUserType(self) -> bool:
        ...

    def __init__(self) -> None:
        """This method is protected."""
        ...

    @overload
    def Equals(self, o: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, o: typing.Type) -> bool:
        ...

    def FindInterfaces(self, filter: typing.Callable[[typing.Type, System.Object], bool], filterCriteria: typing.Any) -> typing.List[typing.Type]:
        ...

    def FindMembers(self, memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: typing.Callable[[System.Reflection.MemberInfo, System.Object], bool], filterCriteria: typing.Any) -> typing.List[System.Reflection.MemberInfo]:
        ...

    def GetArrayRank(self) -> int:
        ...

    def GetAttributeFlagsImpl(self) -> int:
        """
        This method is protected.
        
        :returns: This method returns the int value of a member of the System.Reflection.TypeAttributes enum.
        """
        ...

    @overload
    def GetConstructor(self, types: typing.List[typing.Type]) -> System.Reflection.ConstructorInfo:
        ...

    @overload
    def GetConstructor(self, bindingAttr: System.Reflection.BindingFlags, types: typing.List[typing.Type]) -> System.Reflection.ConstructorInfo:
        """
        Searches for a constructor whose parameters match the specified argument types, using the specified binding constraints.
        
        :param bindingAttr: A bitwise combination of the enumeration values that specify how the search is conducted. -or- Default to return null.
        :param types: An array of Type objects representing the number, order, and type of the parameters for the constructor to get. -or- An empty array of the type Type (that is, Type[] types = Array.Empty{Type}()) to get a constructor that takes no parameters. -or- EmptyTypes.
        :returns: A ConstructorInfo object representing the constructor that matches the specified requirements, if found; otherwise, null.
        """
        ...

    @overload
    def GetConstructor(self, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.ConstructorInfo:
        ...

    @overload
    def GetConstructor(self, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.ConstructorInfo:
        ...

    def GetConstructorImpl(self, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.ConstructorInfo:
        """This method is protected."""
        ...

    @overload
    def GetConstructors(self) -> typing.List[System.Reflection.ConstructorInfo]:
        ...

    @overload
    def GetConstructors(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.ConstructorInfo]:
        ...

    def GetDefaultMembers(self) -> typing.List[System.Reflection.MemberInfo]:
        ...

    def GetElementType(self) -> typing.Type:
        ...

    def GetEnumName(self, value: typing.Any) -> str:
        ...

    def GetEnumNames(self) -> typing.List[str]:
        ...

    def GetEnumUnderlyingType(self) -> typing.Type:
        ...

    def GetEnumValues(self) -> System.Array:
        ...

    def GetEnumValuesAsUnderlyingType(self) -> System.Array:
        """
        Retrieves an array of the values of the underlying type constants of this enumeration type.
        
        :returns: An array that contains the values of the underlying type constants in this enumeration type.
        """
        ...

    @overload
    def GetEvent(self, name: str) -> System.Reflection.EventInfo:
        ...

    @overload
    def GetEvent(self, name: str, bindingAttr: System.Reflection.BindingFlags) -> System.Reflection.EventInfo:
        ...

    @overload
    def GetEvents(self) -> typing.List[System.Reflection.EventInfo]:
        ...

    @overload
    def GetEvents(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.EventInfo]:
        ...

    @overload
    def GetField(self, name: str) -> System.Reflection.FieldInfo:
        ...

    @overload
    def GetField(self, name: str, bindingAttr: System.Reflection.BindingFlags) -> System.Reflection.FieldInfo:
        ...

    @overload
    def GetFields(self) -> typing.List[System.Reflection.FieldInfo]:
        ...

    @overload
    def GetFields(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.FieldInfo]:
        ...

    def GetGenericArguments(self) -> typing.List[typing.Type]:
        ...

    def GetGenericParameterConstraints(self) -> typing.List[typing.Type]:
        ...

    def GetGenericTypeDefinition(self) -> typing.Type:
        ...

    def GetHashCode(self) -> int:
        ...

    @overload
    def GetInterface(self, name: str) -> typing.Type:
        ...

    @overload
    def GetInterface(self, name: str, ignoreCase: bool) -> typing.Type:
        ...

    def GetInterfaceMap(self, interfaceType: typing.Type) -> System.Reflection.InterfaceMapping:
        ...

    def GetInterfaces(self) -> typing.List[typing.Type]:
        ...

    @overload
    def GetMember(self, name: str) -> typing.List[System.Reflection.MemberInfo]:
        ...

    @overload
    def GetMember(self, name: str, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.MemberInfo]:
        ...

    @overload
    def GetMember(self, name: str, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.MemberInfo]:
        ...

    @overload
    def GetMembers(self) -> typing.List[System.Reflection.MemberInfo]:
        ...

    @overload
    def GetMembers(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.MemberInfo]:
        ...

    def GetMemberWithSameMetadataDefinitionAs(self, member: System.Reflection.MemberInfo) -> System.Reflection.MemberInfo:
        """
        Searches for the MemberInfo on the current Type that matches the specified MemberInfo.
        
        :param member: The MemberInfo to find on the current Type.
        :returns: An object representing the member on the current Type that matches the specified member.
        """
        ...

    @overload
    def GetMethod(self, name: str) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, bindingAttr: System.Reflection.BindingFlags) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, bindingAttr: System.Reflection.BindingFlags, types: typing.List[typing.Type]) -> System.Reflection.MethodInfo:
        """
        Searches for the specified method whose parameters match the specified argument types, using the specified binding constraints.
        
        :param name: The string containing the name of the method to get.
        :param bindingAttr: A bitwise combination of the enumeration values that specify how the search is conducted. -or- Default to return null.
        :param types: An array of Type objects representing the number, order, and type of the parameters for the method to get. -or- An empty array of Type objects (as provided by the EmptyTypes field) to get a method that takes no parameters.
        :returns: An object representing the method that matches the specified requirements, if found; otherwise, null.
        """
        ...

    @overload
    def GetMethod(self, name: str, types: typing.List[typing.Type]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, genericParameterCount: int, types: typing.List[typing.Type]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, genericParameterCount: int, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, genericParameterCount: int, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethod(self, name: str, genericParameterCount: int, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        ...

    @overload
    def GetMethodImpl(self, name: str, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        """This method is protected."""
        ...

    @overload
    def GetMethodImpl(self, name: str, genericParameterCount: int, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.MethodInfo:
        """This method is protected."""
        ...

    @overload
    def GetMethods(self) -> typing.List[System.Reflection.MethodInfo]:
        ...

    @overload
    def GetMethods(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.MethodInfo]:
        ...

    @overload
    def GetNestedType(self, name: str) -> typing.Type:
        ...

    @overload
    def GetNestedType(self, name: str, bindingAttr: System.Reflection.BindingFlags) -> typing.Type:
        ...

    @overload
    def GetNestedTypes(self) -> typing.List[typing.Type]:
        ...

    @overload
    def GetNestedTypes(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[typing.Type]:
        ...

    @overload
    def GetProperties(self) -> typing.List[System.Reflection.PropertyInfo]:
        ...

    @overload
    def GetProperties(self, bindingAttr: System.Reflection.BindingFlags) -> typing.List[System.Reflection.PropertyInfo]:
        ...

    @overload
    def GetProperty(self, name: str) -> System.Reflection.PropertyInfo:
        ...

    @overload
    def GetProperty(self, name: str, bindingAttr: System.Reflection.BindingFlags) -> System.Reflection.PropertyInfo:
        ...

    @overload
    def GetProperty(self, name: str, returnType: typing.Type) -> System.Reflection.PropertyInfo:
        ...

    @overload
    def GetProperty(self, name: str, types: typing.List[typing.Type]) -> System.Reflection.PropertyInfo:
        ...

    @overload
    def GetProperty(self, name: str, returnType: typing.Type, types: typing.List[typing.Type]) -> System.Reflection.PropertyInfo:
        ...

    @overload
    def GetProperty(self, name: str, returnType: typing.Type, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.PropertyInfo:
        ...

    @overload
    def GetProperty(self, name: str, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: typing.Type, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.PropertyInfo:
        ...

    def GetPropertyImpl(self, name: str, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: typing.Type, types: typing.List[typing.Type], modifiers: typing.List[System.Reflection.ParameterModifier]) -> System.Reflection.PropertyInfo:
        """This method is protected."""
        ...

    @overload
    def GetType(self) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetType(typeName: str, throwOnError: bool, ignoreCase: bool) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetType(typeName: str, throwOnError: bool) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetType(typeName: str) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetType(typeName: str, assemblyResolver: typing.Callable[[System.Reflection.AssemblyName], System.Reflection.Assembly], typeResolver: typing.Callable[[System.Reflection.Assembly, str, bool], typing.Type]) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetType(typeName: str, assemblyResolver: typing.Callable[[System.Reflection.AssemblyName], System.Reflection.Assembly], typeResolver: typing.Callable[[System.Reflection.Assembly, str, bool], typing.Type], throwOnError: bool) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetType(typeName: str, assemblyResolver: typing.Callable[[System.Reflection.AssemblyName], System.Reflection.Assembly], typeResolver: typing.Callable[[System.Reflection.Assembly, str, bool], typing.Type], throwOnError: bool, ignoreCase: bool) -> typing.Type:
        ...

    @staticmethod
    def GetTypeArray(args: typing.List[System.Object]) -> typing.List[typing.Type]:
        ...

    @staticmethod
    def GetTypeCode(type: typing.Type) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    def GetTypeCodeImpl(self) -> int:
        """
        This method is protected.
        
        :returns: This method returns the int value of a member of the System.TypeCode enum.
        """
        ...

    @staticmethod
    @overload
    def GetTypeFromCLSID(clsid: System.Guid) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromCLSID(clsid: System.Guid, throwOnError: bool) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromCLSID(clsid: System.Guid, server: str) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromCLSID(clsid: System.Guid, server: str, throwOnError: bool) -> typing.Type:
        ...

    @staticmethod
    def GetTypeFromHandle(handle: System.RuntimeTypeHandle) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromProgID(progID: str) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromProgID(progID: str, throwOnError: bool) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromProgID(progID: str, server: str) -> typing.Type:
        ...

    @staticmethod
    @overload
    def GetTypeFromProgID(progID: str, server: str, throwOnError: bool) -> typing.Type:
        ...

    @staticmethod
    def GetTypeHandle(o: typing.Any) -> System.RuntimeTypeHandle:
        ...

    def HasElementTypeImpl(self) -> bool:
        """This method is protected."""
        ...

    @overload
    def InvokeMember(self, name: str, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: typing.Any, args: typing.List[System.Object]) -> System.Object:
        ...

    @overload
    def InvokeMember(self, name: str, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: typing.Any, args: typing.List[System.Object], culture: System.Globalization.CultureInfo) -> System.Object:
        ...

    @overload
    def InvokeMember(self, name: str, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: typing.Any, args: typing.List[System.Object], modifiers: typing.List[System.Reflection.ParameterModifier], culture: System.Globalization.CultureInfo, namedParameters: typing.List[str]) -> System.Object:
        ...

    def IsArrayImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsAssignableFrom(self, c: typing.Type) -> bool:
        ...

    def IsAssignableTo(self, targetType: typing.Type) -> bool:
        ...

    def IsByRefImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsCOMObjectImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsContextfulImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsEnumDefined(self, value: typing.Any) -> bool:
        ...

    def IsEquivalentTo(self, other: typing.Type) -> bool:
        ...

    def IsInstanceOfType(self, o: typing.Any) -> bool:
        ...

    def IsMarshalByRefImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsPointerImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsPrimitiveImpl(self) -> bool:
        """This method is protected."""
        ...

    def IsSubclassOf(self, c: typing.Type) -> bool:
        ...

    def IsValueTypeImpl(self) -> bool:
        """This method is protected."""
        ...

    @overload
    def MakeArrayType(self) -> typing.Type:
        ...

    @overload
    def MakeArrayType(self, rank: int) -> typing.Type:
        ...

    def MakeByRefType(self) -> typing.Type:
        ...

    @staticmethod
    def MakeGenericMethodParameter(position: int) -> typing.Type:
        ...

    @staticmethod
    def MakeGenericSignatureType(genericTypeDefinition: typing.Type, *typeArguments: typing.Type) -> typing.Type:
        ...

    def MakeGenericType(self, *typeArguments: typing.Type) -> typing.Type:
        ...

    def MakePointerType(self) -> typing.Type:
        ...

    @staticmethod
    def ReflectionOnlyGetType(typeName: str, throwIfNotFound: bool, ignoreCase: bool) -> typing.Type:
        """Obsoletions.ReflectionOnlyLoadingMessage"""
        warnings.warn("Obsoletions.ReflectionOnlyLoadingMessage", DeprecationWarning)

    def ToString(self) -> str:
        ...


class Decimal(System.IConvertible, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.IFloatingPoint[float], System.IMinMaxValue[float]):
    """This class has no documentation."""

    @property
    def High(self) -> int:
        ...

    @property
    def Low(self) -> int:
        ...

    @property
    def Mid(self) -> int:
        ...

    @property
    def Low64(self) -> int:
        ...

    Zero: float = 0

    One: float = 1

    MinusOne: float = -1

    MaxValue: float = 79228162514264337593543950335

    MinValue: float = -79228162514264337593543950335

    @property
    def Scale(self) -> int:
        """Gets the scaling factor of the decimal, which is a number from 0 to 28 that represents the number of decimal digits."""
        ...

    AdditiveIdentity: float

    E: float

    Pi: float

    Tau: float

    MultiplicativeIdentity: float

    Radix: int

    NegativeOne: float

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: float) -> None:
        ...

    @overload
    def __init__(self, value: float) -> None:
        ...

    @overload
    def __init__(self, bits: typing.List[int]) -> None:
        ...

    @overload
    def __init__(self, bits: System.ReadOnlySpan[int]) -> None:
        """
        Initializes a new instance of decimal to a decimal value represented in binary and contained in the specified span.
        
        :param bits: A span of four ints containing a binary representation of a decimal value.
        """
        ...

    @overload
    def __init__(self, lo: int, mid: int, hi: int, isNegative: bool, scale: int) -> None:
        ...

    @staticmethod
    def Abs(value: float) -> float:
        ...

    @staticmethod
    def Add(d1: float, d2: float) -> float:
        ...

    @staticmethod
    def Ceiling(d: float) -> float:
        ...

    @staticmethod
    def Clamp(value: float, min: float, max: float) -> float:
        ...

    @staticmethod
    def Compare(d1: float, d2: float) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: float) -> int:
        ...

    @staticmethod
    def CopySign(value: float, sign: float) -> float:
        ...

    @staticmethod
    def CreateChecked(value: System_Decimal_CreateChecked_TOther) -> float:
        ...

    @staticmethod
    def CreateSaturating(value: System_Decimal_CreateSaturating_TOther) -> float:
        ...

    @staticmethod
    def CreateTruncating(value: System_Decimal_CreateTruncating_TOther) -> float:
        ...

    @staticmethod
    def Divide(d1: float, d2: float) -> float:
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, value: float) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(d1: float, d2: float) -> bool:
        ...

    @staticmethod
    def Floor(d: float) -> float:
        ...

    @staticmethod
    def FromOACurrency(cy: int) -> float:
        ...

    @staticmethod
    @overload
    def GetBits(d: float) -> typing.List[int]:
        ...

    @staticmethod
    @overload
    def GetBits(d: float, destination: System.Span[int]) -> int:
        """
        Converts the value of a specified instance of decimal to its equivalent binary representation.
        
        :param d: The value to convert.
        :param destination: The span into which to store the four-integer binary representation.
        :returns: Four, the number of integers in the binary representation.
        """
        ...

    def GetExponentByteCount(self) -> int:
        ...

    def GetExponentShortestBitLength(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetSignificandBitLength(self) -> int:
        ...

    def GetSignificandByteCount(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: float) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: float) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: float) -> bool:
        ...

    @staticmethod
    def IsFinite(value: float) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: float) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: float) -> bool:
        ...

    @staticmethod
    def IsInteger(value: float) -> bool:
        ...

    @staticmethod
    def IsNaN(value: float) -> bool:
        ...

    @staticmethod
    def IsNegative(value: float) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: float) -> bool:
        ...

    @staticmethod
    def IsNormal(value: float) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: float) -> bool:
        ...

    @staticmethod
    def IsPositive(value: float) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: float) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: float) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: float) -> bool:
        ...

    @staticmethod
    def IsZero(value: float) -> bool:
        ...

    @staticmethod
    def Max(x: float, y: float) -> float:
        ...

    @staticmethod
    def MaxMagnitude(x: float, y: float) -> float:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: float, y: float) -> float:
        ...

    @staticmethod
    def MaxNumber(x: float, y: float) -> float:
        ...

    @staticmethod
    def Min(x: float, y: float) -> float:
        ...

    @staticmethod
    def MinMagnitude(x: float, y: float) -> float:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: float, y: float) -> float:
        ...

    @staticmethod
    def MinNumber(x: float, y: float) -> float:
        ...

    @staticmethod
    def Multiply(d1: float, d2: float) -> float:
        ...

    @staticmethod
    def Negate(d: float) -> float:
        ...

    def OnDeserialization(self, sender: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    def Remainder(d1: float, d2: float) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float, decimals: int) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    @overload
    def Round(d: float, decimals: int, mode: System.MidpointRounding) -> float:
        ...

    @staticmethod
    def Sign(d: float) -> int:
        ...

    @staticmethod
    def Subtract(d1: float, d2: float) -> float:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    @staticmethod
    @overload
    def ToByte(value: float) -> int:
        ...

    @overload
    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(d: float) -> float:
        ...

    @overload
    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToInt16(value: float) -> int:
        ...

    @overload
    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(d: float) -> int:
        ...

    @overload
    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(d: float) -> int:
        ...

    @overload
    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def ToOACurrency(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: float) -> int:
        ...

    @overload
    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToSingle(d: float) -> float:
        ...

    @overload
    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: float) -> int:
        ...

    @overload
    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(d: float) -> int:
        ...

    @overload
    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(d: float) -> int:
        ...

    @overload
    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def Truncate(d: float) -> float:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromChecked_TOther, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromSaturating_TOther, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertFromTruncating_TOther, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    def TryConvertToChecked(value: float, result: typing.Optional[System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: float, result: typing.Optional[System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: float, result: typing.Optional[System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_Decimal_System_Numerics_INumberBase<System_Decimal>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryGetBits(d: float, destination: System.Span[int], valuesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        """
        Tries to convert the value of a specified instance of decimal to its equivalent binary representation.
        
        :param d: The value to convert.
        :param destination: The span into which to store the binary representation.
        :param valuesWritten: The number of integers written to the destination.
        :returns: true if the decimal's binary representation was written to the destination; false if the destination wasn't long enough.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    def TryWriteExponentBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteExponentLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteSignificandBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteSignificandLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class UnitySerializationHolder(System.Object, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference):
    """
    Holds Null class for which we guarantee that there is only ever one instance of.
    This only exists for compatibility with .NET Framework.
    """

    NullUnity: int = ...

    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetRealObject(self, context: System.Runtime.Serialization.StreamingContext) -> System.Object:
        ...


class Lazy(typing.Generic[System_Lazy_T, System_Lazy_TMetadata], System_Lazy):
    """Provides support for lazy initialization."""

    @property
    def Metadata(self) -> System_Lazy_TMetadata:
        ...

    @property
    def ValueForDebugDisplay(self) -> System_Lazy_T:
        """Gets the value of the Lazy<T> for debugging display purposes."""
        ...

    @property
    def Mode(self) -> typing.Optional[System.Threading.LazyThreadSafetyMode]:
        """Gets a value indicating whether this instance may be used concurrently from multiple threads."""
        ...

    @property
    def IsValueFaulted(self) -> bool:
        """Gets whether the value creation is faulted or not"""
        ...

    @property
    def IsValueCreated(self) -> bool:
        """Gets a value indicating whether the System.Lazy{T} has been initialized."""
        ...

    @property
    def Value(self) -> System_Lazy_T:
        """Gets the lazily initialized value of the current System.Lazy{T}."""
        ...

    @overload
    def __init__(self, valueFactory: typing.Callable[[], System_Lazy_T], metadata: System_Lazy_TMetadata) -> None:
        ...

    @overload
    def __init__(self, metadata: System_Lazy_TMetadata) -> None:
        ...

    @overload
    def __init__(self, metadata: System_Lazy_TMetadata, isThreadSafe: bool) -> None:
        ...

    @overload
    def __init__(self, valueFactory: typing.Callable[[], System_Lazy_T], metadata: System_Lazy_TMetadata, isThreadSafe: bool) -> None:
        ...

    @overload
    def __init__(self, metadata: System_Lazy_TMetadata, mode: System.Threading.LazyThreadSafetyMode) -> None:
        ...

    @overload
    def __init__(self, valueFactory: typing.Callable[[], System_Lazy_T], metadata: System_Lazy_TMetadata, mode: System.Threading.LazyThreadSafetyMode) -> None:
        ...

    @overload
    def __init__(self) -> None:
        """
        Initializes a new instance of the System.Lazy{T} class that
        uses T's default constructor for lazy initialization.
        """
        ...

    @overload
    def __init__(self, value: System_Lazy_T) -> None:
        """
        Initializes a new instance of the System.Lazy{T} class that
        uses a pre-initialized specified value.
        """
        ...

    @overload
    def __init__(self, valueFactory: typing.Callable[[], System_Lazy_T]) -> None:
        """
        Initializes a new instance of the System.Lazy{T} class that uses a
        specified initialization function.
        
        :param valueFactory: The System.Func{T} invoked to produce the lazily-initialized value when it is needed.
        """
        ...

    @overload
    def __init__(self, isThreadSafe: bool) -> None:
        """
        Initializes a new instance of the System.Lazy{T}
        class that uses T's default constructor and a specified thread-safety mode.
        
        :param isThreadSafe: true if this instance should be usable by multiple threads concurrently; false if the instance will only be used by one thread at a time.
        """
        ...

    @overload
    def __init__(self, mode: System.Threading.LazyThreadSafetyMode) -> None:
        """
        Initializes a new instance of the System.Lazy{T}
        class that uses T's default constructor and a specified thread-safety mode.
        
        :param mode: The lazy thread-safety mode
        """
        ...

    @overload
    def __init__(self, valueFactory: typing.Callable[[], System_Lazy_T], isThreadSafe: bool) -> None:
        """
        Initializes a new instance of the System.Lazy{T} class
        that uses a specified initialization function and a specified thread-safety mode.
        
        :param valueFactory: The System.Func{T} invoked to produce the lazily-initialized value when it is needed.
        :param isThreadSafe: true if this instance should be usable by multiple threads concurrently; false if the instance will only be used by one thread at a time.
        """
        ...

    @overload
    def __init__(self, valueFactory: typing.Callable[[], System_Lazy_T], mode: System.Threading.LazyThreadSafetyMode) -> None:
        """
        Initializes a new instance of the System.Lazy{T} class
        that uses a specified initialization function and a specified thread-safety mode.
        
        :param valueFactory: The System.Func{T} invoked to produce the lazily-initialized value when it is needed.
        :param mode: The lazy thread-safety mode.
        """
        ...

    def ToString(self) -> str:
        """
        Creates and returns a string representation of this instance.
        
        :returns: The result of calling object.ToString on the Value.
        """
        ...


class InvalidProgramException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...


class SerializableAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class ArgumentOutOfRangeException(System.ArgumentException):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @property
    def ActualValue(self) -> System.Object:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, paramName: str) -> None:
        ...

    @overload
    def __init__(self, paramName: str, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, paramName: str, actualValue: typing.Any, message: str) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...


class Double(System.IComparable[float], System.IConvertible, System.ISpanFormattable, System.IEquatable[float], System.Numerics.IBinaryFloatingPointIeee754[float], System.IMinMaxValue[float]):
    """This class has no documentation."""

    MinValue: float = ...

    MaxValue: float = ...

    Epsilon: float = ...

    NegativeInfinity: float = ...

    PositiveInfinity: float = ...

    NaN: float = ...

    AdditiveIdentity: float = 0.0
    """Represents the additive identity (0)."""

    MultiplicativeIdentity: float = 1.0
    """Represents the multiplicative identity (1)."""

    One: float = 1.0
    """Represents the number one (1)."""

    Zero: float = 0.0
    """Represents the number zero (0)."""

    NegativeOne: float = -1.0
    """Represents the number negative one (-1)."""

    NegativeZero: float = -0.0
    """Represents the number negative zero (-0)."""

    E: float = ...
    """Represents the natural logarithmic base, specified by the constant, e."""

    Pi: float = ...
    """Represents the ratio of the circumference of a circle to its diameter, specified by the constant, ."""

    Tau: float = ...
    """Represents the number of radians in one turn, specified by the constant, ."""

    SignMask: int = ...

    SignShift: int = 63

    ShiftedSignMask: int = ...

    BiasedExponentMask: int = ...

    BiasedExponentShift: int = 52

    ShiftedExponentMask: int = ...

    TrailingSignificandMask: int = ...

    MinSign: int = 0

    MaxSign: int = 1

    MinBiasedExponent: int = ...

    MaxBiasedExponent: int = ...

    ExponentBias: int = 1023

    MinExponent: int = -1022

    MaxExponent: int = ...

    MinTrailingSignificand: int = ...

    MaxTrailingSignificand: int = ...

    TrailingSignificandLength: int = 52

    SignificandLength: int = ...

    @property
    def BiasedExponent(self) -> int:
        ...

    @property
    def Exponent(self) -> int:
        ...

    @property
    def Significand(self) -> int:
        ...

    @property
    def TrailingSignificand(self) -> int:
        ...

    AllBitsSet: float

    @property
    def value(self) -> float:
        ...

    @value.setter
    def value(self, value: float):
        ...

    @property
    def bits(self) -> int:
        ...

    @bits.setter
    def bits(self, value: int):
        ...

    @staticmethod
    def () -> float:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: float) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: float) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsFinite(d: float) -> bool:
        """Determines whether the specified value is finite (zero, subnormal, or normal)."""
        ...

    @staticmethod
    def IsInfinity(d: float) -> bool:
        """Determines whether the specified value is infinite."""
        ...

    @staticmethod
    def IsNaN(d: float) -> bool:
        """Determines whether the specified value is NaN."""
        ...

    @staticmethod
    def IsNegative(d: float) -> bool:
        """Determines whether the specified value is negative."""
        ...

    @staticmethod
    def IsNegativeInfinity(d: float) -> bool:
        """Determines whether the specified value is negative infinity."""
        ...

    @staticmethod
    def IsNormal(d: float) -> bool:
        """Determines whether the specified value is normal."""
        ...

    @staticmethod
    def IsPositiveInfinity(d: float) -> bool:
        """Determines whether the specified value is positive infinity."""
        ...

    @staticmethod
    def IsPow2(value: float) -> bool:
        ...

    @staticmethod
    def IsSubnormal(d: float) -> bool:
        """Determines whether the specified value is subnormal."""
        ...

    @staticmethod
    def Log2(value: float) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> float:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...


class StackOverflowException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...


class RankException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class AppDomainUnloadedException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Base64FormattingOptions(System.Enum):
    """This class has no documentation."""

    # Cannot convert to Python: None = 0

    InsertLineBreaks = 1


class TypeCode(System.Enum):
    """This class has no documentation."""

    Empty = 0

    Object = 1

    DBNull = 2

    Boolean = 3

    Char = 4

    SByte = 5

    Byte = 6

    Int16 = 7

    UInt16 = 8

    Int32 = 9

    UInt32 = 10

    Int64 = 11

    UInt64 = 12

    Single = 13

    Double = 14

    Decimal = 15

    DateTime = 16

    String = 18


class Convert(System.Object):
    """This class has no documentation."""

    ConvertTypes: typing.List[typing.Type] = ...

    Base64Table: str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="

    DBNull: System.Object = ...

    @staticmethod
    @overload
    def ChangeType(value: typing.Any, typeCode: System.TypeCode) -> System.Object:
        ...

    @staticmethod
    @overload
    def ChangeType(value: typing.Any, typeCode: System.TypeCode, provider: System.IFormatProvider) -> System.Object:
        ...

    @staticmethod
    @overload
    def ChangeType(value: typing.Any, conversionType: typing.Type) -> System.Object:
        ...

    @staticmethod
    @overload
    def ChangeType(value: typing.Any, conversionType: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    @staticmethod
    def FromBase64CharArray(inArray: typing.List[str], offset: int, length: int) -> typing.List[int]:
        """
        Converts the specified range of a Char array, which encodes binary data as Base64 digits, to the equivalent byte array.
        
        :param inArray: Chars representing Base64 encoding characters
        :param offset: A position within the input array.
        :param length: Number of element to convert.
        :returns: The array of bytes represented by the specified Base64 encoding characters.
        """
        ...

    @staticmethod
    def FromBase64String(s: str) -> typing.List[int]:
        """
        Converts the specified string, which encodes binary data as Base64 digits, to the equivalent byte array.
        
        :param s: The string to convert
        :returns: The array of bytes represented by the specified Base64 string.
        """
        ...

    @staticmethod
    @overload
    def FromHexString(s: str) -> typing.List[int]:
        """
        Converts the specified string, which encodes binary data as hex characters, to an equivalent 8-bit unsigned integer array.
        
        :param s: The string to convert.
        :returns: An array of 8-bit unsigned integers that is equivalent to .
        """
        ...

    @staticmethod
    @overload
    def FromHexString(chars: System.ReadOnlySpan[str]) -> typing.List[int]:
        """
        Converts the span, which encodes binary data as hex characters, to an equivalent 8-bit unsigned integer array.
        
        :param chars: The span to convert.
        :returns: An array of 8-bit unsigned integers that is equivalent to .
        """
        ...

    @staticmethod
    def GetTypeCode(value: typing.Any) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsDBNull(value: typing.Any) -> bool:
        ...

    @staticmethod
    @overload
    def ToBase64CharArray(inArray: typing.List[int], offsetIn: int, length: int, outArray: typing.List[str], offsetOut: int) -> int:
        ...

    @staticmethod
    @overload
    def ToBase64CharArray(inArray: typing.List[int], offsetIn: int, length: int, outArray: typing.List[str], offsetOut: int, options: System.Base64FormattingOptions) -> int:
        ...

    @staticmethod
    @overload
    def ToBase64String(inArray: typing.List[int]) -> str:
        ...

    @staticmethod
    @overload
    def ToBase64String(inArray: typing.List[int], options: System.Base64FormattingOptions) -> str:
        ...

    @staticmethod
    @overload
    def ToBase64String(inArray: typing.List[int], offset: int, length: int) -> str:
        ...

    @staticmethod
    @overload
    def ToBase64String(inArray: typing.List[int], offset: int, length: int, options: System.Base64FormattingOptions) -> str:
        ...

    @staticmethod
    @overload
    def ToBase64String(bytes: System.ReadOnlySpan[int], options: System.Base64FormattingOptions = ...) -> str:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: typing.Any) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: typing.Any, provider: System.IFormatProvider) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: bool) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: int) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: str, provider: System.IFormatProvider) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: float) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: float) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: float) -> bool:
        ...

    @staticmethod
    @overload
    def ToBoolean(value: typing.Union[datetime.datetime, datetime.date]) -> bool:
        ...

    @staticmethod
    @overload
    def ToByte(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToByte(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToChar(value: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: typing.Any, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: bool) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: str) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: str) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: str, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: float) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: float) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: float) -> str:
        ...

    @staticmethod
    @overload
    def ToChar(value: typing.Union[datetime.datetime, datetime.date]) -> str:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: typing.Union[datetime.datetime, datetime.date]) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: typing.Any) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: typing.Any, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: str) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: str, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: int) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: bool) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: str) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: float) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: float) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDateTime(value: float) -> datetime.datetime:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: typing.Any) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: typing.Any, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: str) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: str) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: str, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: bool) -> float:
        ...

    @staticmethod
    @overload
    def ToDecimal(value: typing.Union[datetime.datetime, datetime.date]) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: typing.Any) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: typing.Any, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: str) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: str) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: str, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: bool) -> float:
        ...

    @staticmethod
    @overload
    def ToDouble(value: typing.Union[datetime.datetime, datetime.date]) -> float:
        ...

    @staticmethod
    @overload
    def ToHexString(inArray: typing.List[int]) -> str:
        """
        Converts an array of 8-bit unsigned integers to its equivalent string representation that is encoded with uppercase hex characters.
        
        :param inArray: An array of 8-bit unsigned integers.
        :returns: The string representation in hex of the elements in .
        """
        ...

    @staticmethod
    @overload
    def ToHexString(inArray: typing.List[int], offset: int, length: int) -> str:
        """
        Converts a subset of an array of 8-bit unsigned integers to its equivalent string representation that is encoded with uppercase hex characters.
        Parameters specify the subset as an offset in the input array and the number of elements in the array to convert.
        
        :param inArray: An array of 8-bit unsigned integers.
        :param offset: An offset in .
        :param length: The number of elements of  to convert.
        :returns: The string representation in hex of  elements of , starting at position .
        """
        ...

    @staticmethod
    @overload
    def ToHexString(bytes: System.ReadOnlySpan[int]) -> str:
        """
        Converts a span of 8-bit unsigned integers to its equivalent string representation that is encoded with uppercase hex characters.
        
        :param bytes: A span of 8-bit unsigned integers.
        :returns: The string representation in hex of the elements in .
        """
        ...

    @staticmethod
    @overload
    def ToInt16(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToInt16(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToInt32(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToInt64(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToSByte(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToSingle(value: typing.Any) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: typing.Any, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: str) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: int) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: float) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: str) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: str, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: bool) -> float:
        ...

    @staticmethod
    @overload
    def ToSingle(value: typing.Union[datetime.datetime, datetime.date]) -> float:
        ...

    @staticmethod
    @overload
    def ToString(value: typing.Any) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: typing.Any, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: bool) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: bool, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: str) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: str, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: float) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: float, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: float) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: float, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: float) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: float, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: typing.Union[datetime.datetime, datetime.date]) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: typing.Union[datetime.datetime, datetime.date], provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: str) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: str, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, toBase: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, toBase: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, toBase: int) -> str:
        ...

    @staticmethod
    @overload
    def ToString(value: int, toBase: int) -> str:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt16(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt32(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: typing.Any, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: bool) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: int) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: float) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: str) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: typing.Union[datetime.datetime, datetime.date]) -> int:
        ...

    @staticmethod
    @overload
    def ToUInt64(value: str, fromBase: int) -> int:
        ...

    @staticmethod
    def TryFromBase64Chars(chars: System.ReadOnlySpan[str], bytes: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryFromBase64String(s: str, bytes: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryToBase64Chars(bytes: System.ReadOnlySpan[int], chars: System.Span[str], charsWritten: typing.Optional[int], options: System.Base64FormattingOptions = ...) -> typing.Union[bool, int]:
        ...


class InvalidTimeZoneException(System.Exception):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Nullable(typing.Generic[System_Nullable_T]):
    """This class has no documentation."""

    @property
    def value(self) -> System_Nullable_T:
        ...

    @value.setter
    def value(self, value: System_Nullable_T):
        ...

    @property
    def HasValue(self) -> bool:
        ...

    @property
    def Value(self) -> System_Nullable_T:
        ...

    def __init__(self, value: System_Nullable_T) -> None:
        ...

    @staticmethod
    def Compare(n1: typing.Optional[System_Nullable_Compare_T], n2: typing.Optional[System_Nullable_Compare_T]) -> int:
        ...

    @overload
    def Equals(self, other: typing.Any) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(n1: typing.Optional[System_Nullable_Equals_T], n2: typing.Optional[System_Nullable_Equals_T]) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    def GetUnderlyingType(nullableType: typing.Type) -> typing.Type:
        ...

    @overload
    def GetValueOrDefault(self) -> System_Nullable_T:
        ...

    @overload
    def GetValueOrDefault(self, defaultValue: System_Nullable_T) -> System_Nullable_T:
        ...

    @staticmethod
    def GetValueRefOrDefaultRef(nullable: typing.Optional[System_Nullable_GetValueRefOrDefaultRef_T]) -> typing.Any:
        """
        Retrieves a readonly reference to the location in the Nullable{T} instance where the value is stored.
        
        :param nullable: The readonly reference to the input Nullable{T} value.
        :returns: A readonly reference to the location where the instance's T value is stored. If the instance's Nullable{T}.HasValue is false, the current value at that location may be the default value.
        """
        ...

    def ToString(self) -> str:
        ...


class AttributeTargets(System.Enum):
    """This class has no documentation."""

    Assembly = ...

    Module = ...

    Class = ...

    Struct = ...

    Enum = ...

    Constructor = ...

    Method = ...

    Property = ...

    Field = ...

    Event = ...

    Interface = ...

    Parameter = ...

    Delegate = ...

    ReturnValue = ...

    GenericParameter = ...

    All = ...


class Int32(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.ISignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = ...

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    NegativeOne: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_Int32_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_Int32_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_Int32_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_Int32_System_Numerics_INumberBase<System_Int32>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class AppDomainSetup(System.Object):
    """This class has no documentation."""

    @property
    def ApplicationBase(self) -> str:
        ...

    @property
    def TargetFrameworkName(self) -> str:
        ...


class AssemblyLoadEventArgs(System.EventArgs):
    """This class has no documentation."""

    @property
    def LoadedAssembly(self) -> System.Reflection.Assembly:
        ...

    def __init__(self, loadedAssembly: System.Reflection.Assembly) -> None:
        ...


class ResolveEventArgs(System.EventArgs):
    """This class has no documentation."""

    @property
    def Name(self) -> str:
        ...

    @property
    def RequestingAssembly(self) -> System.Reflection.Assembly:
        ...

    @overload
    def __init__(self, name: str) -> None:
        ...

    @overload
    def __init__(self, name: str, requestingAssembly: System.Reflection.Assembly) -> None:
        ...


class AppDomain(System.MarshalByRefObject):
    """This class has no documentation."""

    @property
    def MonitoringTotalProcessorTime(self) -> datetime.timedelta:
        ...

    CurrentDomain: System.AppDomain

    @property
    def BaseDirectory(self) -> str:
        ...

    @property
    def RelativeSearchPath(self) -> str:
        ...

    @property
    def SetupInformation(self) -> System.AppDomainSetup:
        ...

    @property
    def PermissionSet(self) -> System.Security.PermissionSet:
        """Obsoletions.CodeAccessSecurityMessage"""
        warnings.warn("Obsoletions.CodeAccessSecurityMessage", DeprecationWarning)

    @property
    def UnhandledException(self) -> _EventContainer[typing.Callable[[System.Object, System.UnhandledExceptionEventArgs], None], None]:
        ...

    @UnhandledException.setter
    def UnhandledException(self, value: _EventContainer[typing.Callable[[System.Object, System.UnhandledExceptionEventArgs], None], None]):
        ...

    @property
    def DynamicDirectory(self) -> str:
        ...

    @property
    def FriendlyName(self) -> str:
        ...

    @property
    def Id(self) -> int:
        ...

    @property
    def IsFullyTrusted(self) -> bool:
        ...

    @property
    def IsHomogenous(self) -> bool:
        ...

    @property
    def DomainUnload(self) -> _EventContainer[typing.Callable[[System.Object, System.EventArgs], None], None]:
        ...

    @DomainUnload.setter
    def DomainUnload(self, value: _EventContainer[typing.Callable[[System.Object, System.EventArgs], None], None]):
        ...

    @property
    def FirstChanceException(self) -> _EventContainer[typing.Callable[[System.Object, System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs], None], None]:
        ...

    @FirstChanceException.setter
    def FirstChanceException(self, value: _EventContainer[typing.Callable[[System.Object, System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs], None], None]):
        ...

    @property
    def ProcessExit(self) -> _EventContainer[typing.Callable[[System.Object, System.EventArgs], None], None]:
        ...

    @ProcessExit.setter
    def ProcessExit(self, value: _EventContainer[typing.Callable[[System.Object, System.EventArgs], None], None]):
        ...

    MonitoringIsEnabled: bool

    @property
    def MonitoringSurvivedMemorySize(self) -> int:
        ...

    MonitoringSurvivedProcessMemorySize: int

    @property
    def MonitoringTotalAllocatedMemorySize(self) -> int:
        ...

    @property
    def ShadowCopyFiles(self) -> bool:
        ...

    @property
    def AssemblyLoad(self) -> _EventContainer[typing.Callable[[System.Object, System.AssemblyLoadEventArgs], None], None]:
        ...

    @AssemblyLoad.setter
    def AssemblyLoad(self, value: _EventContainer[typing.Callable[[System.Object, System.AssemblyLoadEventArgs], None], None]):
        ...

    @property
    def AssemblyResolve(self) -> _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]:
        ...

    @AssemblyResolve.setter
    def AssemblyResolve(self, value: _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]):
        ...

    @property
    def ReflectionOnlyAssemblyResolve(self) -> _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]:
        ...

    @ReflectionOnlyAssemblyResolve.setter
    def ReflectionOnlyAssemblyResolve(self, value: _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]):
        ...

    @property
    def TypeResolve(self) -> _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]:
        ...

    @TypeResolve.setter
    def TypeResolve(self, value: _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]):
        ...

    @property
    def ResourceResolve(self) -> _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]:
        ...

    @ResourceResolve.setter
    def ResourceResolve(self, value: _EventContainer[typing.Callable[[System.Object, System.ResolveEventArgs], System.Reflection.Assembly], System.Reflection.Assembly]):
        ...

    def AppendPrivatePath(self, path: str) -> None:
        """AppDomain.AppendPrivatePath has been deprecated and is not supported."""
        warnings.warn("AppDomain.AppendPrivatePath has been deprecated and is not supported.", DeprecationWarning)

    def ApplyPolicy(self, assemblyName: str) -> str:
        ...

    def ClearPrivatePath(self) -> None:
        """AppDomain.ClearPrivatePath has been deprecated and is not supported."""
        warnings.warn("AppDomain.ClearPrivatePath has been deprecated and is not supported.", DeprecationWarning)

    def ClearShadowCopyPath(self) -> None:
        """AppDomain.ClearShadowCopyPath has been deprecated and is not supported."""
        warnings.warn("AppDomain.ClearShadowCopyPath has been deprecated and is not supported.", DeprecationWarning)

    @staticmethod
    def CreateDomain(friendlyName: str) -> System.AppDomain:
        """Obsoletions.AppDomainCreateUnloadMessage"""
        warnings.warn("Obsoletions.AppDomainCreateUnloadMessage", DeprecationWarning)

    @overload
    def CreateInstance(self, assemblyName: str, typeName: str) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @overload
    def CreateInstance(self, assemblyName: str, typeName: str, ignoreCase: bool, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @overload
    def CreateInstance(self, assemblyName: str, typeName: str, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @overload
    def CreateInstanceAndUnwrap(self, assemblyName: str, typeName: str) -> System.Object:
        ...

    @overload
    def CreateInstanceAndUnwrap(self, assemblyName: str, typeName: str, ignoreCase: bool, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Object:
        ...

    @overload
    def CreateInstanceAndUnwrap(self, assemblyName: str, typeName: str, activationAttributes: typing.List[System.Object]) -> System.Object:
        ...

    @overload
    def CreateInstanceFrom(self, assemblyFile: str, typeName: str) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @overload
    def CreateInstanceFrom(self, assemblyFile: str, typeName: str, ignoreCase: bool, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @overload
    def CreateInstanceFrom(self, assemblyFile: str, typeName: str, activationAttributes: typing.List[System.Object]) -> System.Runtime.Remoting.ObjectHandle:
        ...

    @overload
    def CreateInstanceFromAndUnwrap(self, assemblyFile: str, typeName: str) -> System.Object:
        ...

    @overload
    def CreateInstanceFromAndUnwrap(self, assemblyFile: str, typeName: str, ignoreCase: bool, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: typing.List[System.Object], culture: System.Globalization.CultureInfo, activationAttributes: typing.List[System.Object]) -> System.Object:
        ...

    @overload
    def CreateInstanceFromAndUnwrap(self, assemblyFile: str, typeName: str, activationAttributes: typing.List[System.Object]) -> System.Object:
        ...

    @overload
    def ExecuteAssembly(self, assemblyFile: str) -> int:
        ...

    @overload
    def ExecuteAssembly(self, assemblyFile: str, args: typing.List[str]) -> int:
        ...

    @overload
    def ExecuteAssembly(self, assemblyFile: str, args: typing.List[str], hashValue: typing.List[int], hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm) -> int:
        """Obsoletions.CodeAccessSecurityMessage"""
        ...

    @overload
    def ExecuteAssemblyByName(self, assemblyName: System.Reflection.AssemblyName, *args: str) -> int:
        ...

    @overload
    def ExecuteAssemblyByName(self, assemblyName: str) -> int:
        ...

    @overload
    def ExecuteAssemblyByName(self, assemblyName: str, *args: str) -> int:
        ...

    def GetAssemblies(self) -> typing.List[System.Reflection.Assembly]:
        ...

    @staticmethod
    def GetCurrentThreadId() -> int:
        """AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread instead."""
        warnings.warn("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread instead.", DeprecationWarning)

    def GetData(self, name: str) -> System.Object:
        ...

    def IsCompatibilitySwitchSet(self, value: str) -> typing.Optional[bool]:
        ...

    def IsDefaultAppDomain(self) -> bool:
        ...

    def IsFinalizingForUnload(self) -> bool:
        ...

    @overload
    def Load(self, rawAssembly: typing.List[int]) -> System.Reflection.Assembly:
        ...

    @overload
    def Load(self, rawAssembly: typing.List[int], rawSymbolStore: typing.List[int]) -> System.Reflection.Assembly:
        ...

    @overload
    def Load(self, assemblyRef: System.Reflection.AssemblyName) -> System.Reflection.Assembly:
        ...

    @overload
    def Load(self, assemblyString: str) -> System.Reflection.Assembly:
        ...

    def ReflectionOnlyGetAssemblies(self) -> typing.List[System.Reflection.Assembly]:
        ...

    def SetCachePath(self, path: str) -> None:
        """AppDomain.SetCachePath has been deprecated and is not supported."""
        warnings.warn("AppDomain.SetCachePath has been deprecated and is not supported.", DeprecationWarning)

    def SetData(self, name: str, data: typing.Any) -> None:
        ...

    def SetDynamicBase(self, path: str) -> None:
        """AppDomain.SetDynamicBase has been deprecated and is not supported."""
        warnings.warn("AppDomain.SetDynamicBase has been deprecated and is not supported.", DeprecationWarning)

    def SetPrincipalPolicy(self, policy: System.Security.Principal.PrincipalPolicy) -> None:
        ...

    def SetShadowCopyFiles(self) -> None:
        """AppDomain.SetShadowCopyFiles has been deprecated and is not supported."""
        warnings.warn("AppDomain.SetShadowCopyFiles has been deprecated and is not supported.", DeprecationWarning)

    def SetShadowCopyPath(self, path: str) -> None:
        """AppDomain.SetShadowCopyPath has been deprecated and is not supported."""
        warnings.warn("AppDomain.SetShadowCopyPath has been deprecated and is not supported.", DeprecationWarning)

    def SetThreadPrincipal(self, principal: System.Security.Principal.IPrincipal) -> None:
        ...

    def ToString(self) -> str:
        ...

    @staticmethod
    def Unload(domain: System.AppDomain) -> None:
        """Obsoletions.AppDomainCreateUnloadMessage"""
        warnings.warn("Obsoletions.AppDomainCreateUnloadMessage", DeprecationWarning)


class IndexOutOfRangeException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...


class NotSupportedException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class PlatformNotSupportedException(System.NotSupportedException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class FormattableString(System.Object, System.IFormattable, metaclass=abc.ABCMeta):
    """
    A composite format string along with the arguments to be formatted. An instance of this
    type may result from the use of the C# or VB language primitive "interpolated string".
    """

    @property
    @abc.abstractmethod
    def Format(self) -> str:
        """The composite format string."""
        ...

    @property
    @abc.abstractmethod
    def ArgumentCount(self) -> int:
        """The number of arguments to be formatted."""
        ...

    @staticmethod
    def CurrentCulture(formattable: System.FormattableString) -> str:
        """
        Format the given object in the current culture. This static method may be
        imported in C# by
        
        using static System.FormattableString;
        .
        Within the scope
        of that import directive an interpolated string may be formatted in the
        current culture by writing, for example,
        
        CurrentCulture($"{{ lat = {latitude}; lon = {longitude} }}")
        """
        ...

    def GetArgument(self, index: int) -> System.Object:
        """Returns one argument to be formatted from argument position ."""
        ...

    def GetArguments(self) -> typing.List[System.Object]:
        """
        Returns an object array that contains zero or more objects to format. Clients should not
        mutate the contents of the array.
        """
        ...

    @staticmethod
    def Invariant(formattable: System.FormattableString) -> str:
        """
        Format the given object in the invariant culture. This static method may be
        imported in C# by
        
        using static System.FormattableString;
        .
        Within the scope
        of that import directive an interpolated string may be formatted in the
        invariant culture by writing, for example,
        
        Invariant($"{{ lat = {latitude}; lon = {longitude} }}")
        """
        ...

    @overload
    def ToString(self, formatProvider: System.IFormatProvider) -> str:
        """Format to a string using the given culture."""
        ...

    @overload
    def ToString(self, ignored: str, formatProvider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...


class BadImageFormatException(System.SystemException):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @property
    def FileName(self) -> str:
        ...

    @property
    def FusionLog(self) -> str:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, message: str, fileName: str) -> None:
        ...

    @overload
    def __init__(self, message: str, fileName: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def ToString(self) -> str:
        ...


class UInt32(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.IUnsignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = ...

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_UInt32_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_UInt32_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_UInt32_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_UInt32_System_Numerics_INumberBase<System_UInt32>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class Boolean(System.IComparable[bool], System.IConvertible, System.IEquatable[bool]):
    """This class has no documentation."""

    # Cannot convert to Python: True: int = 1

    # Cannot convert to Python: False: int = 0

    TrueLiteral: str = "True"

    FalseLiteral: str = "False"

    TrueString: str = ...

    FalseString: str = ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: bool) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: bool) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    @overload
    def Parse(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def Parse(value: System.ReadOnlySpan[str]) -> bool:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(value: str, result: typing.Optional[bool]) -> typing.Union[bool, bool]:
        ...

    @staticmethod
    @overload
    def TryParse(value: System.ReadOnlySpan[str], result: typing.Optional[bool]) -> typing.Union[bool, bool]:
        ...


class IProgress(typing.Generic[System_IProgress_T], metaclass=abc.ABCMeta):
    """Defines a provider for progress updates."""

    def Report(self, value: System_IProgress_T) -> None:
        """
        Reports a progress update.
        
        :param value: The value of the updated progress.
        """
        ...


class UInt16(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.IUnsignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = 0

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_UInt16_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_UInt16_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_UInt16_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_UInt16_System_Numerics_INumberBase<System_UInt16>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class DBNull(System.Object, System.Runtime.Serialization.ISerializable, System.IConvertible):
    """This class has no documentation."""

    Value: System.DBNull = ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...


class TimeSpan(System.IComparable[datetime.timedelta], System.IEquatable[datetime.timedelta], System.ISpanFormattable, System.ISpanParsable[datetime.timedelta]):
    """This class has no documentation."""

    NanosecondsPerTick: int = 100
    """Represents the number of nanoseconds per tick. This field is constant."""

    TicksPerMicrosecond: int = 10
    """Represents the number of ticks in 1 microsecond. This field is constant."""

    TicksPerMillisecond: int = ...
    """Represents the number of ticks in 1 millisecond. This field is constant."""

    TicksPerSecond: int = ...

    TicksPerMinute: int = ...

    TicksPerHour: int = ...

    TicksPerDay: int = ...

    MaxSeconds: int = ...

    MinSeconds: int = ...

    MaxMilliSeconds: int = ...

    MinMilliSeconds: int = ...

    MaxMicroSeconds: int = ...

    MinMicroSeconds: int = ...

    TicksPerTenthSecond: int = ...

    Zero: datetime.timedelta = ...

    MaxValue: datetime.timedelta = ...

    MinValue: datetime.timedelta = ...

    @property
    def _ticks(self) -> int:
        ...

    @property
    def Ticks(self) -> int:
        ...

    @property
    def Days(self) -> int:
        ...

    @property
    def Hours(self) -> int:
        ...

    @property
    def Milliseconds(self) -> int:
        ...

    @property
    def Microseconds(self) -> int:
        """Gets the microseconds component of the time interval represented by the current TimeSpan structure."""
        ...

    @property
    def Nanoseconds(self) -> int:
        """Gets the nanoseconds component of the time interval represented by the current TimeSpan structure."""
        ...

    @property
    def Minutes(self) -> int:
        ...

    @property
    def Seconds(self) -> int:
        ...

    @property
    def TotalDays(self) -> float:
        ...

    @property
    def TotalHours(self) -> float:
        ...

    @property
    def TotalMilliseconds(self) -> float:
        ...

    @property
    def TotalMicroseconds(self) -> float:
        """Gets the value of the current TimeSpan structure expressed in whole and fractional microseconds."""
        ...

    @property
    def TotalNanoseconds(self) -> float:
        """Gets the value of the current TimeSpan structure expressed in whole and fractional nanoseconds."""
        ...

    @property
    def TotalMinutes(self) -> float:
        ...

    @property
    def TotalSeconds(self) -> float:
        ...

    @overload
    def __init__(self, ticks: int) -> None:
        ...

    @overload
    def __init__(self, hours: int, minutes: int, seconds: int) -> None:
        ...

    @overload
    def __init__(self, days: int, hours: int, minutes: int, seconds: int) -> None:
        ...

    @overload
    def __init__(self, days: int, hours: int, minutes: int, seconds: int, milliseconds: int) -> None:
        """
        Initializes a new instance of the TimeSpan structure to a specified number of
        days, hours, minutes, seconds, and milliseconds.
        
        :param days: Number of days.
        :param hours: Number of hours.
        :param minutes: Number of minutes.
        :param seconds: Number of seconds.
        :param milliseconds: Number of milliseconds.
        """
        ...

    @overload
    def __init__(self, days: int, hours: int, minutes: int, seconds: int, milliseconds: int, microseconds: int) -> None:
        """
        Initializes a new instance of the TimeSpan structure to a specified number of
        days, hours, minutes, seconds, and milliseconds.
        
        :param days: Number of days.
        :param hours: Number of hours.
        :param minutes: Number of minutes.
        :param seconds: Number of seconds.
        :param milliseconds: Number of milliseconds.
        :param microseconds: Number of microseconds.
        """
        ...

    def Add(self, ts: datetime.timedelta) -> datetime.timedelta:
        ...

    @staticmethod
    def Compare(t1: datetime.timedelta, t2: datetime.timedelta) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: datetime.timedelta) -> int:
        ...

    @overload
    def Divide(self, divisor: float) -> datetime.timedelta:
        ...

    @overload
    def Divide(self, ts: datetime.timedelta) -> float:
        ...

    def Duration(self) -> datetime.timedelta:
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: datetime.timedelta) -> bool:
        ...

    @staticmethod
    @overload
    def Equals(t1: datetime.timedelta, t2: datetime.timedelta) -> bool:
        ...

    @staticmethod
    def FromDays(value: float) -> datetime.timedelta:
        ...

    @staticmethod
    def FromHours(value: float) -> datetime.timedelta:
        ...

    @staticmethod
    def FromMicroseconds(value: float) -> datetime.timedelta:
        """
        Returns a TimeSpan that represents a specified number of microseconds.
        
        :param value: A number of microseconds.
        :returns: An object that represents .
        """
        ...

    @staticmethod
    def FromMilliseconds(value: float) -> datetime.timedelta:
        ...

    @staticmethod
    def FromMinutes(value: float) -> datetime.timedelta:
        ...

    @staticmethod
    def FromSeconds(value: float) -> datetime.timedelta:
        ...

    @staticmethod
    def FromTicks(value: int) -> datetime.timedelta:
        ...

    def GetHashCode(self) -> int:
        ...

    def Multiply(self, factor: float) -> datetime.timedelta:
        ...

    def Negate(self) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def Parse(input: str, formatProvider: System.IFormatProvider) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def Parse(input: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider = None) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, format: str, formatProvider: System.IFormatProvider) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, formats: typing.List[str], formatProvider: System.IFormatProvider) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, format: str, formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def ParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles = ...) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def ParseExact(input: str, formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles) -> datetime.timedelta:
        ...

    @staticmethod
    @overload
    def ParseExact(input: System.ReadOnlySpan[str], formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles = ...) -> datetime.timedelta:
        ...

    def Subtract(self, ts: datetime.timedelta) -> datetime.timedelta:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, formatProvider: System.IFormatProvider) -> str:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., formatProvider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParse(input: str, formatProvider: System.IFormatProvider, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParse(input: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, format: str, formatProvider: System.IFormatProvider, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, formats: typing.List[str], formatProvider: System.IFormatProvider, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], formats: typing.List[str], formatProvider: System.IFormatProvider, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, format: str, formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: str, formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...

    @staticmethod
    @overload
    def TryParseExact(input: System.ReadOnlySpan[str], formats: typing.List[str], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: typing.Optional[datetime.timedelta]) -> typing.Union[bool, datetime.timedelta]:
        ...


class OverflowException(System.ArithmeticException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class DivideByZeroException(System.ArithmeticException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class MissingFieldException(System.MissingMemberException, System.Runtime.Serialization.ISerializable):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, className: str, fieldName: str) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class TypeLoadException(System.SystemException, System.Runtime.Serialization.ISerializable):
    """This class has no documentation."""

    @property
    def Message(self) -> str:
        ...

    @property
    def TypeName(self) -> str:
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...


class EntryPointNotFoundException(System.TypeLoadException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Void:
    """This class has no documentation."""


class WeakReference(typing.Generic[System_WeakReference_T], System.Object, System.Runtime.Serialization.ISerializable):
    """This class has no documentation."""

    @property
    def TrackResurrection(self) -> bool:
        ...

    @property
    def WeakHandle(self) -> System.IntPtr:
        ...

    @property
    def IsAlive(self) -> bool:
        ...

    @property
    def Target(self) -> System.Object:
        ...

    @Target.setter
    def Target(self, value: System.Object):
        ...

    @overload
    def __init__(self, target: System_WeakReference_T) -> None:
        ...

    @overload
    def __init__(self, target: System_WeakReference_T, trackResurrection: bool) -> None:
        ...

    @overload
    def __init__(self, target: typing.Any) -> None:
        ...

    @overload
    def __init__(self, target: typing.Any, trackResurrection: bool) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    @overload
    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    @overload
    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    def SetTarget(self, target: System_WeakReference_T) -> None:
        ...

    def TryGetTarget(self, target: typing.Optional[System_WeakReference_T]) -> typing.Union[bool, System_WeakReference_T]:
        ...


class TimeOnly(System.IComparable[System_TimeOnly], System.IEquatable[System_TimeOnly], System.ISpanFormattable, System.ISpanParsable[System_TimeOnly]):
    """Represents a time of day, as would be read from a clock, within the range 00:00:00 to 23:59:59.9999999."""

    MinValue: System.TimeOnly
    """Represents the smallest possible value of TimeOnly."""

    MaxValue: System.TimeOnly
    """Represents the largest possible value of TimeOnly."""

    @property
    def Hour(self) -> int:
        """Gets the hour component of the time represented by this instance."""
        ...

    @property
    def Minute(self) -> int:
        """Gets the minute component of the time represented by this instance."""
        ...

    @property
    def Second(self) -> int:
        """Gets the second component of the time represented by this instance."""
        ...

    @property
    def Millisecond(self) -> int:
        """Gets the millisecond component of the time represented by this instance."""
        ...

    @property
    def Microsecond(self) -> int:
        """Gets the microsecond component of the time represented by this instance."""
        ...

    @property
    def Nanosecond(self) -> int:
        """Gets the nanosecond component of the time represented by this instance."""
        ...

    @property
    def Ticks(self) -> int:
        """Gets the number of ticks that represent the time of this instance."""
        ...

    @overload
    def __init__(self, hour: int, minute: int) -> None:
        """
        Initializes a new instance of the timeOnly structure to the specified hour and the minute.
        
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        """
        ...

    @overload
    def __init__(self, hour: int, minute: int, second: int) -> None:
        """
        Initializes a new instance of the timeOnly structure to the specified hour, minute, and second.
        
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        """
        ...

    @overload
    def __init__(self, hour: int, minute: int, second: int, millisecond: int) -> None:
        """
        Initializes a new instance of the timeOnly structure to the specified hour, minute, second, and millisecond.
        
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The millisecond (0 through 999).
        """
        ...

    @overload
    def __init__(self, hour: int, minute: int, second: int, millisecond: int, microsecond: int) -> None:
        """
        Initializes a new instance of the TimeOnly structure to the specified hour, minute, second, and millisecond.
        
        :param hour: The hours (0 through 23).
        :param minute: The minutes (0 through 59).
        :param second: The seconds (0 through 59).
        :param millisecond: The millisecond (0 through 999).
        :param microsecond: The microsecond (0 through 999).
        """
        ...

    @overload
    def __init__(self, ticks: int) -> None:
        """
        Initializes a new instance of the TimeOnly structure using a specified number of ticks.
        
        :param ticks: A time of day expressed in the number of 100-nanosecond units since 00:00:00.0000000.
        """
        ...

    @overload
    def Add(self, value: datetime.timedelta) -> System.TimeOnly:
        """
        Returns a new TimeOnly that adds the value of the specified TimeSpan to the value of this instance.
        
        :param value: A positive or negative time interval.
        :returns: An object whose value is the sum of the time represented by this instance and the time interval represented by value.
        """
        ...

    @overload
    def Add(self, value: datetime.timedelta, wrappedDays: typing.Optional[int]) -> typing.Union[System.TimeOnly, int]:
        """
        Returns a new TimeOnly that adds the value of the specified TimeSpan to the value of this instance.
        If the result wraps past the end of the day, this method will return the number of excess days as an out parameter.
        
        :param value: A positive or negative time interval.
        :param wrappedDays: When this method returns, contains the number of excess days if any that resulted from wrapping during this addition operation.
        :returns: An object whose value is the sum of the time represented by this instance and the time interval represented by value.
        """
        ...

    @overload
    def AddHours(self, value: float) -> System.TimeOnly:
        """
        Returns a new TimeOnly that adds the specified number of hours to the value of this instance.
        
        :param value: A number of whole and fractional hours. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the time represented by this instance and the number of hours represented by value.
        """
        ...

    @overload
    def AddHours(self, value: float, wrappedDays: typing.Optional[int]) -> typing.Union[System.TimeOnly, int]:
        """
        Returns a new TimeOnly that adds the specified number of hours to the value of this instance.
        If the result wraps past the end of the day, this method will return the number of excess days as an out parameter.
        
        :param value: A number of whole and fractional hours. The value parameter can be negative or positive.
        :param wrappedDays: When this method returns, contains the number of excess days if any that resulted from wrapping during this addition operation.
        :returns: An object whose value is the sum of the time represented by this instance and the number of hours represented by value.
        """
        ...

    @overload
    def AddMinutes(self, value: float) -> System.TimeOnly:
        """
        Returns a new TimeOnly that adds the specified number of minutes to the value of this instance.
        
        :param value: A number of whole and fractional minutes. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the time represented by this instance and the number of minutes represented by value.
        """
        ...

    @overload
    def AddMinutes(self, value: float, wrappedDays: typing.Optional[int]) -> typing.Union[System.TimeOnly, int]:
        """
        Returns a new TimeOnly that adds the specified number of minutes to the value of this instance.
        If the result wraps past the end of the day, this method will return the number of excess days as an out parameter.
        
        :param value: A number of whole and fractional minutes. The value parameter can be negative or positive.
        :param wrappedDays: When this method returns, contains the number of excess days if any that resulted from wrapping during this addition operation.
        :returns: An object whose value is the sum of the time represented by this instance and the number of minutes represented by value.
        """
        ...

    @overload
    def CompareTo(self, value: System.TimeOnly) -> int:
        """
        Compares the value of this instance to a specified TimeOnly value and indicates whether this instance is earlier than, the same as, or later than the specified TimeOnly value.
        
        :param value: The object to compare to the current instance.
        :returns: A signed number indicating the relative values of this instance and the value parameter. Less than zero if this instance is earlier than value. Zero if this instance is the same as value. Greater than zero if this instance is later than value.
        """
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        """
        Compares the value of this instance to a specified object that contains a specified TimeOnly value, and returns an integer that indicates whether this instance is earlier than, the same as, or later than the specified TimeOnly value.
        
        :param value: A boxed object to compare, or null.
        :returns: A signed number indicating the relative values of this instance and the value parameter. Less than zero if this instance is earlier than value. Zero if this instance is the same as value. Greater than zero if this instance is later than value.
        """
        ...

    @overload
    def Equals(self, value: System.TimeOnly) -> bool:
        """
        Returns a value indicating whether the value of this instance is equal to the value of the specified TimeOnly instance.
        
        :param value: The object to compare to this instance.
        :returns: true if the value parameter equals the value of this instance; otherwise, false.
        """
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        """
        Returns a value indicating whether this instance is equal to a specified object.
        
        :param value: The object to compare to this instance.
        :returns: true if value is an instance of TimeOnly and equals the value of this instance; otherwise, false.
        """
        ...

    @staticmethod
    def FromDateTime(dateTime: typing.Union[datetime.datetime, datetime.date]) -> System.TimeOnly:
        """
        Constructs a TimeOnly object from a DateTime representing the time of the day in this DateTime object.
        
        :param dateTime: The time DateTime object to extract the time of the day from.
        :returns: A TimeOnly object representing time of the day specified in the DateTime object.
        """
        ...

    @staticmethod
    def FromTimeSpan(timeSpan: datetime.timedelta) -> System.TimeOnly:
        """
        Constructs a TimeOnly object from a TimeSpan representing the time elapsed since midnight.
        
        :param timeSpan: The time interval measured since midnight. This value has to be positive and not exceeding the time of the day.
        :returns: A TimeOnly object representing the time elapsed since midnight using the timeSpan value.
        """
        ...

    def GetHashCode(self) -> int:
        """
        Returns the hash code for this instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    def IsBetween(self, start: System.TimeOnly, end: System.TimeOnly) -> bool:
        """
        Determines if a time falls within the range provided.
        Supports both "normal" ranges such as 10:00-12:00, and ranges that span midnight such as 23:00-01:00.
        
        :param start: The starting time of day, inclusive.
        :param end: The ending time of day, exclusive.
        :returns: True, if the time falls within the range, false otherwise.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider = ..., style: System.Globalization.DateTimeStyles = ...) -> System.TimeOnly:
        """
        Converts a memory span that contains string representation of a time to its TimeOnly equivalent by using culture-specific format information and a formatting style.
        
        :param s: The memory span that contains the string to parse.
        :param provider: An object that supplies culture-specific format information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the time contained in s, as specified by provider and styles.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.TimeOnly:
        """
        Converts a string that contains string representation of a time to its TimeOnly equivalent by using the conventions of the current culture.
        
        :param s: The string that contains the string to parse.
        :returns: An object that is equivalent to the time contained in s.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.TimeOnly:
        """
        Converts a string that contains string representation of a time to its TimeOnly equivalent by using culture-specific format information and a formatting style.
        
        :param s: The string that contains the string to parse.
        :param provider: An object that supplies culture-specific format information about s.
        :param style: A bitwise combination of the enumeration values that indicates the style elements that can be present in s for the parse operation to succeed, and that defines how to interpret the parsed date. A typical value to specify is None.
        :returns: An object that is equivalent to the time contained in s, as specified by provider and styles.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.TimeOnly:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System.TimeOnly:
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], provider: System.IFormatProvider = ..., style: System.Globalization.DateTimeStyles = ...) -> System.TimeOnly:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a time to convert.
        :param format: A span containing the characters that represent a format specifier that defines the required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the time contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str]) -> System.TimeOnly:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified array of formats.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a time to convert.
        :param formats: An array of allowable formats of s.
        :returns: An object that is equivalent to the time contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.TimeOnly:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified array of formats, culture-specific format information, and style.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a time to convert.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the time contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, format: str) -> System.TimeOnly:
        """
        Converts the specified string representation of a time to its TimeOnly equivalent using the specified format.
        The format of the string representation must match the specified format exactly or an exception is thrown.
        
        :param s: A string containing the characters that represent a time to convert.
        :param format: A string that represent a format specifier that defines the required format of s.
        :returns: An object that is equivalent to the time contained in s, as specified by format.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, format: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.TimeOnly:
        """
        Converts the specified string representation of a time to its TimeOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly or an exception is thrown.
        
        :param s: A string containing the characters that represent a time to convert.
        :param format: A string containing the characters that represent a format specifier that defines the required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of the enumeration values that provides additional information about s, about style elements that may be present in s, or about the conversion from s to a TimeOnly value. A typical value to specify is None.
        :returns: An object that is equivalent to the time contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, formats: typing.List[str]) -> System.TimeOnly:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified array of formats.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a time to convert.
        :param formats: An array of allowable formats of s.
        :returns: An object that is equivalent to the time contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.TimeOnly:
        """
        Converts the specified string representation of a time to its TimeOnly equivalent using the specified array of formats, culture-specific format information, and style.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A string containing the characters that represent a time to convert.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the time contained in s, as specified by format, provider, and style.
        """
        ...

    def ToLongTimeString(self) -> str:
        """
        Converts the value of the current TimeOnly object to its equivalent long date string representation.
        
        :returns: A string that contains the long time string representation of the current TimeOnly object.
        """
        ...

    def ToShortTimeString(self) -> str:
        """
        Converts the value of the current TimeOnly object to its equivalent short time string representation.
        
        :returns: A string that contains the short time string representation of the current TimeOnly object.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Converts the value of the current TimeOnly object to its equivalent string representation using the formatting conventions of the current culture.
        The TimeOnly object will be formatted in short form.
        
        :returns: A string that contains the short time string representation of the current TimeOnly object.
        """
        ...

    @overload
    def ToString(self, format: str) -> str:
        """
        Converts the value of the current TimeOnly object to its equivalent string representation using the specified format and the formatting conventions of the current culture.
        
        :param format: A standard or custom time format string.
        :returns: A string representation of value of the current TimeOnly object as specified by format.
        """
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        """
        Converts the value of the current TimeOnly object to its equivalent string representation using the specified culture-specific format information.
        
        :param provider: An object that supplies culture-specific formatting information.
        :returns: A string representation of value of the current TimeOnly object as specified by provider.
        """
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        """
        Converts the value of the current TimeOnly object to its equivalent string representation using the specified culture-specific format information.
        
        :param format: A standard or custom time format string.
        :param provider: An object that supplies culture-specific formatting information.
        :returns: A string representation of value of the current TimeOnly object as specified by format and provider.
        """
        ...

    def ToTimeSpan(self) -> datetime.timedelta:
        """
        Convert the current TimeOnly instance to a TimeSpan object.
        
        :returns: A TimeSpan object spanning to the time specified in the current TimeOnly object.
        """
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        """
        Tries to format the value of the current TimeOnly instance into the provided span of characters.
        
        :param destination: When this method returns, this instance's value formatted as a span of characters.
        :param charsWritten: When this method returns, the number of characters that were written in destination.
        :param format: A span containing the characters that represent a standard or custom format string that defines the acceptable format for destination.
        :param provider: An optional object that supplies culture-specific formatting information for destination.
        :returns: true if the formatting was successful; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing the time to convert.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified array of formats, culture-specific format information, and style. And returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters that represent a time to convert.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified string representation of a time to its TimeOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters representing the time to convert.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified string representation of a time to its TimeOnly equivalent using the specified array of formats, culture-specific format information, and style. And returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters that represent a time to convert.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified format and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing a time to convert.
        :param format: The required format of s.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a time that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing a time to convert.
        :param format: The required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of one or more enumeration values that indicate the permitted format of s.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a time that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified char span of a time to its TimeOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The span containing the string to parse.
        :param formats: An array of allowable formats of s.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified char span of a time to its TimeOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The span containing the string to parse.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that defines how to interpret the parsed time. A typical value to specify is None.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, format: str, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified string representation of a time to its TimeOnly equivalent using the specified format and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters representing a time to convert.
        :param format: The required format of s.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a time that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, format: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified span representation of a time to its TimeOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing a time to convert.
        :param format: The required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of one or more enumeration values that indicate the permitted format of s.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a time that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, formats: typing.List[str], result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified string of a time to its TimeOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The string containing time to parse.
        :param formats: An array of allowable formats of s.
        :param result: When this method returns, contains the timeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.TimeOnly]) -> typing.Union[bool, System.TimeOnly]:
        """
        Converts the specified string of a time to its TimeOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The string containing the time to parse.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that defines how to interpret the parsed date. A typical value to specify is None.
        :param result: When this method returns, contains the TimeOnly value equivalent to the time contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a time. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...


class Progress(typing.Generic[System_Progress_T], System.Object, System.IProgress[System_Progress_T]):
    """Provides an IProgress{T} that invokes callbacks for each reported progress value."""

    @property
    def ProgressChanged(self) -> _EventContainer[typing.Callable[[System.Object, System_Progress_T], None], None]:
        """Raised for each reported progress value."""
        ...

    @ProgressChanged.setter
    def ProgressChanged(self, value: _EventContainer[typing.Callable[[System.Object, System_Progress_T], None], None]):
        """Raised for each reported progress value."""
        ...

    @overload
    def __init__(self) -> None:
        """Initializes the Progress{T}."""
        ...

    @overload
    def __init__(self, handler: typing.Callable[[System_Progress_T], None]) -> None:
        """
        Initializes the Progress{T} with the specified callback.
        
        :param handler: A handler to invoke for each reported progress value.  This handler will be invoked in addition to any delegates registered with the ProgressChanged event. Depending on the System.Threading.SynchronizationContext instance captured by the Progress{T} at construction, it's possible that this handler instance could be invoked concurrently with itself.
        """
        ...

    def OnReport(self, value: System_Progress_T) -> None:
        """
        Reports a progress change.
        
        This method is protected.
        
        :param value: The value of the updated progress.
        """
        ...

    def Report(self, value: System_Progress_T) -> None:
        """
        Reports a progress change.
        
        :param value: The value of the updated progress.
        """
        ...


class IAsyncDisposable(metaclass=abc.ABCMeta):
    """Provides a mechanism for releasing unmanaged resources asynchronously."""

    def DisposeAsync(self) -> System.Threading.Tasks.ValueTask:
        """
        Performs application-defined tasks associated with freeing, releasing, or
        resetting unmanaged resources asynchronously.
        """
        ...


class ApplicationId(System.Object):
    """This class has no documentation."""

    @property
    def Culture(self) -> str:
        ...

    @property
    def Name(self) -> str:
        ...

    @property
    def ProcessorArchitecture(self) -> str:
        ...

    @property
    def Version(self) -> System.Version:
        ...

    @property
    def PublicKeyToken(self) -> typing.List[int]:
        ...

    def __init__(self, publicKeyToken: typing.List[int], name: str, version: System.Version, processorArchitecture: str, culture: str) -> None:
        ...

    def Copy(self) -> System.ApplicationId:
        ...

    def Equals(self, o: typing.Any) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    def ToString(self) -> str:
        ...


class LoaderOptimization(System.Enum):
    """This class has no documentation."""

    DisallowBindings = 4

    DomainMask = 3

    MultiDomain = 2

    MultiDomainHost = 3

    NotSpecified = 0

    SingleDomain = 1


class Half(System.IComparable[System_Half], System.ISpanFormattable, System.IEquatable[System_Half], System.Numerics.IBinaryFloatingPointIeee754[System_Half], System.IMinMaxValue[System_Half]):
    """This class has no documentation."""

    SignMask: int = ...

    SignShift: int = 15

    ShiftedSignMask: int = ...

    BiasedExponentMask: int = ...

    BiasedExponentShift: int = 10

    ShiftedBiasedExponentMask: int = ...

    TrailingSignificandMask: int = ...

    MinSign: int = 0

    MaxSign: int = 1

    MinBiasedExponent: int = ...

    MaxBiasedExponent: int = ...

    ExponentBias: int = 15

    MinExponent: int = -14

    MaxExponent: int = ...

    MinTrailingSignificand: int = ...

    MaxTrailingSignificand: int = ...

    Epsilon: System.Half

    PositiveInfinity: System.Half

    NegativeInfinity: System.Half

    NaN: System.Half

    MinValue: System.Half

    MaxValue: System.Half

    @property
    def _value(self) -> int:
        ...

    @property
    def BiasedExponent(self) -> int:
        ...

    @property
    def Exponent(self) -> int:
        ...

    @property
    def Significand(self) -> int:
        ...

    @property
    def TrailingSignificand(self) -> int:
        ...

    AdditiveIdentity: System.Half

    AllBitsSet: System.Half

    @property
    def value(self) -> System.Half:
        ...

    @value.setter
    def value(self, value: System.Half):
        ...

    @property
    def bits(self) -> int:
        ...

    @bits.setter
    def bits(self, value: int):
        ...

    @staticmethod
    def () -> System.Half:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        """
        Compares this object to another object, returning an integer that indicates the relationship.
        
        :returns: A value less than zero if this is less than , zero if this is equal to , or a value greater than zero if this is greater than .
        """
        ...

    @overload
    def CompareTo(self, other: System.Half) -> int:
        """
        Compares this object to another object, returning an integer that indicates the relationship.
        
        :returns: A value less than zero if this is less than , zero if this is equal to , or a value greater than zero if this is greater than .
        """
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        """Returns a value that indicates whether this instance is equal to a specified ."""
        ...

    @overload
    def Equals(self, other: System.Half) -> bool:
        """Returns a value that indicates whether this instance is equal to a specified  value."""
        ...

    def GetHashCode(self) -> int:
        """Serves as the default hash function."""
        ...

    @staticmethod
    def IsFinite(value: System.Half) -> bool:
        """Determines whether the specified value is finite (zero, subnormal, or normal)."""
        ...

    @staticmethod
    def IsInfinity(value: System.Half) -> bool:
        """Determines whether the specified value is infinite."""
        ...

    @staticmethod
    def IsNaN(value: System.Half) -> bool:
        """Determines whether the specified value is NaN."""
        ...

    @staticmethod
    def IsNegative(value: System.Half) -> bool:
        """Determines whether the specified value is negative."""
        ...

    @staticmethod
    def IsNegativeInfinity(value: System.Half) -> bool:
        """Determines whether the specified value is negative infinity."""
        ...

    @staticmethod
    def IsNormal(value: System.Half) -> bool:
        """Determines whether the specified value is normal."""
        ...

    @staticmethod
    def IsPositiveInfinity(value: System.Half) -> bool:
        """Determines whether the specified value is positive infinity."""
        ...

    @staticmethod
    def IsPow2(value: System.Half) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: System.Half) -> bool:
        """Determines whether the specified value is subnormal."""
        ...

    @staticmethod
    def Log2(value: System.Half) -> System.Half:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.Half:
        """
        Parses a Half from a string in the default parse style.
        
        :param s: The input to be parsed.
        :returns: The equivalent Half value representing the input string. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> System.Half:
        """
        Parses a Half from a string in the given NumberStyles.
        
        :param s: The input to be parsed.
        :param style: The NumberStyles used to parse the input.
        :returns: The equivalent Half value representing the input string. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.Half:
        """
        Parses a Half from a string and IFormatProvider.
        
        :param s: The input to be parsed.
        :param provider: A format provider.
        :returns: The equivalent Half value representing the input string. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> System.Half:
        """
        Parses a Half from a string with the given NumberStyles and IFormatProvider.
        
        :param s: The input to be parsed.
        :param style: The NumberStyles used to parse the input.
        :param provider: A format provider.
        :returns: The equivalent Half value representing the input string. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> System.Half:
        """
        Parses a Half from a ReadOnlySpan{Char} and IFormatProvider.
        
        :param s: The input to be parsed.
        :param style: The NumberStyles used to parse the input.
        :param provider: A format provider.
        :returns: The equivalent Half value representing the input string. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned.
        """
        ...

    @overload
    def ToString(self) -> str:
        """Returns a string representation of the current value."""
        ...

    @overload
    def ToString(self, format: str) -> str:
        """Returns a string representation of the current value using the specified ."""
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        """Returns a string representation of the current value with the specified ."""
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        """Returns a string representation of the current value using the specified  and ."""
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        """
        Tries to format the value of the current Half instance into the provided span of characters.
        
        :param destination: When this method returns, this instance's value formatted as a span of characters.
        :param charsWritten: When this method returns, the number of characters that were written in .
        :param format: A span containing the characters that represent a standard or custom format string that defines the acceptable format for .
        :param provider: An optional object that supplies culture-specific formatting information for .
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.Half]) -> typing.Union[bool, System.Half]:
        """
        Tries to parse a Half from a string in the default parse style.
        
        :param s: The input to be parsed.
        :param result: The equivalent Half value representing the input string if the parse was successful. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned. If the parse was unsuccessful, a default Half value is returned.
        :returns: true if the parse was successful, false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.Half]) -> typing.Union[bool, System.Half]:
        """
        Tries to parse a Half from a ReadOnlySpan{Char} in the default parse style.
        
        :param s: The input to be parsed.
        :param result: The equivalent Half value representing the input string if the parse was successful. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned. If the parse was unsuccessful, a default Half value is returned.
        :returns: true if the parse was successful, false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.Half]) -> typing.Union[bool, System.Half]:
        """
        Tries to parse a Half from a string with the given NumberStyles and IFormatProvider.
        
        :param s: The input to be parsed.
        :param style: The NumberStyles used to parse the input.
        :param provider: A format provider.
        :param result: The equivalent Half value representing the input string if the parse was successful. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned. If the parse was unsuccessful, a default Half value is returned.
        :returns: true if the parse was successful, false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.Half]) -> typing.Union[bool, System.Half]:
        """
        Tries to parse a Half from a ReadOnlySpan{Char} with the given NumberStyles and IFormatProvider.
        
        :param s: The input to be parsed.
        :param style: The NumberStyles used to parse the input.
        :param provider: A format provider.
        :param result: The equivalent Half value representing the input string if the parse was successful. If the input exceeds Half's range, a Half.PositiveInfinity or Half.NegativeInfinity is returned. If the parse was unsuccessful, a default Half value is returned.
        :returns: true if the parse was successful, false otherwise.
        """
        ...


class BitConverter(System.Object):
    """Converts base data types to an array of bytes, and an array of bytes to base data types."""

    IsLittleEndian: bool = True

    @staticmethod
    def DoubleToInt64Bits(value: float) -> int:
        """
        Converts the specified double-precision floating point number to a 64-bit signed integer.
        
        :param value: The number to convert.
        :returns: A 64-bit signed integer whose bits are identical to .
        """
        ...

    @staticmethod
    def DoubleToUInt64Bits(value: float) -> int:
        """
        Converts the specified double-precision floating point number to a 64-bit unsigned integer.
        
        :param value: The number to convert.
        :returns: A 64-bit unsigned integer whose bits are identical to .
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: bool) -> typing.List[int]:
        ...

    @staticmethod
    @overload
    def GetBytes(value: str) -> typing.List[int]:
        """
        Returns the specified Unicode character value as a byte array.
        
        :param value: A Char value.
        :returns: An array of bytes with length 2.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: int) -> typing.List[int]:
        """
        Returns the specified 16-bit signed integer value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 2.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: int) -> typing.List[int]:
        """
        Returns the specified 32-bit signed integer value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 4.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: int) -> typing.List[int]:
        """
        Returns the specified 64-bit signed integer value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 8.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: int) -> typing.List[int]:
        """
        Returns the specified 16-bit unsigned integer value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 2.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: int) -> typing.List[int]:
        """
        Returns the specified 32-bit unsigned integer value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 4.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: int) -> typing.List[int]:
        """
        Returns the specified 64-bit signed integer value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 8.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: System.Half) -> typing.List[int]:
        """
        Returns the specified half-precision floating point value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 2.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: float) -> typing.List[int]:
        """
        Returns the specified single-precision floating point value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 4.
        """
        ...

    @staticmethod
    @overload
    def GetBytes(value: float) -> typing.List[int]:
        """
        Returns the specified double-precision floating point value as an array of bytes.
        
        :param value: The number to convert.
        :returns: An array of bytes with length 8.
        """
        ...

    @staticmethod
    def HalfToInt16Bits(value: System.Half) -> int:
        """
        Converts the specified half-precision floating point number to a 16-bit signed integer.
        
        :param value: The number to convert.
        :returns: A 16-bit signed integer whose bits are identical to .
        """
        ...

    @staticmethod
    def HalfToUInt16Bits(value: System.Half) -> int:
        """
        Converts the specified half-precision floating point number to a 16-bit unsigned integer.
        
        :param value: The number to convert.
        :returns: A 16-bit unsigned integer whose bits are identical to .
        """
        ...

    @staticmethod
    def Int16BitsToHalf(value: int) -> System.Half:
        """
        Converts the specified 16-bit signed integer to a half-precision floating point number.
        
        :param value: The number to convert.
        :returns: A half-precision floating point number whose bits are identical to .
        """
        ...

    @staticmethod
    def Int32BitsToSingle(value: int) -> float:
        """
        Converts the specified 32-bit signed integer to a single-precision floating point number.
        
        :param value: The number to convert.
        :returns: A single-precision floating point number whose bits are identical to .
        """
        ...

    @staticmethod
    def Int64BitsToDouble(value: int) -> float:
        """
        Converts the specified 64-bit signed integer to a double-precision floating point number.
        
        :param value: The number to convert.
        :returns: A double-precision floating point number whose bits are identical to .
        """
        ...

    @staticmethod
    def SingleToInt32Bits(value: float) -> int:
        """
        Converts the specified single-precision floating point number to a 32-bit signed integer.
        
        :param value: The number to convert.
        :returns: A 32-bit signed integer whose bits are identical to .
        """
        ...

    @staticmethod
    def SingleToUInt32Bits(value: float) -> int:
        """
        Converts the specified single-precision floating point number to a 32-bit unsigned integer.
        
        :param value: The number to convert.
        :returns: A 32-bit unsigned integer whose bits are identical to .
        """
        ...

    @staticmethod
    @overload
    def ToBoolean(value: typing.List[int], startIndex: int) -> bool:
        """
        Returns a Boolean value converted from two bytes at a specified position in a byte array.
        
        :param value: A byte array.
        :param startIndex: The index of the byte within .
        :returns: true if the byte at  is nonzero; otherwise false.
        """
        ...

    @staticmethod
    @overload
    def ToBoolean(value: System.ReadOnlySpan[int]) -> bool:
        """
        Converts a read-only byte span into a Boolean value.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A Boolean representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToChar(value: typing.List[int], startIndex: int) -> str:
        """
        Returns a Unicode character converted from two bytes at a specified position in a byte array.
        
        :param value: An array.
        :param startIndex: The starting position within .
        :returns: A character formed by two bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToChar(value: System.ReadOnlySpan[int]) -> str:
        """
        Converts a read-only byte span into a character.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A character representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToDouble(value: typing.List[int], startIndex: int) -> float:
        """
        Returns a double-precision floating point number converted from four bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A double-precision floating point number formed by eight bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToDouble(value: System.ReadOnlySpan[int]) -> float:
        """
        Converts a read-only byte span into a double-precision floating-point value.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A double-precision floating-point value representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToHalf(value: typing.List[int], startIndex: int) -> System.Half:
        """
        Returns a half-precision floating point number converted from two bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A half-precision floating point number signed integer formed by two bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToHalf(value: System.ReadOnlySpan[int]) -> System.Half:
        """
        Converts a read-only byte span into a half-precision floating-point value.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A half-precision floating-point value representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToInt16(value: typing.List[int], startIndex: int) -> int:
        """
        Returns a 16-bit signed integer converted from two bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A 16-bit signed integer formed by two bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToInt16(value: System.ReadOnlySpan[int]) -> int:
        """
        Converts a read-only byte span into a 16-bit signed integer.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A 16-bit signed integer representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToInt32(value: typing.List[int], startIndex: int) -> int:
        """
        Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A 32-bit signed integer formed by four bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToInt32(value: System.ReadOnlySpan[int]) -> int:
        """
        Converts a read-only byte span into a 32-bit signed integer.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A 32-bit signed integer representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToInt64(value: typing.List[int], startIndex: int) -> int:
        """
        Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A 64-bit signed integer formed by eight bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToInt64(value: System.ReadOnlySpan[int]) -> int:
        """
        Converts a read-only byte span into a 64-bit signed integer.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A 64-bit signed integer representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToSingle(value: typing.List[int], startIndex: int) -> float:
        """
        Returns a single-precision floating point number converted from four bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A single-precision floating point number formed by four bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToSingle(value: System.ReadOnlySpan[int]) -> float:
        """
        Converts a read-only byte span into a single-precision floating-point value.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A single-precision floating-point value representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToString(value: typing.List[int], startIndex: int, length: int) -> str:
        """
        Converts the numeric value of each element of a specified array of bytes
        to its equivalent hexadecimal string representation.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :param length: The number of array elements in  to convert.
        :returns: A string of hexadecimal pairs separated by hyphens, where each pair represents the corresponding element in a subarray of ; for example, "7F-2C-4A-00".
        """
        ...

    @staticmethod
    @overload
    def ToString(value: typing.List[int]) -> str:
        """
        Converts the numeric value of each element of a specified array of bytes
        to its equivalent hexadecimal string representation.
        
        :param value: An array of bytes.
        :returns: A string of hexadecimal pairs separated by hyphens, where each pair represents the corresponding element in ; for example, "7F-2C-4A-00".
        """
        ...

    @staticmethod
    @overload
    def ToString(value: typing.List[int], startIndex: int) -> str:
        """
        Converts the numeric value of each element of a specified array of bytes
        to its equivalent hexadecimal string representation.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A string of hexadecimal pairs separated by hyphens, where each pair represents the corresponding element in a subarray of ; for example, "7F-2C-4A-00".
        """
        ...

    @staticmethod
    @overload
    def ToUInt16(value: typing.List[int], startIndex: int) -> int:
        """
        Returns a 16-bit unsigned integer converted from two bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A 16-bit unsigned integer formed by two bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToUInt16(value: System.ReadOnlySpan[int]) -> int:
        """
        Converts a read-only byte span into a 16-bit unsigned integer.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A 16-bit unsigned integer representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToUInt32(value: typing.List[int], startIndex: int) -> int:
        """
        Returns a 32-bit unsigned integer converted from four bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A 32-bit unsigned integer formed by four bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToUInt32(value: System.ReadOnlySpan[int]) -> int:
        """
        Converts a read-only byte span into a 32-bit unsigned integer.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A 32-bit unsigned integer representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def ToUInt64(value: typing.List[int], startIndex: int) -> int:
        """
        Returns a 64-bit unsigned integer converted from four bytes at a specified position in a byte array.
        
        :param value: An array of bytes.
        :param startIndex: The starting position within .
        :returns: A 64-bit unsigned integer formed by eight bytes beginning at .
        """
        ...

    @staticmethod
    @overload
    def ToUInt64(value: System.ReadOnlySpan[int]) -> int:
        """
        Converts a read-only byte span into a 64-bit unsigned integer.
        
        :param value: A read-only span containing the bytes to convert.
        :returns: A 64-bit unsigned integer representing the converted bytes.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: bool) -> bool:
        """
        Converts a Boolean into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted Boolean.
        :param value: The Boolean to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: str) -> bool:
        """
        Converts a character into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted character.
        :param value: The character to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: int) -> bool:
        """
        Converts a 16-bit signed integer into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted 16-bit signed integer.
        :param value: The 16-bit signed integer to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: int) -> bool:
        """
        Converts a 32-bit signed integer into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted 32-bit signed integer.
        :param value: The 32-bit signed integer to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: int) -> bool:
        """
        Converts a 64-bit signed integer into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted 64-bit signed integer.
        :param value: The 64-bit signed integer to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: int) -> bool:
        """
        Converts a 16-bit unsigned integer into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted 16-bit unsigned integer.
        :param value: The 16-bit unsigned integer to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: int) -> bool:
        """
        Converts a 32-bit unsigned integer into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted 32-bit unsigned integer.
        :param value: The 32-bit unsigned integer to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: int) -> bool:
        """
        Converts a 64-bit unsigned integer into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted 64-bit unsigned integer.
        :param value: The 64-bit unsigned integer to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: System.Half) -> bool:
        """
        Converts a half-precision floating-point value into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted half-precision floating-point value.
        :param value: The half-precision floating-point value to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: float) -> bool:
        """
        Converts a single-precision floating-point value into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted single-precision floating-point value.
        :param value: The single-precision floating-point value to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    @overload
    def TryWriteBytes(destination: System.Span[int], value: float) -> bool:
        """
        Converts a double-precision floating-point value into a span of bytes.
        
        :param destination: When this method returns, the bytes representing the converted double-precision floating-point value.
        :param value: The double-precision floating-point value to convert.
        :returns: true if the conversion was successful; false otherwise.
        """
        ...

    @staticmethod
    def UInt16BitsToHalf(value: int) -> System.Half:
        """
        Converts the specified 16-bit unsigned integer to a half-precision floating point number.
        
        :param value: The number to convert.
        :returns: A half-precision floating point number whose bits are identical to .
        """
        ...

    @staticmethod
    def UInt32BitsToSingle(value: int) -> float:
        """
        Converts the specified 32-bit unsigned integer to a single-precision floating point number.
        
        :param value: The number to convert.
        :returns: A single-precision floating point number whose bits are identical to .
        """
        ...

    @staticmethod
    def UInt64BitsToDouble(value: int) -> float:
        """
        Converts the specified 64-bit unsigned integer to a double-precision floating point number.
        
        :param value: The number to convert.
        :returns: A double-precision floating point number whose bits are identical to .
        """
        ...


class Buffer(System.Object):
    """This class has no documentation."""

    @staticmethod
    def BlockCopy(src: System.Array, srcOffset: int, dst: System.Array, dstOffset: int, count: int) -> None:
        ...

    @staticmethod
    def ByteLength(array: System.Array) -> int:
        ...

    @staticmethod
    def GetByte(array: System.Array, index: int) -> int:
        ...

    @staticmethod
    @overload
    def MemoryCopy(source: typing.Any, destination: typing.Any, destinationSizeInBytes: int, sourceBytesToCopy: int) -> None:
        ...

    @staticmethod
    @overload
    def MemoryCopy(source: typing.Any, destination: typing.Any, destinationSizeInBytes: int, sourceBytesToCopy: int) -> None:
        ...

    @staticmethod
    def SetByte(array: System.Array, index: int, value: int) -> None:
        ...


class DllNotFoundException(System.TypeLoadException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class Single(System.IComparable[float], System.IConvertible, System.ISpanFormattable, System.IEquatable[float], System.Numerics.IBinaryFloatingPointIeee754[float], System.IMinMaxValue[float]):
    """This class has no documentation."""

    MinValue: float = ...

    MaxValue: float = ...

    Epsilon: float = ...

    NegativeInfinity: float = ...

    PositiveInfinity: float = ...

    NaN: float = ...

    AdditiveIdentity: float = ...
    """Represents the additive identity (0)."""

    MultiplicativeIdentity: float = ...
    """Represents the multiplicative identity (1)."""

    One: float = ...
    """Represents the number one (1)."""

    Zero: float = ...
    """Represents the number zero (0)."""

    NegativeOne: float = ...
    """Represents the number negative one (-1)."""

    NegativeZero: float = ...
    """Represents the number negative zero (-0)."""

    E: float = ...
    """Represents the natural logarithmic base, specified by the constant, e."""

    Pi: float = ...
    """Represents the ratio of the circumference of a circle to its diameter, specified by the constant, ."""

    Tau: float = ...
    """Represents the number of radians in one turn, specified by the constant, ."""

    SignMask: int = ...

    SignShift: int = 31

    ShiftedSignMask: int = ...

    BiasedExponentMask: int = ...

    BiasedExponentShift: int = 23

    ShiftedBiasedExponentMask: int = ...

    TrailingSignificandMask: int = ...

    MinSign: int = 0

    MaxSign: int = 1

    MinBiasedExponent: int = ...

    MaxBiasedExponent: int = ...

    ExponentBias: int = 127

    MinExponent: int = -126

    MaxExponent: int = ...

    MinTrailingSignificand: int = ...

    MaxTrailingSignificand: int = ...

    @property
    def BiasedExponent(self) -> int:
        ...

    @property
    def Exponent(self) -> int:
        ...

    @property
    def Significand(self) -> int:
        ...

    @property
    def TrailingSignificand(self) -> int:
        ...

    AllBitsSet: float

    @property
    def value(self) -> float:
        ...

    @value.setter
    def value(self, value: float):
        ...

    @property
    def bits(self) -> int:
        ...

    @bits.setter
    def bits(self, value: int):
        ...

    @staticmethod
    def () -> float:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: float) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: float) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsFinite(f: float) -> bool:
        """Determines whether the specified value is finite (zero, subnormal, or normal)."""
        ...

    @staticmethod
    def IsInfinity(f: float) -> bool:
        """Determines whether the specified value is infinite."""
        ...

    @staticmethod
    def IsNaN(f: float) -> bool:
        """Determines whether the specified value is NaN."""
        ...

    @staticmethod
    def IsNegative(f: float) -> bool:
        """Determines whether the specified value is negative."""
        ...

    @staticmethod
    def IsNegativeInfinity(f: float) -> bool:
        """Determines whether the specified value is negative infinity."""
        ...

    @staticmethod
    def IsNormal(f: float) -> bool:
        """Determines whether the specified value is normal."""
        ...

    @staticmethod
    def IsPositiveInfinity(f: float) -> bool:
        """Determines whether the specified value is positive infinity."""
        ...

    @staticmethod
    def IsPow2(value: float) -> bool:
        ...

    @staticmethod
    def IsSubnormal(f: float) -> bool:
        """Determines whether the specified value is subnormal."""
        ...

    @staticmethod
    def Log2(value: float) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> float:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> float:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[float]) -> typing.Union[bool, float]:
        ...


class Char(System.IConvertible, System.IBinaryInteger[str], System.IMinMaxValue[str], System.IUnsignedNumber[str]):
    """This class has no documentation."""

    MaxValue: str = ...

    MinValue: str = ...

    UNICODE_PLANE00_END: int = ...

    UNICODE_PLANE01_START: int = ...

    UNICODE_PLANE16_END: int = ...

    AdditiveIdentity: str

    AllBitsSet: str

    @property
    def value(self) -> str:
        ...

    @value.setter
    def value(self, value: str):
        ...

    MultiplicativeIdentity: str

    One: str

    Radix: int

    Zero: str

    @staticmethod
    def () -> str:
        ...

    @staticmethod
    def Abs(value: str) -> str:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: str) -> int:
        ...

    @staticmethod
    def ConvertFromUtf32(utf32: int) -> str:
        ...

    @staticmethod
    @overload
    def ConvertToUtf32(highSurrogate: str, lowSurrogate: str) -> int:
        ...

    @staticmethod
    @overload
    def ConvertToUtf32(s: str, index: int) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: str) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    @overload
    def GetNumericValue(c: str) -> float:
        ...

    @staticmethod
    @overload
    def GetNumericValue(s: str, index: int) -> float:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    @overload
    def GetUnicodeCategory(c: str) -> int:
        """:returns: This method returns the int value of a member of the System.Globalization.UnicodeCategory enum."""
        ...

    @staticmethod
    @overload
    def GetUnicodeCategory(s: str, index: int) -> int:
        """:returns: This method returns the int value of a member of the System.Globalization.UnicodeCategory enum."""
        ...

    @staticmethod
    def IsAscii(c: str) -> bool:
        ...

    @staticmethod
    def IsAsciiDigit(c: str) -> bool:
        """
        Indicates whether a character is categorized as an ASCII digit.
        
        :param c: The character to evaluate.
        :returns: true if  is an ASCII digit; otherwise, false.
        """
        ...

    @staticmethod
    def IsAsciiHexDigit(c: str) -> bool:
        """
        Indicates whether a character is categorized as an ASCII hexadecimal digit.
        
        :param c: The character to evaluate.
        :returns: true if  is a hexadecimal digit; otherwise, false.
        """
        ...

    @staticmethod
    def IsAsciiHexDigitLower(c: str) -> bool:
        """
        Indicates whether a character is categorized as an ASCII lower-case hexadecimal digit.
        
        :param c: The character to evaluate.
        :returns: true if  is a lower-case hexadecimal digit; otherwise, false.
        """
        ...

    @staticmethod
    def IsAsciiHexDigitUpper(c: str) -> bool:
        """
        Indicates whether a character is categorized as an ASCII upper-case hexadecimal digit.
        
        :param c: The character to evaluate.
        :returns: true if  is a hexadecimal digit; otherwise, false.
        """
        ...

    @staticmethod
    def IsAsciiLetter(c: str) -> bool:
        ...

    @staticmethod
    def IsAsciiLetterLower(c: str) -> bool:
        """
        Indicates whether a character is categorized as a lowercase ASCII letter.
        
        :param c: The character to evaluate.
        :returns: true if  is a lowercase ASCII letter; otherwise, false.
        """
        ...

    @staticmethod
    def IsAsciiLetterOrDigit(c: str) -> bool:
        """
        Indicates whether a character is categorized as an ASCII letter or digit.
        
        :param c: The character to evaluate.
        :returns: true if  is an ASCII letter or digit; otherwise, false.
        """
        ...

    @staticmethod
    def IsAsciiLetterUpper(c: str) -> bool:
        """
        Indicates whether a character is categorized as an uppercase ASCII letter.
        
        :param c: The character to evaluate.
        :returns: true if  is a lowercase ASCII letter; otherwise, false.
        """
        ...

    @staticmethod
    def IsBetween(c: str, minInclusive: str, maxInclusive: str) -> bool:
        """
        Indicates whether a character is within the specified inclusive range.
        
        :param c: The character to evaluate.
        :param minInclusive: The lower bound, inclusive.
        :param maxInclusive: The upper bound, inclusive.
        :returns: true if  is within the specified range; otherwise, false.
        """
        ...

    @staticmethod
    def IsCanonical(value: str) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsControl(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsControl(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsDigit(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsDigit(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: str) -> bool:
        ...

    @staticmethod
    def IsFinite(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsHighSurrogate(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsHighSurrogate(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: str) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: str) -> bool:
        ...

    @staticmethod
    def IsInteger(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsLetter(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsLetter(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsLetterOrDigit(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsLetterOrDigit(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsLower(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsLower(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsLowSurrogate(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsLowSurrogate(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: str) -> bool:
        ...

    @staticmethod
    def IsNegative(value: str) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: str) -> bool:
        ...

    @staticmethod
    def IsNormal(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsNumber(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsNumber(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: str) -> bool:
        ...

    @staticmethod
    def IsPositive(value: str) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: str) -> bool:
        ...

    @staticmethod
    def IsPow2(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsPunctuation(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsPunctuation(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsSeparator(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsSeparator(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsSurrogate(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsSurrogate(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsSurrogatePair(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsSurrogatePair(highSurrogate: str, lowSurrogate: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsSymbol(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsSymbol(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsUpper(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsUpper(s: str, index: int) -> bool:
        ...

    @staticmethod
    @overload
    def IsWhiteSpace(c: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsWhiteSpace(s: str, index: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: str) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: str) -> str:
        ...

    @staticmethod
    def Log2(value: str) -> str:
        ...

    @staticmethod
    def MaxMagnitude(x: str, y: str) -> str:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: str, y: str) -> str:
        ...

    @staticmethod
    def MinMagnitude(x: str, y: str) -> str:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: str, y: str) -> str:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> str:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    def PopCount(value: str) -> str:
        ...

    @staticmethod
    def RotateLeft(value: str, rotateAmount: int) -> str:
        ...

    @staticmethod
    def RotateRight(value: str, rotateAmount: int) -> str:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToLower(c: str, culture: System.Globalization.CultureInfo) -> str:
        ...

    @staticmethod
    @overload
    def ToLower(c: str) -> str:
        ...

    @staticmethod
    def ToLowerInvariant(c: str) -> str:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @staticmethod
    @overload
    def ToString(c: str) -> str:
        ...

    @overload
    def ToString(self, format: str, formatProvider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def ToUpper(c: str, culture: System.Globalization.CultureInfo) -> str:
        ...

    @staticmethod
    @overload
    def ToUpper(c: str) -> str:
        ...

    @staticmethod
    def ToUpperInvariant(c: str) -> str:
        ...

    @staticmethod
    def TrailingZeroCount(value: str) -> str:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromChecked_TOther, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromSaturating_TOther, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_Char_System_Numerics_INumberBase<System_Char>_TryConvertFromTruncating_TOther, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    def TryConvertToChecked(value: str, result: typing.Optional[System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: str, result: typing.Optional[System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: str, result: typing.Optional[System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_Char_System_Numerics_INumberBase<System_Char>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[str]) -> typing.Union[bool, str]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class FormatException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class HashCode:
    """This class has no documentation."""

    @overload
    def Add(self, value: System_HashCode_Add_T) -> None:
        ...

    @overload
    def Add(self, value: System_HashCode_Add_T, comparer: System.Collections.Generic.IEqualityComparer[System_HashCode_Add_T]) -> None:
        ...

    def AddBytes(self, value: System.ReadOnlySpan[int]) -> None:
        """
        Adds a span of bytes to the hash code.
        
        :param value: The span.
        """
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2, value3: System_HashCode_Combine_T3) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2, value3: System_HashCode_Combine_T3, value4: System_HashCode_Combine_T4) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2, value3: System_HashCode_Combine_T3, value4: System_HashCode_Combine_T4, value5: System_HashCode_Combine_T5) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2, value3: System_HashCode_Combine_T3, value4: System_HashCode_Combine_T4, value5: System_HashCode_Combine_T5, value6: System_HashCode_Combine_T6) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2, value3: System_HashCode_Combine_T3, value4: System_HashCode_Combine_T4, value5: System_HashCode_Combine_T5, value6: System_HashCode_Combine_T6, value7: System_HashCode_Combine_T7) -> int:
        ...

    @staticmethod
    @overload
    def Combine(value1: System_HashCode_Combine_T1, value2: System_HashCode_Combine_T2, value3: System_HashCode_Combine_T3, value4: System_HashCode_Combine_T4, value5: System_HashCode_Combine_T5, value6: System_HashCode_Combine_T6, value7: System_HashCode_Combine_T7, value8: System_HashCode_Combine_T8) -> int:
        ...

    def Equals(self, obj: typing.Any) -> bool:
        """HashCode is a mutable struct and should not be compared with other HashCodes."""
        warnings.warn("HashCode is a mutable struct and should not be compared with other HashCodes.", DeprecationWarning)

    def GetHashCode(self) -> int:
        """HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code."""
        warnings.warn("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", DeprecationWarning)

    def ToHashCode(self) -> int:
        ...


class InvalidOperationException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class ObjectDisposedException(System.InvalidOperationException):
    """The exception that is thrown when accessing an object that was disposed."""

    @property
    def Message(self) -> str:
        """Gets the text for the message for this exception."""
        ...

    @property
    def ObjectName(self) -> str:
        ...

    @overload
    def __init__(self, objectName: str) -> None:
        ...

    @overload
    def __init__(self, objectName: str, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    @staticmethod
    @overload
    def ThrowIf(condition: bool, instance: typing.Any) -> None:
        """
        Throws an ObjectDisposedException if the specified  is true.
        
        :param condition: The condition to evaluate.
        :param instance: The object whose type's full name should be included in any resulting ObjectDisposedException.
        """
        ...

    @staticmethod
    @overload
    def ThrowIf(condition: bool, type: typing.Type) -> None:
        """
        Throws an ObjectDisposedException if the specified  is true.
        
        :param condition: The condition to evaluate.
        :param type: The type whose full name should be included in any resulting ObjectDisposedException.
        """
        ...


class LocalDataStoreSlot(System.Object):
    """This class has no documentation."""

    @property
    def Data(self) -> System.Threading.ThreadLocal[System.Object]:
        ...

    @Data.setter
    def Data(self, value: System.Threading.ThreadLocal[System.Object]):
        ...


class UInt64(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.IUnsignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = ...

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_UInt64_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_UInt64_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_UInt64_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_UInt64_System_Numerics_INumberBase<System_UInt64>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class Delegate(System.Object, System.ICloneable, System.Runtime.Serialization.ISerializable, metaclass=abc.ABCMeta):
    """This class has no documentation."""

    @property
    def Method(self) -> System.Reflection.MethodInfo:
        ...

    @property
    def Target(self) -> System.Object:
        ...

    @overload
    def __init__(self, target: typing.Any, method: str) -> None:
        """This method is protected."""
        ...

    @overload
    def __init__(self, target: typing.Type, method: str) -> None:
        """This method is protected."""
        ...

    def Clone(self) -> System.Object:
        ...

    @staticmethod
    @overload
    def Combine(a: System.Delegate, b: System.Delegate) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def Combine(*delegates: System.Delegate) -> System.Delegate:
        ...

    def CombineImpl(self, d: System.Delegate) -> System.Delegate:
        """This method is protected."""
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, firstArgument: typing.Any, method: System.Reflection.MethodInfo) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, method: System.Reflection.MethodInfo) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, target: typing.Any, method: str) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, target: typing.Any, method: str, ignoreCase: bool) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, target: typing.Type, method: str) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, target: typing.Type, method: str, ignoreCase: bool) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, firstArgument: typing.Any, method: System.Reflection.MethodInfo, throwOnBindFailure: bool) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, method: System.Reflection.MethodInfo, throwOnBindFailure: bool) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, target: typing.Any, method: str, ignoreCase: bool, throwOnBindFailure: bool) -> System.Delegate:
        ...

    @staticmethod
    @overload
    def CreateDelegate(type: typing.Type, target: typing.Type, method: str, ignoreCase: bool, throwOnBindFailure: bool) -> System.Delegate:
        ...

    def DynamicInvoke(self, *args: typing.Any) -> System.Object:
        ...

    def DynamicInvokeImpl(self, args: typing.List[System.Object]) -> System.Object:
        """This method is protected."""
        ...

    def Equals(self, obj: typing.Any) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetInvocationList(self) -> typing.List[System.Delegate]:
        ...

    def GetMethodImpl(self) -> System.Reflection.MethodInfo:
        """This method is protected."""
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...

    @staticmethod
    def Remove(source: System.Delegate, value: System.Delegate) -> System.Delegate:
        ...

    @staticmethod
    def RemoveAll(source: System.Delegate, value: System.Delegate) -> System.Delegate:
        ...

    def RemoveImpl(self, d: System.Delegate) -> System.Delegate:
        """This method is protected."""
        ...


class NotImplementedException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class TypedReference:
    """This class has no documentation."""

    @property
    def IsNull(self) -> bool:
        ...

    def Equals(self, o: typing.Any) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    def GetTargetType(value: System.TypedReference) -> typing.Type:
        ...

    @staticmethod
    def MakeTypedReference(target: typing.Any, flds: typing.List[System.Reflection.FieldInfo]) -> System.TypedReference:
        ...

    @staticmethod
    def SetTypedReference(target: System.TypedReference, value: typing.Any) -> None:
        ...

    @staticmethod
    def TargetTypeToken(value: System.TypedReference) -> System.RuntimeTypeHandle:
        ...

    @staticmethod
    def ToObject(value: System.TypedReference) -> System.Object:
        ...


class OutOfMemoryException(System.SystemException):
    """The exception class for OOM."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class InsufficientMemoryException(System.OutOfMemoryException):
    """
    Purpose: The exception class for running out of memory
    but most likely in a non-fatal way that shouldn't
    be affected by escalation policy.  Use this for cases
    like MemoryFailPoint or a TryAllocate method, where you
    expect OOM's with no shared state corruption and you
    want to recover from these errors.
    """

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...


class InsufficientExecutionStackException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...


class DateOnly(System.IComparable[System_DateOnly], System.IEquatable[System_DateOnly], System.ISpanFormattable, System.ISpanParsable[System_DateOnly]):
    """Represents dates with values ranging from January 1, 0001 Anno Domini (Common Era) through December 31, 9999 A.D. (C.E.) in the Gregorian calendar."""

    MinValue: System.DateOnly
    """Gets the earliest possible date that can be created."""

    MaxValue: System.DateOnly
    """Gets the latest possible date that can be created."""

    @property
    def Year(self) -> int:
        """Gets the year component of the date represented by this instance."""
        ...

    @property
    def Month(self) -> int:
        """Gets the month component of the date represented by this instance."""
        ...

    @property
    def Day(self) -> int:
        """Gets the day component of the date represented by this instance."""
        ...

    @property
    def DayOfWeek(self) -> int:
        """
        Gets the day of the week represented by this instance.
        
        This property contains the int value of a member of the System.DayOfWeek enum.
        """
        ...

    @property
    def DayOfYear(self) -> int:
        """Gets the day of the year represented by this instance."""
        ...

    @property
    def DayNumber(self) -> int:
        """Gets the number of days since January 1, 0001 in the Proleptic Gregorian calendar represented by this instance."""
        ...

    @overload
    def __init__(self, year: int, month: int, day: int) -> None:
        """
        Creates a new instance of the DateOnly structure to the specified year, month, and day.
        
        :param year: The year (1 through 9999).
        :param month: The month (1 through 12).
        :param day: The day (1 through the number of days in ).
        """
        ...

    @overload
    def __init__(self, year: int, month: int, day: int, calendar: System.Globalization.Calendar) -> None:
        """
        Creates a new instance of the DateOnly structure to the specified year, month, and day for the specified calendar.
        
        :param year: The year (1 through the number of years in calendar).
        :param month: The month (1 through the number of months in calendar).
        :param day: The day (1 through the number of days in ).
        :param calendar: The calendar that is used to interpret year, month, and day..
        """
        ...

    def AddDays(self, value: int) -> System.DateOnly:
        """
        Adds the specified number of days to the value of this instance.
        
        :param value: The number of days to add. To subtract days, specify a negative number.
        :returns: An instance whose value is the sum of the date represented by this instance and the number of days represented by value.
        """
        ...

    def AddMonths(self, value: int) -> System.DateOnly:
        """
        Adds the specified number of months to the value of this instance.
        
        :param value: A number of months. The months parameter can be negative or positive.
        :returns: An object whose value is the sum of the date represented by this instance and months.
        """
        ...

    def AddYears(self, value: int) -> System.DateOnly:
        """
        Adds the specified number of years to the value of this instance.
        
        :param value: A number of years. The value parameter can be negative or positive.
        :returns: An object whose value is the sum of the date represented by this instance and the number of years represented by value.
        """
        ...

    @overload
    def CompareTo(self, value: System.DateOnly) -> int:
        """
        Compares the value of this instance to a specified DateOnly value and returns an integer that indicates whether this instance is earlier than, the same as, or later than the specified DateTime value.
        
        :param value: The object to compare to the current instance.
        :returns: Less than zero if this instance is earlier than value. Greater than zero if this instance is later than value. Zero if this instance is the same as value.
        """
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        """
        Compares the value of this instance to a specified object that contains a specified DateOnly value, and returns an integer that indicates whether this instance is earlier than, the same as, or later than the specified DateOnly value.
        
        :param value: A boxed object to compare, or null.
        :returns: Less than zero if this instance is earlier than value. Greater than zero if this instance is later than value. Zero if this instance is the same as value.
        """
        ...

    @overload
    def Equals(self, value: System.DateOnly) -> bool:
        """
        Returns a value indicating whether the value of this instance is equal to the value of the specified DateOnly instance.
        
        :param value: The object to compare to this instance.
        :returns: true if the value parameter equals the value of this instance; otherwise, false.
        """
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        """
        Returns a value indicating whether this instance is equal to a specified object.
        
        :param value: The object to compare to this instance.
        :returns: true if value is an instance of DateOnly and equals the value of this instance; otherwise, false.
        """
        ...

    @staticmethod
    def FromDateTime(dateTime: typing.Union[datetime.datetime, datetime.date]) -> System.DateOnly:
        """
        Returns a DateOnly instance that is set to the date part of the specified dateTime.
        
        :param dateTime: The DateTime instance.
        :returns: The DateOnly instance composed of the date part of the specified input time dateTime instance.
        """
        ...

    @staticmethod
    def FromDayNumber(dayNumber: int) -> System.DateOnly:
        """
        Creates a new instance of the DateOnly structure to the specified number of days.
        
        :param dayNumber: The number of days since January 1, 0001 in the Proleptic Gregorian calendar.
        """
        ...

    def GetHashCode(self) -> int:
        """
        Returns the hash code for this instance.
        
        :returns: A 32-bit signed integer hash code.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider = ..., style: System.Globalization.DateTimeStyles = ...) -> System.DateOnly:
        """
        Converts a memory span that contains string representation of a date to its DateOnly equivalent by using culture-specific format information and a formatting style.
        
        :param s: The memory span that contains the string to parse.
        :param provider: An object that supplies culture-specific format information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the date contained in s, as specified by provider and styles.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.DateOnly:
        """
        Converts a string that contains string representation of a date to its DateOnly equivalent by using the conventions of the current culture.
        
        :param s: The string that contains the string to parse.
        :returns: An object that is equivalent to the date contained in s.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.DateOnly:
        """
        Converts a string that contains string representation of a date to its DateOnly equivalent by using culture-specific format information and a formatting style.
        
        :param s: The string that contains the string to parse.
        :param provider: An object that supplies culture-specific format information about s.
        :param style: A bitwise combination of the enumeration values that indicates the style elements that can be present in s for the parse operation to succeed, and that defines how to interpret the parsed date. A typical value to specify is None.
        :returns: An object that is equivalent to the date contained in s, as specified by provider and styles.
        """
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.DateOnly:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> System.DateOnly:
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], provider: System.IFormatProvider = ..., style: System.Globalization.DateTimeStyles = ...) -> System.DateOnly:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a date to convert.
        :param format: A span containing the characters that represent a format specifier that defines the required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the date contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str]) -> System.DateOnly:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified array of formats.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a date to convert.
        :param formats: An array of allowable formats of s.
        :returns: An object that is equivalent to the date contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.DateOnly:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified array of formats, culture-specific format information, and style.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a date to convert.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the date contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, format: str) -> System.DateOnly:
        """
        Converts the specified string representation of a date to its DateOnly equivalent using the specified format.
        The format of the string representation must match the specified format exactly or an exception is thrown.
        
        :param s: A string containing the characters that represent a date to convert.
        :param format: A string that represent a format specifier that defines the required format of s.
        :returns: An object that is equivalent to the date contained in s, as specified by format.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, format: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.DateOnly:
        """
        Converts the specified string representation of a date to its DateOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly or an exception is thrown.
        
        :param s: A string containing the characters that represent a date to convert.
        :param format: A string containing the characters that represent a format specifier that defines the required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of the enumeration values that provides additional information about s, about style elements that may be present in s, or about the conversion from s to a DateOnly value. A typical value to specify is None.
        :returns: An object that is equivalent to the date contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, formats: typing.List[str]) -> System.DateOnly:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified array of formats.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A span containing the characters that represent a date to convert.
        :param formats: An array of allowable formats of s.
        :returns: An object that is equivalent to the date contained in s, as specified by format, provider, and style.
        """
        ...

    @staticmethod
    @overload
    def ParseExact(s: str, formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles = ...) -> System.DateOnly:
        """
        Converts the specified string representation of a date to its DateOnly equivalent using the specified array of formats, culture-specific format information, and style.
        The format of the string representation must match at least one of the specified formats exactly or an exception is thrown.
        
        :param s: A string containing the characters that represent a date to convert.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :returns: An object that is equivalent to the date contained in s, as specified by format, provider, and style.
        """
        ...

    @overload
    def ToDateTime(self, time: System.TimeOnly) -> datetime.datetime:
        """
        Returns a DateTime that is set to the date of this DateOnly instance and the time of specified input time.
        
        :param time: The time of the day.
        :returns: The DateTime instance composed of the date of the current DateOnly instance and the time specified by the input time.
        """
        ...

    @overload
    def ToDateTime(self, time: System.TimeOnly, kind: System.DateTimeKind) -> datetime.datetime:
        """
        Returns a DateTime instance with the specified input kind that is set to the date of this DateOnly instance and the time of specified input time.
        
        :param time: The time of the day.
        :param kind: One of the enumeration values that indicates whether ticks specifies a local time, Coordinated Universal Time (UTC), or neither.
        :returns: The DateTime instance composed of the date of the current DateOnly instance and the time specified by the input time.
        """
        ...

    def ToLongDateString(self) -> str:
        """
        Converts the value of the current DateOnly object to its equivalent long date string representation.
        
        :returns: A string that contains the long date string representation of the current DateOnly object.
        """
        ...

    def ToShortDateString(self) -> str:
        """
        Converts the value of the current DateOnly object to its equivalent short date string representation.
        
        :returns: A string that contains the short date string representation of the current DateOnly object.
        """
        ...

    @overload
    def ToString(self) -> str:
        """
        Converts the value of the current DateOnly object to its equivalent string representation using the formatting conventions of the current culture.
        The DateOnly object will be formatted in short form.
        
        :returns: A string that contains the short date string representation of the current DateOnly object.
        """
        ...

    @overload
    def ToString(self, format: str) -> str:
        """
        Converts the value of the current DateOnly object to its equivalent string representation using the specified format and the formatting conventions of the current culture.
        
        :param format: A standard or custom date format string.
        :returns: A string representation of value of the current DateOnly object as specified by format.
        """
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        """
        Converts the value of the current DateOnly object to its equivalent string representation using the specified culture-specific format information.
        
        :param provider: An object that supplies culture-specific formatting information.
        :returns: A string representation of value of the current DateOnly object as specified by provider.
        """
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        """
        Converts the value of the current DateOnly object to its equivalent string representation using the specified culture-specific format information.
        
        :param format: A standard or custom date format string.
        :param provider: An object that supplies culture-specific formatting information.
        :returns: A string representation of value of the current DateOnly object as specified by format and provider.
        """
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        """
        Tries to format the value of the current DateOnly instance into the provided span of characters.
        
        :param destination: When this method returns, this instance's value formatted as a span of characters.
        :param charsWritten: When this method returns, the number of characters that were written in destination.
        :param format: A span containing the characters that represent a standard or custom format string that defines the acceptable format for destination.
        :param provider: An optional object that supplies culture-specific formatting information for destination.
        :returns: true if the formatting was successful; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified span representation of a date to its DateOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing the date to convert.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified array of formats, culture-specific format information, and style. And returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters that represent a date to convert.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified string representation of a date to its DateOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters representing the date to convert.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified string representation of a date to its DateOnly equivalent using the specified array of formats, culture-specific format information, and style. And returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters that represent a date to convert.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that indicates the permitted format of s. A typical value to specify is None.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is empty string, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified format and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing a date to convert.
        :param format: The required format of s.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a date that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], format: System.ReadOnlySpan[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing a date to convert.
        :param format: The required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of one or more enumeration values that indicate the permitted format of s.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a date that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified char span of a date to its DateOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The span containing the string to parse.
        :param formats: An array of allowable formats of s.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: System.ReadOnlySpan[str], formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified char span of a date to its DateOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The span containing the string to parse.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that defines how to interpret the parsed date. A typical value to specify is None.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, format: str, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified string representation of a date to its DateOnly equivalent using the specified format and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A string containing the characters representing a date to convert.
        :param format: The required format of s.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a date that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, format: str, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified span representation of a date to its DateOnly equivalent using the specified format, culture-specific format information, and style.
        The format of the string representation must match the specified format exactly. The method returns a value that indicates whether the conversion succeeded.
        
        :param s: A span containing the characters representing a date to convert.
        :param format: The required format of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of one or more enumeration values that indicate the permitted format of s.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s is empty string, or does not contain a date that correspond to the pattern specified in format. This parameter is passed uninitialized.
        :returns: true if s was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, formats: typing.List[str], result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified string of a date to its DateOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The string containing date to parse.
        :param formats: An array of allowable formats of s.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...

    @staticmethod
    @overload
    def TryParseExact(s: str, formats: typing.List[str], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: typing.Optional[System.DateOnly]) -> typing.Union[bool, System.DateOnly]:
        """
        Converts the specified string of a date to its DateOnly equivalent and returns a value that indicates whether the conversion succeeded.
        
        :param s: The string containing the date to parse.
        :param formats: An array of allowable formats of s.
        :param provider: An object that supplies culture-specific formatting information about s.
        :param style: A bitwise combination of enumeration values that defines how to interpret the parsed date. A typical value to specify is None.
        :param result: When this method returns, contains the DateOnly value equivalent to the date contained in s, if the conversion succeeded, or MinValue if the conversion failed. The conversion fails if the s parameter is Empty, or does not contain a valid string representation of a date. This parameter is passed uninitialized.
        :returns: true if the s parameter was converted successfully; otherwise, false.
        """
        ...


class FieldAccessException(System.MemberAccessException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class UInt128(System.IBinaryInteger[System_UInt128], System.IMinMaxValue[System_UInt128], System.IUnsignedNumber[System_UInt128]):
    """Represents a 128-bit unsigned integer."""

    Size: int = 16

    @property
    def Lower(self) -> int:
        ...

    @property
    def Upper(self) -> int:
        ...

    def __init__(self, upper: int, lower: int) -> None:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: System.UInt128) -> int:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: System.UInt128) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> System.UInt128:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> System.UInt128:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> System.UInt128:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> System.UInt128:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> System.UInt128:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[System.UInt128]) -> typing.Union[bool, System.UInt128]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[System.UInt128]) -> typing.Union[bool, System.UInt128]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.UInt128]) -> typing.Union[bool, System.UInt128]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[System.UInt128]) -> typing.Union[bool, System.UInt128]:
        ...


class CannotUnloadAppDomainException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class TypeInitializationException(System.SystemException):
    """This class has no documentation."""

    @property
    def TypeName(self) -> str:
        ...

    def __init__(self, fullTypeName: str, innerException: System.Exception) -> None:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...


class GCCollectionMode(System.Enum):
    """This class has no documentation."""

    Default = 0

    Forced = 1

    Optimized = 2

    Aggressive = 3


class GCGenerationInfo:
    """This class has no documentation."""

    @property
    def SizeBeforeBytes(self) -> int:
        """Size in bytes on entry to the reported collection."""
        ...

    @property
    def FragmentationBeforeBytes(self) -> int:
        """Fragmentation in bytes on entry to the reported collection."""
        ...

    @property
    def SizeAfterBytes(self) -> int:
        """Size in bytes on exit from the reported collection."""
        ...

    @property
    def FragmentationAfterBytes(self) -> int:
        """Fragmentation in bytes on exit from the reported collection."""
        ...


class GCMemoryInfo:
    """Provides a set of APIs that can be used to retrieve garbage collection information."""

    @property
    def HighMemoryLoadThresholdBytes(self) -> int:
        """High memory load threshold when this GC occurred"""
        ...

    @property
    def MemoryLoadBytes(self) -> int:
        """Memory load when this GC occurred"""
        ...

    @property
    def TotalAvailableMemoryBytes(self) -> int:
        """
        Total available memory for the GC to use when this GC occurred.
        
        If the environment variable COMPlus_GCHeapHardLimit is set,
        or "Server.GC.HeapHardLimit" is in runtimeconfig.json, this will come from that.
        If the program is run in a container, this will be an implementation-defined fraction of the container's size.
        Else, this is the physical memory on the machine that was available for the GC to use when this GC occurred.
        """
        ...

    @property
    def HeapSizeBytes(self) -> int:
        """The total heap size when this GC occurred"""
        ...

    @property
    def FragmentedBytes(self) -> int:
        """
        The total fragmentation when this GC occurred
        
        Let's take the example below:
         | OBJ_A |     OBJ_B     | OBJ_C |   OBJ_D   | OBJ_E |
        
        Let's say OBJ_B, OBJ_C and and OBJ_E are garbage and get collected, but the heap does not get compacted, the resulting heap will look like the following:
         | OBJ_A |           F           |   OBJ_D   |
        
        The memory between OBJ_A and OBJ_D marked `F` is considered part of the FragmentedBytes, and will be used to allocate new objects. The memory after OBJ_D will not be
        considered part of the FragmentedBytes, and will also be used to allocate new objects
        """
        ...

    @property
    def Index(self) -> int:
        """
        The index of this GC. GC indices start with 1 and get increased at the beginning of a GC.
        Since the info is updated at the end of a GC, this means you can get the info for a BGC
        with a smaller index than a foreground GC finished earlier.
        """
        ...

    @property
    def Generation(self) -> int:
        """
        The generation this GC collected. Collecting a generation means all its younger generation(s)
        are also collected.
        """
        ...

    @property
    def Compacted(self) -> bool:
        """Is this a compacting GC or not."""
        ...

    @property
    def Concurrent(self) -> bool:
        """Is this a concurrent GC (BGC) or not."""
        ...

    @property
    def TotalCommittedBytes(self) -> int:
        """Total committed bytes of the managed heap."""
        ...

    @property
    def PromotedBytes(self) -> int:
        """Promoted bytes for this GC."""
        ...

    @property
    def PinnedObjectsCount(self) -> int:
        """Number of pinned objects this GC observed."""
        ...

    @property
    def FinalizationPendingCount(self) -> int:
        """Number of objects ready for finalization this GC observed."""
        ...

    @property
    def PauseDurations(self) -> System.ReadOnlySpan[datetime.timedelta]:
        """Pause durations. For blocking GCs there's only 1 pause; for BGC there are 2."""
        ...

    @property
    def PauseTimePercentage(self) -> float:
        """This is the % pause time in GC so far. If it's 1.2%, this number is 1.2."""
        ...

    @property
    def GenerationInfo(self) -> System.ReadOnlySpan[System.GCGenerationInfo]:
        """Generation info for all generations."""
        ...


class GCKind(System.Enum):
    """This class has no documentation."""

    Any = 0
    """Any kind of collection."""

    Ephemeral = 1
    """A gen0 or gen1 collection."""

    FullBlocking = 2
    """A blocking gen2 collection."""

    Background = 3
    """A background collection."""


class GC(System.Object):
    """This class has no documentation."""

    EPHEMERON_TOMBSTONE: System.Object = ...

    MaxGeneration: int

    @staticmethod
    def AddMemoryPressure(bytesAllocated: int) -> None:
        ...

    @staticmethod
    def AllocateArray(length: int, pinned: bool = False) -> typing.List[System_GC_AllocateArray_T]:
        ...

    @staticmethod
    def AllocateUninitializedArray(length: int, pinned: bool = False) -> typing.List[System_GC_AllocateUninitializedArray_T]:
        ...

    @staticmethod
    def CancelFullGCNotification() -> None:
        ...

    @staticmethod
    @overload
    def Collect(generation: int) -> None:
        ...

    @staticmethod
    @overload
    def Collect() -> None:
        ...

    @staticmethod
    @overload
    def Collect(generation: int, mode: System.GCCollectionMode) -> None:
        ...

    @staticmethod
    @overload
    def Collect(generation: int, mode: System.GCCollectionMode, blocking: bool) -> None:
        ...

    @staticmethod
    @overload
    def Collect(generation: int, mode: System.GCCollectionMode, blocking: bool, compacting: bool) -> None:
        ...

    @staticmethod
    def CollectionCount(generation: int) -> int:
        ...

    @staticmethod
    def EndNoGCRegion() -> None:
        ...

    @staticmethod
    def GetAllocatedBytesForCurrentThread() -> int:
        ...

    @staticmethod
    def GetConfigurationVariables() -> System.Collections.Generic.IReadOnlyDictionary[str, System.Object]:
        ...

    @staticmethod
    @overload
    def GetGCMemoryInfo() -> System.GCMemoryInfo:
        ...

    @staticmethod
    @overload
    def GetGCMemoryInfo(kind: System.GCKind) -> System.GCMemoryInfo:
        ...

    @staticmethod
    @overload
    def GetGeneration(obj: typing.Any) -> int:
        ...

    @staticmethod
    @overload
    def GetGeneration(wo: System.WeakReference) -> int:
        ...

    @staticmethod
    def GetTotalAllocatedBytes(precise: bool = False) -> int:
        ...

    @staticmethod
    def GetTotalMemory(forceFullCollection: bool) -> int:
        ...

    @staticmethod
    def GetTotalPauseDuration() -> datetime.timedelta:
        ...

    @staticmethod
    def KeepAlive(obj: typing.Any) -> None:
        ...

    @staticmethod
    def RegisterForFullGCNotification(maxGenerationThreshold: int, largeObjectHeapThreshold: int) -> None:
        ...

    @staticmethod
    def RemoveMemoryPressure(bytesAllocated: int) -> None:
        ...

    @staticmethod
    def ReRegisterForFinalize(obj: typing.Any) -> None:
        ...

    @staticmethod
    def SuppressFinalize(obj: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def TryStartNoGCRegion(totalSize: int) -> bool:
        ...

    @staticmethod
    @overload
    def TryStartNoGCRegion(totalSize: int, lohSize: int) -> bool:
        ...

    @staticmethod
    @overload
    def TryStartNoGCRegion(totalSize: int, disallowFullBlockingGC: bool) -> bool:
        ...

    @staticmethod
    @overload
    def TryStartNoGCRegion(totalSize: int, lohSize: int, disallowFullBlockingGC: bool) -> bool:
        ...

    @staticmethod
    @overload
    def WaitForFullGCApproach(timeout: datetime.timedelta) -> int:
        """
        Returns, in a specified time-out period, the status of a registered notification for determining whether a full,
        blocking garbage collection by the common language runtime is imminent.
        
        :param timeout: The timeout on waiting for a full GC approach
        :returns: The status of a registered full GC notification. This method returns the int value of a member of the System.GCNotificationStatus enum.
        """
        ...

    @staticmethod
    @overload
    def WaitForFullGCApproach() -> int:
        """:returns: This method returns the int value of a member of the System.GCNotificationStatus enum."""
        ...

    @staticmethod
    @overload
    def WaitForFullGCApproach(millisecondsTimeout: int) -> int:
        """:returns: This method returns the int value of a member of the System.GCNotificationStatus enum."""
        ...

    @staticmethod
    @overload
    def WaitForFullGCComplete(timeout: datetime.timedelta) -> int:
        """
        Returns the status of a registered notification about whether a blocking garbage collection
        has completed. May wait indefinitely for a full collection.
        
        :param timeout: The timeout on waiting for a full collection
        :returns: The status of a registered full GC notification. This method returns the int value of a member of the System.GCNotificationStatus enum.
        """
        ...

    @staticmethod
    @overload
    def WaitForFullGCComplete() -> int:
        """:returns: This method returns the int value of a member of the System.GCNotificationStatus enum."""
        ...

    @staticmethod
    @overload
    def WaitForFullGCComplete(millisecondsTimeout: int) -> int:
        """:returns: This method returns the int value of a member of the System.GCNotificationStatus enum."""
        ...

    @staticmethod
    def WaitForPendingFinalizers() -> None:
        ...


class AccessViolationException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class StringComparer(System.Object, System.Collections.IComparer, System.Collections.IEqualityComparer, System.Collections.Generic.IComparer[str], System.Collections.Generic.IEqualityComparer[str], metaclass=abc.ABCMeta):
    """This class has no documentation."""

    InvariantCulture: System.StringComparer

    InvariantCultureIgnoreCase: System.StringComparer

    CurrentCulture: System.StringComparer

    CurrentCultureIgnoreCase: System.StringComparer

    Ordinal: System.StringComparer

    OrdinalIgnoreCase: System.StringComparer

    @overload
    def Compare(self, x: typing.Any, y: typing.Any) -> int:
        ...

    @overload
    def Compare(self, x: str, y: str) -> int:
        ...

    @staticmethod
    @overload
    def Create(culture: System.Globalization.CultureInfo, ignoreCase: bool) -> System.StringComparer:
        ...

    @staticmethod
    @overload
    def Create(culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions) -> System.StringComparer:
        ...

    @overload
    def Equals(self, x: typing.Any, y: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, x: str, y: str) -> bool:
        ...

    @staticmethod
    def FromComparison(comparisonType: System.StringComparison) -> System.StringComparer:
        ...

    @overload
    def GetHashCode(self, obj: typing.Any) -> int:
        ...

    @overload
    def GetHashCode(self, obj: str) -> int:
        ...

    @staticmethod
    def IsWellKnownCultureAwareComparer(comparer: System.Collections.Generic.IEqualityComparer[str], compareInfo: typing.Optional[System.Globalization.CompareInfo], compareOptions: typing.Optional[System.Globalization.CompareOptions]) -> typing.Union[bool, System.Globalization.CompareInfo, System.Globalization.CompareOptions]:
        """
        Determines whether the specified IEqualityComparer{String} is a well-known culture-aware string comparer.
        
        :param comparer: The comparer to query.
        :param compareInfo: When this method returns, contains a value indicating which CompareInfo was used to create . Set to null if this method returns false.
        :param compareOptions: When this method returns, contains a value indicating which CompareOptions was used to create . Set to CompareOptions.None if this method returns false.
        :returns: true if  is a well-known culture-aware string comparer; otherwise, false.
        """
        ...

    @staticmethod
    def IsWellKnownOrdinalComparer(comparer: System.Collections.Generic.IEqualityComparer[str], ignoreCase: typing.Optional[bool]) -> typing.Union[bool, bool]:
        """
        Determines whether the specified IEqualityComparer{String} is a well-known ordinal string comparer.
        
        :param comparer: The comparer to query.
        :param ignoreCase: When this method returns, contains a value stating whether  is case-insensitive. Set to false if this method returns false.
        :returns: true if  is a well-known ordinal string comparer; otherwise, false.
        """
        ...


class CultureAwareComparer(System.StringComparer, System.Runtime.Serialization.ISerializable):
    """This class has no documentation."""

    InvariantCaseSensitiveInstance: System.CultureAwareComparer = ...

    InvariantIgnoreCaseInstance: System.CultureAwareComparer = ...

    def Compare(self, x: str, y: str) -> int:
        ...

    @overload
    def Equals(self, x: str, y: str) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def GetHashCode(self, obj: str) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        ...


class OrdinalComparer(System.StringComparer):
    """This class has no documentation."""

    def Compare(self, x: str, y: str) -> int:
        ...

    @overload
    def Equals(self, x: str, y: str) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def GetHashCode(self, obj: str) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...


class Int64(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.ISignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = ...

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    NegativeOne: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_Int64_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_Int64_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_Int64_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_Int64_System_Numerics_INumberBase<System_Int64>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class Int16(System.IConvertible, System.IBinaryInteger[int], System.IMinMaxValue[int], System.ISignedNumber[int]):
    """This class has no documentation."""

    MaxValue: int = ...

    MinValue: int = ...

    AdditiveIdentity: int

    AllBitsSet: int

    @property
    def value(self) -> int:
        ...

    @value.setter
    def value(self, value: int):
        ...

    MultiplicativeIdentity: int

    One: int

    Radix: int

    Zero: int

    NegativeOne: int

    @staticmethod
    def () -> int:
        ...

    @staticmethod
    def Abs(value: int) -> int:
        ...

    @staticmethod
    def Clamp(value: int, min: int, max: int) -> int:
        ...

    @overload
    def CompareTo(self, value: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, value: int) -> int:
        ...

    @staticmethod
    def CopySign(value: int, sign: int) -> int:
        ...

    @staticmethod
    def CreateChecked(value: System_Int16_CreateChecked_TOther) -> int:
        ...

    @staticmethod
    def CreateSaturating(value: System_Int16_CreateSaturating_TOther) -> int:
        ...

    @staticmethod
    def CreateTruncating(value: System_Int16_CreateTruncating_TOther) -> int:
        ...

    @staticmethod
    def DivRem(left: int, right: int) -> System.ValueTuple[int, int]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: int) -> bool:
        ...

    def GetByteCount(self) -> int:
        ...

    def GetHashCode(self) -> int:
        ...

    def GetShortestBitLength(self) -> int:
        ...

    def GetTypeCode(self) -> int:
        """:returns: This method returns the int value of a member of the System.TypeCode enum."""
        ...

    @staticmethod
    def IsCanonical(value: int) -> bool:
        ...

    @staticmethod
    def IsComplexNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsEvenInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsFinite(value: int) -> bool:
        ...

    @staticmethod
    def IsImaginaryNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsNaN(value: int) -> bool:
        ...

    @staticmethod
    def IsNegative(value: int) -> bool:
        ...

    @staticmethod
    def IsNegativeInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsNormal(value: int) -> bool:
        ...

    @staticmethod
    def IsOddInteger(value: int) -> bool:
        ...

    @staticmethod
    def IsPositive(value: int) -> bool:
        ...

    @staticmethod
    def IsPositiveInfinity(value: int) -> bool:
        ...

    @staticmethod
    def IsPow2(value: int) -> bool:
        ...

    @staticmethod
    def IsRealNumber(value: int) -> bool:
        ...

    @staticmethod
    def IsSubnormal(value: int) -> bool:
        ...

    @staticmethod
    def IsZero(value: int) -> bool:
        ...

    @staticmethod
    def LeadingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def Log2(value: int) -> int:
        ...

    @staticmethod
    def Max(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MaxNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def Min(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitude(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinMagnitudeNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    def MinNumber(x: int, y: int) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles = ..., provider: System.IFormatProvider = None) -> int:
        ...

    @staticmethod
    @overload
    def Parse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def PopCount(value: int) -> int:
        ...

    @staticmethod
    def RotateLeft(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def RotateRight(value: int, rotateAmount: int) -> int:
        ...

    @staticmethod
    def Sign(value: int) -> int:
        ...

    def ToBoolean(self, provider: System.IFormatProvider) -> bool:
        ...

    def ToByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToChar(self, provider: System.IFormatProvider) -> str:
        ...

    def ToDateTime(self, provider: System.IFormatProvider) -> datetime.datetime:
        ...

    def ToDecimal(self, provider: System.IFormatProvider) -> float:
        ...

    def ToDouble(self, provider: System.IFormatProvider) -> float:
        ...

    def ToInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToInt64(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSByte(self, provider: System.IFormatProvider) -> int:
        ...

    def ToSingle(self, provider: System.IFormatProvider) -> float:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, provider: System.IFormatProvider) -> str:
        ...

    @overload
    def ToString(self, format: str) -> str:
        ...

    @overload
    def ToString(self, format: str, provider: System.IFormatProvider) -> str:
        ...

    def ToType(self, type: typing.Type, provider: System.IFormatProvider) -> System.Object:
        ...

    def ToUInt16(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt32(self, provider: System.IFormatProvider) -> int:
        ...

    def ToUInt64(self, provider: System.IFormatProvider) -> int:
        ...

    @staticmethod
    def TrailingZeroCount(value: int) -> int:
        ...

    @staticmethod
    def TryConvertFromChecked(value: System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromChecked_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromSaturating(value: System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromSaturating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertFromTruncating(value: System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertFromTruncating_TOther, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryConvertToChecked(value: int, result: typing.Optional[System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToChecked_TOther]) -> typing.Union[bool, System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToChecked_TOther]:
        ...

    @staticmethod
    def TryConvertToSaturating(value: int, result: typing.Optional[System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToSaturating_TOther]) -> typing.Union[bool, System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToSaturating_TOther]:
        ...

    @staticmethod
    def TryConvertToTruncating(value: int, result: typing.Optional[System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToTruncating_TOther]) -> typing.Union[bool, System_Int16_System_Numerics_INumberBase<System_Int16>_TryConvertToTruncating_TOther]:
        ...

    def TryFormat(self, destination: System.Span[str], charsWritten: typing.Optional[int], format: System.ReadOnlySpan[str] = ..., provider: System.IFormatProvider = None) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: str, provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    @overload
    def TryParse(s: System.ReadOnlySpan[str], provider: System.IFormatProvider, result: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadBigEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    @staticmethod
    def TryReadLittleEndian(source: System.ReadOnlySpan[int], isUnsigned: bool, value: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteBigEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...

    def TryWriteLittleEndian(self, destination: System.Span[int], bytesWritten: typing.Optional[int]) -> typing.Union[bool, int]:
        ...


class LoaderOptimizationAttribute(System.Attribute):
    """This class has no documentation."""

    @property
    def Value(self) -> int:
        """This property contains the int value of a member of the System.LoaderOptimization enum."""
        ...

    @overload
    def __init__(self, value: int) -> None:
        ...

    @overload
    def __init__(self, value: System.LoaderOptimization) -> None:
        ...


class NonSerializedAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class TimeoutException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class MulticastNotSupportedException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...


class TypeAccessException(System.TypeLoadException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class TimeZoneNotFoundException(System.Exception):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class ParamArrayAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class Tuple(typing.Generic[System_Tuple_T1, System_Tuple_T2, System_Tuple_T3, System_Tuple_T4, System_Tuple_T5, System_Tuple_T6, System_Tuple_T7, System_Tuple_TRest], System.Object, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal):
    """This class has no documentation."""

    @property
    def Item1(self) -> System_Tuple_T1:
        ...

    @property
    def Length(self) -> int:
        """The number of positions in this data structure."""
        ...

    @property
    def Item2(self) -> System_Tuple_T2:
        ...

    @property
    def Item3(self) -> System_Tuple_T3:
        ...

    @property
    def Item4(self) -> System_Tuple_T4:
        ...

    @property
    def Item5(self) -> System_Tuple_T5:
        ...

    @property
    def Item6(self) -> System_Tuple_T6:
        ...

    @property
    def Item7(self) -> System_Tuple_T7:
        ...

    @property
    def Rest(self) -> System_Tuple_TRest:
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __getitem__(self, index: int) -> typing.Any:
        """Get the element at position ."""
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2, item3: System_Tuple_T3) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2, item3: System_Tuple_T3, item4: System_Tuple_T4) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2, item3: System_Tuple_T3, item4: System_Tuple_T4, item5: System_Tuple_T5) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2, item3: System_Tuple_T3, item4: System_Tuple_T4, item5: System_Tuple_T5, item6: System_Tuple_T6) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2, item3: System_Tuple_T3, item4: System_Tuple_T4, item5: System_Tuple_T5, item6: System_Tuple_T6, item7: System_Tuple_T7) -> None:
        ...

    @overload
    def __init__(self, item1: System_Tuple_T1, item2: System_Tuple_T2, item3: System_Tuple_T3, item4: System_Tuple_T4, item5: System_Tuple_T5, item6: System_Tuple_T6, item7: System_Tuple_T7, rest: System_Tuple_TRest) -> None:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @overload
    def CompareTo(self, obj: typing.Any) -> int:
        ...

    @overload
    def CompareTo(self, other: typing.Any, comparer: System.Collections.IComparer) -> int:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1) -> System.Tuple[System_Tuple_Create_T1]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2, item3: System_Tuple_Create_T3) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2, System_Tuple_Create_T3]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2, item3: System_Tuple_Create_T3, item4: System_Tuple_Create_T4) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2, System_Tuple_Create_T3, System_Tuple_Create_T4]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2, item3: System_Tuple_Create_T3, item4: System_Tuple_Create_T4, item5: System_Tuple_Create_T5) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2, System_Tuple_Create_T3, System_Tuple_Create_T4, System_Tuple_Create_T5]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2, item3: System_Tuple_Create_T3, item4: System_Tuple_Create_T4, item5: System_Tuple_Create_T5, item6: System_Tuple_Create_T6) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2, System_Tuple_Create_T3, System_Tuple_Create_T4, System_Tuple_Create_T5, System_Tuple_Create_T6]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2, item3: System_Tuple_Create_T3, item4: System_Tuple_Create_T4, item5: System_Tuple_Create_T5, item6: System_Tuple_Create_T6, item7: System_Tuple_Create_T7) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2, System_Tuple_Create_T3, System_Tuple_Create_T4, System_Tuple_Create_T5, System_Tuple_Create_T6, System_Tuple_Create_T7]:
        ...

    @staticmethod
    @overload
    def Create(item1: System_Tuple_Create_T1, item2: System_Tuple_Create_T2, item3: System_Tuple_Create_T3, item4: System_Tuple_Create_T4, item5: System_Tuple_Create_T5, item6: System_Tuple_Create_T6, item7: System_Tuple_Create_T7, item8: System_Tuple_Create_T8) -> System.Tuple[System_Tuple_Create_T1, System_Tuple_Create_T2, System_Tuple_Create_T3, System_Tuple_Create_T4, System_Tuple_Create_T5, System_Tuple_Create_T6, System_Tuple_Create_T7, System.Tuple[System_Tuple_Create_T8]]:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def Equals(self, obj: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, other: typing.Any, comparer: System.Collections.IEqualityComparer) -> bool:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def GetHashCode(self, comparer: System.Collections.IEqualityComparer) -> int:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...

    @overload
    def ToString(self) -> str:
        ...

    @overload
    def ToString(self, sb: System.Text.StringBuilder) -> str:
        ...


class TupleExtensions(System.Object):
    """Provides extension methods for Tuple instances to interop with C# tuples features (deconstruction syntax, converting from and to ValueTuple)."""

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1]:
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2]:
        """Deconstruct a properly nested Tuple with 2 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3]:
        """Deconstruct a properly nested Tuple with 3 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4]:
        """Deconstruct a properly nested Tuple with 4 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5]:
        """Deconstruct a properly nested Tuple with 5 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6]:
        """Deconstruct a properly nested Tuple with 6 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7]:
        """Deconstruct a properly nested Tuple with 7 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8]:
        """Deconstruct a properly nested Tuple with 8 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9]:
        """Deconstruct a properly nested Tuple with 9 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10]:
        """Deconstruct a properly nested Tuple with 10 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11]:
        """Deconstruct a properly nested Tuple with 11 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12]:
        """Deconstruct a properly nested Tuple with 12 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13]:
        """Deconstruct a properly nested Tuple with 13 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14]:
        """Deconstruct a properly nested Tuple with 14 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15]:
        """Deconstruct a properly nested Tuple with 15 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15], item16: typing.Optional[System_TupleExtensions_Deconstruct_T16]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16]:
        """Deconstruct a properly nested Tuple with 16 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15], item16: typing.Optional[System_TupleExtensions_Deconstruct_T16], item17: typing.Optional[System_TupleExtensions_Deconstruct_T17]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17]:
        """Deconstruct a properly nested Tuple with 17 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15], item16: typing.Optional[System_TupleExtensions_Deconstruct_T16], item17: typing.Optional[System_TupleExtensions_Deconstruct_T17], item18: typing.Optional[System_TupleExtensions_Deconstruct_T18]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18]:
        """Deconstruct a properly nested Tuple with 18 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18, System_TupleExtensions_Deconstruct_T19]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15], item16: typing.Optional[System_TupleExtensions_Deconstruct_T16], item17: typing.Optional[System_TupleExtensions_Deconstruct_T17], item18: typing.Optional[System_TupleExtensions_Deconstruct_T18], item19: typing.Optional[System_TupleExtensions_Deconstruct_T19]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18, System_TupleExtensions_Deconstruct_T19]:
        """Deconstruct a properly nested Tuple with 19 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18, System_TupleExtensions_Deconstruct_T19, System_TupleExtensions_Deconstruct_T20]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15], item16: typing.Optional[System_TupleExtensions_Deconstruct_T16], item17: typing.Optional[System_TupleExtensions_Deconstruct_T17], item18: typing.Optional[System_TupleExtensions_Deconstruct_T18], item19: typing.Optional[System_TupleExtensions_Deconstruct_T19], item20: typing.Optional[System_TupleExtensions_Deconstruct_T20]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18, System_TupleExtensions_Deconstruct_T19, System_TupleExtensions_Deconstruct_T20]:
        """Deconstruct a properly nested Tuple with 20 elements."""
        ...

    @staticmethod
    @overload
    def Deconstruct(value: System.Tuple[System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System.Tuple[System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System.Tuple[System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18, System_TupleExtensions_Deconstruct_T19, System_TupleExtensions_Deconstruct_T20, System_TupleExtensions_Deconstruct_T21]]], item1: typing.Optional[System_TupleExtensions_Deconstruct_T1], item2: typing.Optional[System_TupleExtensions_Deconstruct_T2], item3: typing.Optional[System_TupleExtensions_Deconstruct_T3], item4: typing.Optional[System_TupleExtensions_Deconstruct_T4], item5: typing.Optional[System_TupleExtensions_Deconstruct_T5], item6: typing.Optional[System_TupleExtensions_Deconstruct_T6], item7: typing.Optional[System_TupleExtensions_Deconstruct_T7], item8: typing.Optional[System_TupleExtensions_Deconstruct_T8], item9: typing.Optional[System_TupleExtensions_Deconstruct_T9], item10: typing.Optional[System_TupleExtensions_Deconstruct_T10], item11: typing.Optional[System_TupleExtensions_Deconstruct_T11], item12: typing.Optional[System_TupleExtensions_Deconstruct_T12], item13: typing.Optional[System_TupleExtensions_Deconstruct_T13], item14: typing.Optional[System_TupleExtensions_Deconstruct_T14], item15: typing.Optional[System_TupleExtensions_Deconstruct_T15], item16: typing.Optional[System_TupleExtensions_Deconstruct_T16], item17: typing.Optional[System_TupleExtensions_Deconstruct_T17], item18: typing.Optional[System_TupleExtensions_Deconstruct_T18], item19: typing.Optional[System_TupleExtensions_Deconstruct_T19], item20: typing.Optional[System_TupleExtensions_Deconstruct_T20], item21: typing.Optional[System_TupleExtensions_Deconstruct_T21]) -> typing.Union[None, System_TupleExtensions_Deconstruct_T1, System_TupleExtensions_Deconstruct_T2, System_TupleExtensions_Deconstruct_T3, System_TupleExtensions_Deconstruct_T4, System_TupleExtensions_Deconstruct_T5, System_TupleExtensions_Deconstruct_T6, System_TupleExtensions_Deconstruct_T7, System_TupleExtensions_Deconstruct_T8, System_TupleExtensions_Deconstruct_T9, System_TupleExtensions_Deconstruct_T10, System_TupleExtensions_Deconstruct_T11, System_TupleExtensions_Deconstruct_T12, System_TupleExtensions_Deconstruct_T13, System_TupleExtensions_Deconstruct_T14, System_TupleExtensions_Deconstruct_T15, System_TupleExtensions_Deconstruct_T16, System_TupleExtensions_Deconstruct_T17, System_TupleExtensions_Deconstruct_T18, System_TupleExtensions_Deconstruct_T19, System_TupleExtensions_Deconstruct_T20, System_TupleExtensions_Deconstruct_T21]:
        """Deconstruct a properly nested Tuple with 21 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1]) -> System.Tuple[System_TupleExtensions_ToTuple_T1]:
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 2 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 3 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 4 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 5 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 6 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 7 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 8 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 9 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 10 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 11 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 12 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 13 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 14 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 15 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 16 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 17 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 18 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18, System_TupleExtensions_ToTuple_T19]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18, System_TupleExtensions_ToTuple_T19]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 19 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18, System_TupleExtensions_ToTuple_T19, System_TupleExtensions_ToTuple_T20]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18, System_TupleExtensions_ToTuple_T19, System_TupleExtensions_ToTuple_T20]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 20 elements."""
        ...

    @staticmethod
    @overload
    def ToTuple(value: System.ValueTuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.ValueTuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.ValueTuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18, System_TupleExtensions_ToTuple_T19, System_TupleExtensions_ToTuple_T20, System_TupleExtensions_ToTuple_T21]]]) -> System.Tuple[System_TupleExtensions_ToTuple_T1, System_TupleExtensions_ToTuple_T2, System_TupleExtensions_ToTuple_T3, System_TupleExtensions_ToTuple_T4, System_TupleExtensions_ToTuple_T5, System_TupleExtensions_ToTuple_T6, System_TupleExtensions_ToTuple_T7, System.Tuple[System_TupleExtensions_ToTuple_T8, System_TupleExtensions_ToTuple_T9, System_TupleExtensions_ToTuple_T10, System_TupleExtensions_ToTuple_T11, System_TupleExtensions_ToTuple_T12, System_TupleExtensions_ToTuple_T13, System_TupleExtensions_ToTuple_T14, System.Tuple[System_TupleExtensions_ToTuple_T15, System_TupleExtensions_ToTuple_T16, System_TupleExtensions_ToTuple_T17, System_TupleExtensions_ToTuple_T18, System_TupleExtensions_ToTuple_T19, System_TupleExtensions_ToTuple_T20, System_TupleExtensions_ToTuple_T21]]]:
        """Make a properly nested Tuple from a properly nested ValueTuple with 21 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1]:
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 2 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 3 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 4 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 5 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 6 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 7 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 8 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 9 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 10 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 11 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 12 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 13 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 14 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 15 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 16 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 17 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 18 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18, System_TupleExtensions_ToValueTuple_T19]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18, System_TupleExtensions_ToValueTuple_T19]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 19 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18, System_TupleExtensions_ToValueTuple_T19, System_TupleExtensions_ToValueTuple_T20]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18, System_TupleExtensions_ToValueTuple_T19, System_TupleExtensions_ToValueTuple_T20]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 20 elements."""
        ...

    @staticmethod
    @overload
    def ToValueTuple(value: System.Tuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.Tuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.Tuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18, System_TupleExtensions_ToValueTuple_T19, System_TupleExtensions_ToValueTuple_T20, System_TupleExtensions_ToValueTuple_T21]]]) -> System.ValueTuple[System_TupleExtensions_ToValueTuple_T1, System_TupleExtensions_ToValueTuple_T2, System_TupleExtensions_ToValueTuple_T3, System_TupleExtensions_ToValueTuple_T4, System_TupleExtensions_ToValueTuple_T5, System_TupleExtensions_ToValueTuple_T6, System_TupleExtensions_ToValueTuple_T7, System.ValueTuple[System_TupleExtensions_ToValueTuple_T8, System_TupleExtensions_ToValueTuple_T9, System_TupleExtensions_ToValueTuple_T10, System_TupleExtensions_ToValueTuple_T11, System_TupleExtensions_ToValueTuple_T12, System_TupleExtensions_ToValueTuple_T13, System_TupleExtensions_ToValueTuple_T14, System.ValueTuple[System_TupleExtensions_ToValueTuple_T15, System_TupleExtensions_ToValueTuple_T16, System_TupleExtensions_ToValueTuple_T17, System_TupleExtensions_ToValueTuple_T18, System_TupleExtensions_ToValueTuple_T19, System_TupleExtensions_ToValueTuple_T20, System_TupleExtensions_ToValueTuple_T21]]]:
        """Make a properly nested ValueTuple from a properly nested Tuple with 21 elements."""
        ...


class ArgumentNullException(System.ArgumentException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, paramName: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, paramName: str, message: str) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...

    @staticmethod
    @overload
    def ThrowIfNull(argument: typing.Any, paramName: str = None) -> None:
        """
        Throws an ArgumentNullException if  is null.
        
        :param argument: The reference type argument to validate as non-null.
        :param paramName: The name of the parameter with which  corresponds.
        """
        ...

    @staticmethod
    @overload
    def ThrowIfNull(argument: typing.Any, paramName: str = None) -> None:
        """
        Throws an ArgumentNullException if  is null.
        
        :param argument: The pointer argument to validate as non-null.
        :param paramName: The name of the parameter with which  corresponds.
        """
        ...


class StringNormalizationExtensions(System.Object):
    """This class has no documentation."""

    @staticmethod
    @overload
    def IsNormalized(strInput: str) -> bool:
        ...

    @staticmethod
    @overload
    def IsNormalized(strInput: str, normalizationForm: System.Text.NormalizationForm) -> bool:
        ...

    @staticmethod
    @overload
    def Normalize(strInput: str) -> str:
        ...

    @staticmethod
    @overload
    def Normalize(strInput: str, normalizationForm: System.Text.NormalizationForm) -> str:
        ...


class InvalidCastException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, message: str, errorCode: int) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class NullReferenceException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class OperationCanceledException(System.SystemException):
    """This class has no documentation."""

    @property
    def CancellationToken(self) -> System.Threading.CancellationToken:
        ...

    @CancellationToken.setter
    def CancellationToken(self, value: System.Threading.CancellationToken):
        ...

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, token: System.Threading.CancellationToken) -> None:
        ...

    @overload
    def __init__(self, message: str, token: System.Threading.CancellationToken) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception, token: System.Threading.CancellationToken) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class IDisposable(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def Dispose(self) -> None:
        ...


class FlagsAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class ThreadStaticAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class TypeUnloadedException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class STAThreadAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class MTAThreadAttribute(System.Attribute):
    """This class has no documentation."""

    def __init__(self) -> None:
        ...


class UnauthorizedAccessException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, inner: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class AttributeUsageAttribute(System.Attribute):
    """This class has no documentation."""

    Default: System.AttributeUsageAttribute = ...

    @property
    def ValidOn(self) -> int:
        """This property contains the int value of a member of the System.AttributeTargets enum."""
        ...

    @property
    def AllowMultiple(self) -> bool:
        ...

    @AllowMultiple.setter
    def AllowMultiple(self, value: bool):
        ...

    @property
    def Inherited(self) -> bool:
        ...

    @Inherited.setter
    def Inherited(self, value: bool):
        ...

    def __init__(self, validOn: System.AttributeTargets) -> None:
        ...


class ArrayTypeMismatchException(System.SystemException):
    """This class has no documentation."""

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, message: str) -> None:
        ...

    @overload
    def __init__(self, message: str, innerException: System.Exception) -> None:
        ...

    @overload
    def __init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None:
        """This method is protected."""
        ...


class IObservable(typing.Generic[System_IObservable_T], metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def Subscribe(self, observer: System.IObserver[System_IObservable_T]) -> System.IDisposable:
        ...


class ICustomFormatter(metaclass=abc.ABCMeta):
    """This class has no documentation."""

    def Format(self, format: str, arg: typing.Any, formatProvider: System.IFormatProvider) -> str:
        ...


class GCNotificationStatus(System.Enum):
    """This class has no documentation."""

    Succeeded = 0

    Failed = 1

    Canceled = 2

    Timeout = 3

    NotApplicable = 4


class UriTypeConverter(System.ComponentModel.TypeConverter):
    """
    Provides a type converter to convert Uri objects to and from
    various other representations.
    """

    def CanConvertFrom(self, context: System.ComponentModel.ITypeDescriptorContext, sourceType: typing.Type) -> bool:
        """
        Gets a value indicating whether this converter can convert an object in the
        given source type to a Uri.
        """
        ...

    def CanConvertTo(self, context: System.ComponentModel.ITypeDescriptorContext, destinationType: typing.Type) -> bool:
        """
        Gets a value indicating whether this converter can
        convert an object to the given destination type using the context.
        """
        ...

    def ConvertFrom(self, context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: typing.Any) -> System.Object:
        """Converts the given object to the a Uri."""
        ...

    def ConvertTo(self, context: System.ComponentModel.ITypeDescriptorContext, culture: System.Globalization.CultureInfo, value: typing.Any, destinationType: typing.Type) -> System.Object:
        """
        Converts the given value object to
        the specified destination type using the specified context and arguments.
        """
        ...

    def IsValid(self, context: System.ComponentModel.ITypeDescriptorContext, value: typing.Any) -> bool:
        ...


class ConsoleColor(System.Enum):
    """This class has no documentation."""

    Black = 0

    DarkBlue = 1

    DarkGreen = 2

    DarkCyan = 3

    DarkRed = 4

    DarkMagenta = 5

    DarkYellow = 6

    Gray = 7

    DarkGray = 8

    Blue = 9

    Green = 10

    Cyan = 11

    Red = 12

    Magenta = 13

    Yellow = 14

    White = 15


class ConsoleCancelEventArgs(System.EventArgs):
    """This class has no documentation."""

    @property
    def Cancel(self) -> bool:
        ...

    @Cancel.setter
    def Cancel(self, value: bool):
        ...

    @property
    def SpecialKey(self) -> int:
        """This property contains the int value of a member of the System.ConsoleSpecialKey enum."""
        ...


class ConsoleKey(System.Enum):
    """This class has no documentation."""

    Backspace = ...

    Tab = ...

    Clear = ...

    Enter = ...

    Pause = ...

    Escape = ...

    Spacebar = ...

    PageUp = ...

    PageDown = ...

    End = ...

    Home = ...

    LeftArrow = ...

    UpArrow = ...

    RightArrow = ...

    DownArrow = ...

    Select = ...

    Print = ...

    Execute = ...

    PrintScreen = ...

    Insert = ...

    Delete = ...

    Help = ...

    D0 = ...

    D1 = ...

    D2 = ...

    D3 = ...

    D4 = ...

    D5 = ...

    D6 = ...

    D7 = ...

    D8 = ...

    D9 = ...

    A = ...

    B = ...

    C = ...

    D = ...

    E = ...

    F = ...

    G = ...

    H = ...

    I = ...

    J = ...

    K = ...

    L = ...

    M = ...

    N = ...

    O = ...

    P = ...

    Q = ...

    R = ...

    S = ...

    T = ...

    U = ...

    V = ...

    W = ...

    X = ...

    Y = ...

    Z = ...

    LeftWindows = ...

    RightWindows = ...

    Applications = ...

    Sleep = ...

    NumPad0 = ...

    NumPad1 = ...

    NumPad2 = ...

    NumPad3 = ...

    NumPad4 = ...

    NumPad5 = ...

    NumPad6 = ...

    NumPad7 = ...

    NumPad8 = ...

    NumPad9 = ...

    Multiply = ...

    Add = ...

    Separator = ...

    Subtract = ...

    Decimal = ...

    Divide = ...

    F1 = ...

    F2 = ...

    F3 = ...

    F4 = ...

    F5 = ...

    F6 = ...

    F7 = ...

    F8 = ...

    F9 = ...

    F10 = ...

    F11 = ...

    F12 = ...

    F13 = ...

    F14 = ...

    F15 = ...

    F16 = ...

    F17 = ...

    F18 = ...

    F19 = ...

    F20 = ...

    F21 = ...

    F22 = ...

    F23 = ...

    F24 = ...

    BrowserBack = ...

    BrowserForward = ...

    BrowserRefresh = ...

    BrowserStop = ...

    BrowserSearch = ...

    BrowserFavorites = ...

    BrowserHome = ...

    VolumeMute = ...

    VolumeDown = ...

    VolumeUp = ...

    MediaNext = ...

    MediaPrevious = ...

    MediaStop = ...

    MediaPlay = ...

    LaunchMail = ...

    LaunchMediaSelect = ...

    LaunchApp1 = ...

    LaunchApp2 = ...

    Oem1 = ...

    OemPlus = ...

    OemComma = ...

    OemMinus = ...

    OemPeriod = ...

    Oem2 = ...

    Oem3 = ...

    Oem4 = ...

    Oem5 = ...

    Oem6 = ...

    Oem7 = ...

    Oem8 = ...

    Oem102 = ...

    Process = ...

    Packet = ...

    Attention = ...

    CrSel = ...

    ExSel = ...

    EraseEndOfFile = ...

    Play = ...

    Zoom = ...

    NoName = ...

    Pa1 = ...

    OemClear = ...


class ConsoleKeyInfo(System.IEquatable[System_ConsoleKeyInfo]):
    """This class has no documentation."""

    @property
    def KeyChar(self) -> str:
        ...

    @property
    def Key(self) -> int:
        """This property contains the int value of a member of the System.ConsoleKey enum."""
        ...

    @property
    def Modifiers(self) -> int:
        """This property contains the int value of a member of the System.ConsoleModifiers enum."""
        ...

    def __init__(self, keyChar: str, key: System.ConsoleKey, shift: bool, alt: bool, control: bool) -> None:
        ...

    @overload
    def Equals(self, value: typing.Any) -> bool:
        ...

    @overload
    def Equals(self, obj: System.ConsoleKeyInfo) -> bool:
        ...

    def GetHashCode(self) -> int:
        ...


class ConsoleModifiers(System.Enum):
    """This class has no documentation."""

    Alt = 1

    Shift = 2

    Control = 4


class Console(System.Object):
    """This class has no documentation."""

    ReadBufferSize: int = 4096

    In: System.IO.TextReader

    InputEncoding: System.Text.Encoding

    OutputEncoding: System.Text.Encoding

    KeyAvailable: bool

    Out: System.IO.TextWriter

    Error: System.IO.TextWriter

    IsInputRedirected: bool

    IsOutputRedirected: bool

    IsErrorRedirected: bool

    CursorSize: int

    NumberLock: bool

    CapsLock: bool

    UnknownColor: System.ConsoleColor = ...

    BackgroundColor: int
    """This property contains the int value of a member of the System.ConsoleColor enum."""

    ForegroundColor: int
    """This property contains the int value of a member of the System.ConsoleColor enum."""

    BufferWidth: int

    BufferHeight: int

    WindowLeft: int

    WindowTop: int

    WindowWidth: int

    WindowHeight: int

    LargestWindowWidth: int

    LargestWindowHeight: int

    CursorVisible: bool

    CursorLeft: int

    CursorTop: int

    Title: str

    CancelKeyPress: _EventContainer[typing.Callable[[System.Object, System.ConsoleCancelEventArgs], None], None]

    TreatControlCAsInput: bool

    @staticmethod
    @overload
    def Beep() -> None:
        ...

    @staticmethod
    @overload
    def Beep(frequency: int, duration: int) -> None:
        ...

    @staticmethod
    def Clear() -> None:
        ...

    @staticmethod
    def GetCursorPosition() -> System.ValueTuple[int, int]:
        """
        Gets the position of the cursor.
        
        :returns: The column and row position of the cursor.
        """
        ...

    @staticmethod
    @overload
    def MoveBufferArea(sourceLeft: int, sourceTop: int, sourceWidth: int, sourceHeight: int, targetLeft: int, targetTop: int) -> None:
        ...

    @staticmethod
    @overload
    def MoveBufferArea(sourceLeft: int, sourceTop: int, sourceWidth: int, sourceHeight: int, targetLeft: int, targetTop: int, sourceChar: str, sourceForeColor: System.ConsoleColor, sourceBackColor: System.ConsoleColor) -> None:
        ...

    @staticmethod
    @overload
    def OpenStandardError() -> System.IO.Stream:
        ...

    @staticmethod
    @overload
    def OpenStandardError(bufferSize: int) -> System.IO.Stream:
        ...

    @staticmethod
    @overload
    def OpenStandardInput() -> System.IO.Stream:
        ...

    @staticmethod
    @overload
    def OpenStandardInput(bufferSize: int) -> System.IO.Stream:
        ...

    @staticmethod
    @overload
    def OpenStandardOutput() -> System.IO.Stream:
        ...

    @staticmethod
    @overload
    def OpenStandardOutput(bufferSize: int) -> System.IO.Stream:
        ...

    @staticmethod
    def Read() -> int:
        ...

    @staticmethod
    @overload
    def ReadKey() -> System.ConsoleKeyInfo:
        ...

    @staticmethod
    @overload
    def ReadKey(intercept: bool) -> System.ConsoleKeyInfo:
        ...

    @staticmethod
    def ReadLine() -> str:
        ...

    @staticmethod
    def ResetColor() -> None:
        ...

    @staticmethod
    def SetBufferSize(width: int, height: int) -> None:
        ...

    @staticmethod
    def SetCursorPosition(left: int, top: int) -> None:
        ...

    @staticmethod
    def SetError(newError: System.IO.TextWriter) -> None:
        ...

    @staticmethod
    def SetIn(newIn: System.IO.TextReader) -> None:
        ...

    @staticmethod
    def SetOut(newOut: System.IO.TextWriter) -> None:
        ...

    @staticmethod
    def SetWindowPosition(left: int, top: int) -> None:
        ...

    @staticmethod
    def SetWindowSize(width: int, height: int) -> None:
        ...

    @staticmethod
    @overload
    def Write(format: str, arg0: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Write(format: str, arg0: typing.Any, arg1: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Write(format: str, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Write(format: str, *arg: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: bool) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: str) -> None:
        ...

    @staticmethod
    @overload
    def Write(buffer: typing.List[str]) -> None:
        ...

    @staticmethod
    @overload
    def Write(buffer: typing.List[str], index: int, count: int) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: float) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: float) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: float) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: int) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: int) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: int) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: int) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def Write(value: str) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine() -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: bool) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: str) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(buffer: typing.List[str]) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(buffer: typing.List[str], index: int, count: int) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: float) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: float) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: float) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: int) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: int) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: int) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: int) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(value: str) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(format: str, arg0: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(format: str, arg0: typing.Any, arg1: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(format: str, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> None:
        ...

    @staticmethod
    @overload
    def WriteLine(format: str, *arg: typing.Any) -> None:
        ...


class ConsoleSpecialKey(System.Enum):
    """This class has no documentation."""

    ControlC = 0

    ControlBreak = 1


class _EventContainer(typing.Generic[System__EventContainer_Callable, System__EventContainer_ReturnType]):
    """This class is used to provide accurate autocomplete on events and cannot be imported."""

    def __call__(self, *args: typing.Any, **kwargs: typing.Any) -> System__EventContainer_ReturnType:
        """Fires the event."""
        ...

    def __iadd__(self, item: System__EventContainer_Callable) -> None:
        """Registers an event handler."""
        ...

    def __isub__(self, item: System__EventContainer_Callable) -> None:
        """Unregisters an event handler."""
        ...


